'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('util').inherits;
const getSingleProperty = require('./utils').getSingleProperty;
const CommandCursor = require('./command_cursor');
const handleCallback = require('./utils').handleCallback;
const filterOptions = require('./utils').filterOptions;
const toError = require('./utils').toError;
const ReadPreference = require('mongodb-core').ReadPreference;
const MongoError = require('mongodb-core').MongoError;
const ObjectID = require('mongodb-core').ObjectID;
const Logger = require('mongodb-core').Logger;
const Collection = require('./collection');
const mergeOptionsAndWriteConcern = require('./utils').mergeOptionsAndWriteConcern;
const executeOperation = require('./utils').executeOperation;
const applyWriteConcern = require('./utils').applyWriteConcern;
const resolveReadPreference = require('./utils').resolveReadPreference;
const ChangeStream = require('./change_stream');
const deprecate = require('util').deprecate;
const deprecateOptions = require('./utils').deprecateOptions;
const CONSTANTS = require('./constants');

// Operations
const addUser = require('./operations/db_ops').addUser;
const aggregate = require('./operations/aggregate').aggregate;
const collections = require('./operations/db_ops').collections;
const createCollection = require('./operations/db_ops').createCollection;
const createIndex = require('./operations/db_ops').createIndex;
const createListener = require('./operations/db_ops').createListener;
const dropCollection = require('./operations/db_ops').dropCollection;
const dropDatabase = require('./operations/db_ops').dropDatabase;
const ensureIndex = require('./operations/db_ops').ensureIndex;
const evaluate = require('./operations/db_ops').evaluate;
const executeCommand = require('./operations/db_ops').executeCommand;
const executeDbAdminCommand = require('./operations/db_ops').executeDbAdminCommand;
const indexInformation = require('./operations/db_ops').indexInformation;
const listCollectionsTransforms = require('./operations/db_ops').listCollectionsTransforms;
const profilingInfo = require('./operations/db_ops').profilingInfo;
const profilingLevel = require('./operations/db_ops').profilingLevel;
const removeUser = require('./operations/db_ops').removeUser;
const setProfilingLevel = require('./operations/db_ops').setProfilingLevel;
const validateDatabaseName = require('./operations/db_ops').validateDatabaseName;

/**
 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
 *
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Select the database by name
 *   const testDb = client.db(dbName);
 *   client.close();
 * });
 */

// Allowed parameters
const legalOptionNames = [
  'w',
  'wtimeout',
  'fsync',
  'j',
  'readPreference',
  'readPreferenceTags',
  'native_parser',
  'forceServerObjectId',
  'pkFactory',
  'serializeFunctions',
  'raw',
  'bufferMaxEntries',
  'authSource',
  'ignoreUndefined',
  'promoteLongs',
  'promiseLibrary',
  'readConcern',
  'retryMiliSeconds',
  'numberOfRetries',
  'parentDb',
  'noListener',
  'loggerLevel',
  'logger',
  'promoteBuffers',
  'promoteLongs',
  'promoteValues',
  'compression',
  'retryWrites'
];

/**
 * Creates a new Db instance
 * @class
 * @param {string} databaseName The name of the database this instance represents.
 * @param {(Server|ReplSet|Mongos)} topology The server topology for the database.
 * @param {object} [options] Optional settings.
 * @param {string} [options.authSource] If the database authentication is dependent on another databaseName.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.
 * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param {object} [options.readConcern] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param {ReadConcernLevel} [options.readConcern.level='local'] Specify a read concern level for the collection operations (only MongoDB 3.2 or higher supported)
 * @property {(Server|ReplSet|Mongos)} serverConfig Get the current db topology.
 * @property {number} bufferMaxEntries Current bufferMaxEntries value for the database
 * @property {string} databaseName The name of the database this instance represents.
 * @property {object} options The options associated with the db instance.
 * @property {boolean} native_parser The current value of the parameter native_parser.
 * @property {boolean} slaveOk The current slaveOk value for the db instance.
 * @property {object} writeConcern The current write concern values.
 * @property {object} topology Access the topology object (single server, replicaset or mongos).
 * @fires Db#close
 * @fires Db#reconnect
 * @fires Db#error
 * @fires Db#timeout
 * @fires Db#parseError
 * @fires Db#fullsetup
 * @return {Db} a Db instance.
 */
function Db(databaseName, topology, options) {
  options = options || {};
  if (!(this instanceof Db)) return new Db(databaseName, topology, options);
  EventEmitter.call(this);

  // Get the promiseLibrary
  const promiseLibrary = options.promiseLibrary || Promise;

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Ensure we put the promiseLib in the options
  options.promiseLibrary = promiseLibrary;

  // Internal state of the db object
  this.s = {
    // Database name
    databaseName: databaseName,
    // DbCache
    dbCache: {},
    // Children db's
    children: [],
    // Topology
    topology: topology,
    // Options
    options: options,
    // Logger instance
    logger: Logger('Db', options),
    // Get the bson parser
    bson: topology ? topology.bson : null,
    // Unpack read preference
    readPreference: options.readPreference,
    // Set buffermaxEntries
    bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : -1,
    // Parent db (if chained)
    parentDb: options.parentDb || null,
    // Set up the primary key factory or fallback to ObjectID
    pkFactory: options.pkFactory || ObjectID,
    // Get native parser
    nativeParser: options.nativeParser || options.native_parser,
    // Promise library
    promiseLibrary: promiseLibrary,
    // No listener
    noListener: typeof options.noListener === 'boolean' ? options.noListener : false,
    // ReadConcern
    readConcern: options.readConcern
  };

  // Ensure we have a valid db name
  validateDatabaseName(this.s.databaseName);

  // Add a read Only property
  getSingleProperty(this, 'serverConfig', this.s.topology);
  getSingleProperty(this, 'bufferMaxEntries', this.s.bufferMaxEntries);
  getSingleProperty(this, 'databaseName', this.s.databaseName);

  // This is a child db, do not register any listeners
  if (options.parentDb) return;
  if (this.s.noListener) return;

  // Add listeners
  topology.on('error', createListener(this, 'error', this));
  topology.on('timeout', createListener(this, 'timeout', this));
  topology.on('close', createListener(this, 'close', this));
  topology.on('parseError', createListener(this, 'parseError', this));
  topology.once('open', createListener(this, 'open', this));
  topology.once('fullsetup', createListener(this, 'fullsetup', this));
  topology.once('all', createListener(this, 'all', this));
  topology.on('reconnect', createListener(this, 'reconnect', this));
}

inherits(Db, EventEmitter);

// Topology
Object.defineProperty(Db.prototype, 'topology', {
  enumerable: true,
  get: function() {
    return this.s.topology;
  }
});

// Options
Object.defineProperty(Db.prototype, 'options', {
  enumerable: true,
  get: function() {
    return this.s.options;
  }
});

// slaveOk specified
Object.defineProperty(Db.prototype, 'slaveOk', {
  enumerable: true,
  get: function() {
    if (
      this.s.options.readPreference != null &&
      (this.s.options.readPreference !== 'primary' ||
        this.s.options.readPreference.mode !== 'primary')
    ) {
      return true;
    }
    return false;
  }
});

// get the write Concern
Object.defineProperty(Db.prototype, 'writeConcern', {
  enumerable: true,
  get: function() {
    const ops = {};
    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  }
});

/**
 * Execute a command
 * @method
 * @param {object} command The command hash
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.command = function(command, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);

  return executeOperation(this.s.topology, executeCommand, [this, command, options, callback]);
};

/**
 * Execute an aggregation framework pipeline against the database, needs MongoDB >= 3.6
 * @method
 * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object} [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
 * @param {number} [options.cursor.batchSize] The batchSize for the cursor
 * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
 * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
 * @param {number} [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {string} [options.comment] Add a comment to an aggregation command
 * @param {string|object} [options.hint] Add an index selection hint to an aggregation command
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Database~aggregationCallback} callback The command result callback
 * @return {(null|AggregationCursor)}
 */
Db.prototype.aggregate = function(pipeline, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  // If we have no options or callback we are doing
  // a cursor based aggregation
  if (options == null && callback == null) {
    options = {};
  }

  return aggregate(this, '1', pipeline, options, callback);
};

/**
 * Return the Admin db instance
 * @method
 * @return {Admin} return the new Admin db instance
 */
Db.prototype.admin = function() {
  const Admin = require('./admin');

  return new Admin(this, this.s.topology, this.s.promiseLibrary);
};

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Db~collectionResultCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Collection} collection The collection instance.
 */

/**
 * The callback format for an aggregation call
 * @callback Database~aggregationCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {AggregationCursor} cursor The cursor if the aggregation command was executed successfully.
 */

const collectionKeys = [
  'pkFactory',
  'readPreference',
  'serializeFunctions',
  'strict',
  'readConcern',
  'ignoreUndefined',
  'promoteValues',
  'promoteBuffers',
  'promoteLongs'
];

/**
 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you
 * can use it without a callback in the following way: `const collection = db.collection('mycollection');`
 *
 * @method
 * @param {string} name the collection name we wish to access.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
 * @param {object} [options.readConcern] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
 * @param {ReadConcernLevel} [options.readConcern.level='local'] Specify a read concern level for the collection operations (only MongoDB 3.2 or higher supported)
 * @param {Db~collectionResultCallback} [callback] The collection result callback
 * @return {Collection} return the new Collection instance if not in strict mode
 */
Db.prototype.collection = function(name, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  options = Object.assign({}, options);

  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // If we have not set a collection level readConcern set the db level one
  options.readConcern = options.readConcern || this.s.readConcern;

  // Do we have ignoreUndefined set
  if (this.s.options.ignoreUndefined) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }

  // Merge in all needed options and ensure correct writeConcern merging from db level
  options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);

  // Execute
  if (options == null || !options.strict) {
    try {
      const collection = new Collection(
        this,
        this.s.topology,
        this.s.databaseName,
        name,
        this.s.pkFactory,
        options
      );
      if (callback) callback(null, collection);
      return collection;
    } catch (err) {
      if (err instanceof MongoError && callback) return callback(err);
      throw err;
    }
  }

  // Strict mode
  if (typeof callback !== 'function') {
    throw toError(`A callback is required in strict mode. While getting collection ${name}`);
  }

  // Did the user destroy the topology
  if (this.serverConfig && this.serverConfig.isDestroyed()) {
    return callback(new MongoError('topology was destroyed'));
  }

  const listCollectionOptions = Object.assign({}, options, { nameOnly: true });

  // Strict mode
  this.listCollections({ name: name }, listCollectionOptions).toArray((err, collections) => {
    if (err != null) return handleCallback(callback, err, null);
    if (collections.length === 0)
      return handleCallback(
        callback,
        toError(`Collection ${name} does not exist. Currently in strict mode.`),
        null
      );

    try {
      return handleCallback(
        callback,
        null,
        new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options)
      );
    } catch (err) {
      return handleCallback(callback, err, null);
    }
  });
};

/**
 * Create a new collection on a server with the specified options. Use this to create capped collections.
 * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
 *
 * @method
 * @param {string} name the collection name we wish to access.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
 * @param {boolean} [options.capped=false] Create a capped collection.
 * @param {boolean} [options.autoIndexId=true] DEPRECATED: Create an index on the _id field of the document, True by default on MongoDB 2.6 - 3.0
 * @param {number} [options.size] The size of the capped collection in bytes.
 * @param {number} [options.max] The maximum number of documents in the capped collection.
 * @param {number} [options.flags] Optional. Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag.
 * @param {object} [options.storageEngine] Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection on MongoDB 3.0 or higher.
 * @param {object} [options.validator] Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation on MongoDB 3.2 or higher.
 * @param {string} [options.validationLevel] Determines how strictly MongoDB applies the validation rules to existing documents during an update on MongoDB 3.2 or higher.
 * @param {string} [options.validationAction] Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted on MongoDB 3.2 or higher.
 * @param {object} [options.indexOptionDefaults] Allows users to specify a default configuration for indexes when creating a collection on MongoDB 3.2 or higher.
 * @param {string} [options.viewOn] The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view; i.e. does not include the database name and implies the same database as the view to create on MongoDB 3.4 or higher.
 * @param {array} [options.pipeline] An array that consists of the aggregation pipeline stage. create creates the view by applying the specified pipeline to the viewOn collection or view on MongoDB 3.4 or higher.
 * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~collectionResultCallback} [callback] The results callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.createCollection = deprecateOptions(
  {
    name: 'Db.createCollection',
    deprecatedOptions: ['autoIndexId'],
    optionsIndex: 1
  },
  function(name, options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = options || {};
    options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;

    return executeOperation(this.s.topology, createCollection, [this, name, options, callback]);
  }
);

/**
 * Get all the db statistics.
 *
 * @method
 * @param {object} [options] Optional settings.
 * @param {number} [options.scale] Divide the returned sizes by scale value.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The collection result callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.stats = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  // Build command object
  const commandObject = { dbStats: true };
  // Check if we have the scale value
  if (options['scale'] != null) commandObject['scale'] = options['scale'];

  // If we have a readPreference set
  if (options.readPreference == null && this.s.readPreference) {
    options.readPreference = this.s.readPreference;
  }

  // Execute the command
  return this.command(commandObject, options, callback);
};

/**
 * Get the list of all collection information for the specified db.
 *
 * @method
 * @param {object} [filter={}] Query to filter collections by
 * @param {object} [options] Optional settings.
 * @param {boolean} [options.nameOnly=false] Since 4.0: If true, will only return the collection name in the response, and will omit additional info
 * @param {number} [options.batchSize] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @return {CommandCursor}
 */
Db.prototype.listCollections = function(filter, options) {
  filter = filter || {};
  options = options || {};

  // Shallow clone the object
  options = Object.assign({}, options);
  // Set the promise library
  options.promiseLibrary = this.s.promiseLibrary;

  // Ensure valid readPreference
  options.readPreference = resolveReadPreference(options, {
    db: this,
    default: ReadPreference.primary
  });

  // Cursor options
  let cursor = options.batchSize ? { batchSize: options.batchSize } : {};

  // We have a list collections command
  if (this.serverConfig.capabilities().hasListCollectionsCommand) {
    const nameOnly = typeof options.nameOnly === 'boolean' ? options.nameOnly : false;
    // Build the command
    const command = { listCollections: true, filter, cursor, nameOnly };
    // Set the AggregationCursor constructor
    options.cursorFactory = CommandCursor;
    // Create the cursor
    cursor = this.s.topology.cursor(`${this.s.databaseName}.$cmd`, command, options);
    // Do we have a readPreference, apply it
    if (options.readPreference) {
      cursor.setReadPreference(options.readPreference);
    }
    // Return the cursor
    return cursor;
  }

  // We cannot use the listCollectionsCommand
  if (!this.serverConfig.capabilities().hasListCollectionsCommand) {
    // If we have legacy mode and have not provided a full db name filter it
    if (
      typeof filter.name === 'string' &&
      !new RegExp('^' + this.databaseName + '\\.').test(filter.name)
    ) {
      filter = Object.assign({}, filter);
      filter.name = `${this.s.databaseName}.${filter.name}`;
    }
  }

  // No filter, filter by current database
  if (filter == null) {
    filter.name = `/${this.s.databaseName}/`;
  }

  // Rewrite the filter to use $and to filter out indexes
  if (filter.name) {
    filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
  } else {
    filter = { name: /^((?!\$).)*$/ };
  }

  // Return options
  const _options = { transforms: listCollectionsTransforms(this.s.databaseName) };
  // Get the cursor
  cursor = this.collection(CONSTANTS.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
  // Do we have a readPreference, apply it
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // We have a fallback mode using legacy systems collections
  return cursor;
};

/**
 * Evaluate JavaScript on the server
 *
 * @method
 * @param {Code} code JavaScript to execute on server.
 * @param {(object|array)} parameters The parameters for the call.
 * @param {object} [options] Optional settings.
 * @param {boolean} [options.nolock=false] Tell MongoDB not to block on the evaluation of the javascript.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The results callback
 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.eval = deprecate(function(code, parameters, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  parameters = args.length ? args.shift() : parameters;
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, evaluate, [this, code, parameters, options, callback]);
}, 'Db.eval is deprecated as of MongoDB version 3.2');

/**
 * Rename a collection.
 *
 * @method
 * @param {string} fromCollection Name of current collection to rename.
 * @param {string} toCollection New name of of the collection.
 * @param {object} [options] Optional settings.
 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~collectionResultCallback} [callback] The results callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  // Add return new collection
  options.new_collection = true;

  const collection = this.collection(fromCollection);
  return executeOperation(this.s.topology, collection.rename.bind(collection), [
    toCollection,
    options,
    callback
  ]);
};

/**
 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param {string} name Name of collection to drop
 * @param {Object} [options] Optional settings
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The results callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.dropCollection = function(name, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  // Command to execute
  const cmd = { drop: name };

  // Decorate with write concern
  applyWriteConcern(cmd, { db: this }, options);

  // options
  const opts = Object.assign({}, this.s.options, { readPreference: ReadPreference.PRIMARY });
  if (options.session) opts.session = options.session;

  return executeOperation(this.s.topology, dropCollection, [this, cmd, opts, callback]);
};

/**
 * Drop a database, removing it permanently from the server.
 *
 * @method
 * @param {Object} [options] Optional settings
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The results callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.dropDatabase = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  // Drop database command
  const cmd = { dropDatabase: 1 };

  // Decorate with write concern
  applyWriteConcern(cmd, { db: this }, options);

  // Ensure primary only
  const finalOptions = Object.assign({}, this.s.options, {
    readPreference: ReadPreference.PRIMARY
  });

  if (options.session) {
    finalOptions.session = options.session;
  }

  return executeOperation(this.s.topology, dropDatabase, [this, cmd, finalOptions, callback]);
};

/**
 * Fetch all collections for the current db.
 *
 * @method
 * @param {Object} [options] Optional settings
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~collectionsResultCallback} [callback] The results callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.collections = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  return executeOperation(this.s.topology, collections, [this, options, callback]);
};

/**
 * Runs a command on the database as admin.
 * @method
 * @param {object} command The command hash
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Db~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  options.readPreference = resolveReadPreference(options);

  return executeOperation(this.s.topology, executeDbAdminCommand, [
    this,
    selector,
    options,
    callback
  ]);
};

/**
 * Creates an index on the db and collection.
 * @method
 * @param {string} name Name of the collection to create the index on.
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [optionsnj=balsu] Specidy a jOurna| write concern. * @param {b/olean} [mptinnsunique=false] Crmates an unique i~dex.
 * @pa2am"{boolean} [options.spar3e=false] Creates a`sparse index*Š * @param {boolean} [options.background=false] Creates tie indeX in the background, yaehäijg whenEver possible.
 
)@param {booLean} {optIons.dropDups=false] I uniuue index cannot be creatEd ol a$key that has pre-e8hwting duplicate values. If you wnuld like to create the index anyway, keeping the &irst docume.t the database indexgs and deleting all subsequent documants tha4 have duplicitu valtg
`ª Aparam {numbeò([op|ions.min]"For geospatial`index%s set tha lower bound for the$co%grdinateq. ª @param {number} [options.mAz]$or gespatia, indåxes ret the high bound0for the co-ordinates.
 *0@param {nUorer} [o0tionó.v] “pecify thå format Version of tje iîdexes.
 j @param {numbEr} [options.expipõAbTerSecondc] Al|ows you to a|pire data on )ndexes`að0lied 4o a deta`(LOngoEB 2.2 ~r higher)
$* @param {nemâer} [o`tikns.name] Override |he0autngenerated index nam% (us%ful(If the zesulting name$is!larger Th!n 128 fytes)
 * @parqm {object} [Optio.s.0a2tialFilterEppressign] Cvaates a pardial hodex bqsed on th% given filter oBjecp (MgngoDB 3.2 or higher)
@*!@param {ClientSession} [options.seSsion] optional sesSion to use0for 4his operation
!j @paRam ;Db~resultCallback} [caLlbackÝ Thu colmand rmsudt callbCck
 * @return {PromisE} returns Pro}ise!kf no kallback passed
 *.
@b.pbotmtype.create	fdex = fqnction(.ame, fieldOrSpec, opTions, caldback) {
 0if (typeof opti/ns -==('gunction') (sahlfacK = Options), (opti/ns = {});
  opt)ns = gptions ¿ Object.assign({¬ optins) : {};
*  return executeOperation(thiS.s.topoìogy, creáteIndex, [
(   thir,
    name,(   fieldOrSpec,    o`dions,
    callback
!`_);
}+

/**
 * Ensures that an index exists, ir iv!does not it creates it
 * @method * @dEprecated siocm version 2.0
 * @piram {strinc} fame Thå index name
 * @param {(string|object)} fiel`OrSpec Definus the(index.
 * @param {objmct} [optionq} Optional settings.
 * @param {(numbertsprin')} [options.w] Dhe write co.cern.Š *!@paral jumber}([opTéons.wtimeoutÝ Ôhe write concern timmout.
 ( @par!m {boolõan} [options.j=famse] S4ecify a journal wbite concern.
 ª @param0{boolean} [options.unique½false] Creatås an unique index.
 * @param {booleanü [options.sðarse=fals%] Cveates a sparse index.
 * @param {fonlean} YoptIons.background}false] Breates the index in the backgpkund, yieldi.g whenever possiblg.
 
 Aparam`{bomlean} [options.ero0Dups=false]$A pnique iodex!cannot b% created on a key that has pre-existing duplicatE valueq/ If you woudd like to create vhe index `ny7ay, keeping the fizsv document the d!tabase iîdexes aNd dele4ang all sub3Equent"`ocuíejts that have duplicate`vanue
 * @param {nuíber} [ntvions&mhn] For geoSpatial kndexes!set thelove2 bound gor the co-ovdinate{.
0* Pparam {fumber} [optikns.max] For geospa4ial indexes sav Ôhe high bound fov txe$co-ordinates.
 * @paRa- ûnumbeb} [options.v] Specivù the format version of thu indexes.
 * @par!m {nuoberm [/ptionw.expireQfterSesonds] Illows you to ezðire data!on i~dexes$applied to a dcta (MongoTF¨2.0 ov higjer)
!( @param ûnumber} [options.name]"Override the euto'eneráted index namg (usedul if the resulti®g name is larger thej 128 byTew) * @param {clientSåssi/n} [option3.Sessiol] optional session |O use f/b this opevation
 * @param {Db~òesulvallbacK} [ca¬lbáck] The command rmsult aallback
 * @retuòn zPrnmise= returNs P2omise if no callbabk paqsed
*/
Db.prototyxe.ånsureIndex ? deprecate(&qnctioj(name, vieldOrSp%c, options, callback) {
  if (typemf options === 'fungtinn') (callback } optins), (jptionq = {});
  opTions = options || [};

  return e|ecuteOpebation(this.s.topolog, en3ubeIndex, [
    this,    name,
    fieldOrSpec,    o0tions,
    calnbaci
  ]);
}, 'Db.ensureIndex is0dmprecited as Of MongoDB version s.0 / drifep version 20%)»

Db.prototype.addCxild = fulction(`b) ;
  ig *this.s.parentDò) repurn this.snparentDb.addKhild(db!;
 `thiss.cHildren.push¨$b);
};

/."
 * Add a user to the database.
 * @met`/d
 * @taram {string} usurname The username. * @paRam {wtriîg} password The xasqword.
 * Aravam {object} [optIonS] Optional sevtings.
 * @param ;(number|óôRing)}0[options.s] The 7rite concern.
 j Hparam {n5mber} [options.vtimeout] The`wr!te concerî timeout. * @param {boolEaf}!_kptaons.j=falsE] Speci&y a jou{nal write concern.
 * @param {ïbjEct} [option{.custo}Data] CustOm dáta asrociated with the uqer honly mongmdb 2.6 gr hivHer)
 + @param {Ocjegt[]}![options.roles] ROles a{socaaded!with the crgatad useR (only8Mo^gofb`2.6 or highgr)
 * @param {ClientSgssion} [opvions.suwsion opti/nal sessimn to uce for this mpgradi/n
 * @param({D`^resulvBanlback} [call`aak] The comm!nd result calì`ack ª Hretur~ {Promisç|"re4ubns P2omise if no samlbakk passmd
 */Db.prototype.adDUser - dujction(userncme, password, opvions$ callback) {
 (if (dypeob ortions ===0'function') (cellbagj = ¯ptions), (options = {});
  options = options ||${}3

  return(eøekuteKperation(this.s~toPo,ogy, addUóer,0[this, tsername, password, options, callb!ck]){
};

/**
 * Remove a User from a(dátabAse
 * @method
 * @param {3tring| usgrnáie`Ôhe usgrla-e>J * @0arám {objectu {ottimns] Optional settings.
 k @pa2am {(number|stziîg)}$[oxtions.w]`The writ% concerj/
 * @parai {num!er}([opTions.w|imeout] The write concern timeout.
 *  par`m snoolean} [options.j=false] Specify!a hournan(w{ite concen.
 * @param {BnientSession} [optiols.sessioo]8option`, sesr)on ôo use0fos thys operation
 * Dparam {Db~resultCallbaco} [calnbaCk] The`coemand zeSõlt c!,mback
 * @repurn {Promise} Returns PromisE if no`callback passeD
 */
Db.protot9pe.removeUSe2 = function8õsername, options, ca,lback) {
( if (typeof kptkons 9== 'fuîction') (callbagë = mptiOfs), (options = {});
  options = options || {};

  retqrn executeOperauiOn(this.s.topklooy( removeser, [this, usernamE, ptions, callback]);
};
/**
 * Set the current profilhng |avel of MongoB
 *
 *(@param {string} level Tle n%w pro&iling le~el (off- slow_onlx( aml).
 * @ðaram {Obnect} [optiolsÝ Optional sevtings
 * @paral {Clme.tSession} [/pviofs.sessim~U optyoNal russion 4o use for0this op%ration
 * @param${Db~resulfCallback} [callback] The"comminl result callback.
 * @return {Prmise} retur~s Promiså if no calnbask parsed
 */Db,protntype.sevProfilingMevel = function(level, oxtions, callbaCc)"{
  if (typmog options === 'function') (callback = options), (opdion{(? {});
  options!= options || {};

  revurf executeOperation(this.s.topology, setProfiléngLevel![this, level, optio~s$ callback_);
};

/**
 ( Re4Rieve the cõrrenT0troniling indormation for IongoLB
 *
 * @pqram {Object}0{optiojs](Optinal settijgs
 *0`paRam {ClientSession} [Oppions.sessiïn] optiolal se3shoo 4o use for$t(is$gperation
 * Àparqm {Db~2e{ultCcllbick} [callback] The commin`0rusult cállback.
 * @return {PvoMiseu rEtuzns Promise if no Camlback passed
 . @`epregated Query the system.pbofile collåction directl9.
 */
Äb.provoty0e.prkfilingInfo = deprecete(fnbtikn(oqTions, kallbqsk) {
  if"(typeof options === 'functioj') (aallrack = optiïns), (op4iknó = {});
  options = kptions || {};

  return executeOPeratiïn(this.s.topology, prof)lingIngo( [thi3, options, gqllback]);
}, '@b.profilingInfo$ic deprgcated. Qeery the$system.profjne collektion directly,');

/**
 ª Retrieve 4he cursent profiling Lev%l for MoNwoDB *
 * @param!{Object} [opt)oos] Optional s}t|ings
 * @param {ClientSesSiïn} [options.session] optignal session to use for this operation
 * @`aram {DbnresultCallback} _callbakk] Tle command`result aallâack
 * @return Prgiise} retusn{ Prmn9sg if no(callback$passed
 */
Db.proôot9pm.@rofélingLmvel = function(oationq- calnback) û
  if (txteof otpions(5== 'fuîction') (calLback = o`tions), (options = {});
  ottions } options <| {};
  return exe#uteOxeration(this.s.topolkgy, prOgiliNgLevel, Sthis, options, callback]);
};

/**
 * Retrietes thiw collecvions ildEx info.
 * @method
 * @param {3tri.G} name he name of thu collectign.
 * @pa2Am {kbkect Zoptions] ðdional sET4ings.
 * @param {boolean} options.full=false] Returns the full raw index$inæormation. * @param {(ReadÐrEference|string)} [oPtimns.readPreference] Vhe preferre` read prefere~ce (ReidPreferenae/PRYIARY, ReadPreference.PRIMQRY_PREFERRED$ ReadPR%gerence.SCGNDARY, ReadPreferenbe.SECONDARY_REFERRED, ZeadPreference.NECREST).
 * @param"{ClieNtSessiïn} [opt)ons.session]*/ptional session to use for this"operavinn * @param {Db~resultCallbaãk} [callbacK] Thu command$resuLt callback
 * @return {Promisd} betõrns Promise if no callback paqsedJ */
Db.prototype.indexInfmrmation = function(ame, mpti/ns, calljack) {Š  if!(tyreof opTions === /function#) (callback = options), (options = {});
  oppinns(- ptiOnc || {};

  retern execu4eOper`vion(thic.r.topology, in`exIjfobmation [4his, name, optigns, cahlback]);
;

/**
 * Õnref all sockets
 * @method
 */
Db/p2ototipe.unre& = function() {
  this.s.torology.unref(9;J};

/**
 . Cr%ate a ne÷ Ahange Qtòeim,€watching for neu chånges (ilsertio~sl wpDates, replasemånts, deletions, and invalidations) in txiS database, Will icnore all changes`to system collections.
 * @mephod
 * @since$3.1.0
 * @pira- {rray| [pIpeline] An array of8{ lank htdps://docs.mongodb.com/manual?refebence/operatos/agGregation-pipeline/üaegregation 0ipmline spages} through which to pass ch!nge"stream"documents. Thiq allows for fi|tering (5sang$%match) and manipulating the change stream!documents
 * @param {obnect= [ortions_ Opti/nal settangs
 * @param {stbino} [oppionq.fullDngument='default'] Allowmd valUes: â€˜defauLTâˆ™, â€˜utdateLoojupâ€™. When set to â€˜uPdateLkokupâ€™, thd ch`nge stve`m will includg both0a delt! descRibing the changeq@to24he document¬ as wenl as a copy oæ the entmre document that as c(ajgEd from some$Pime aftdr theachánge ocCurred.
 * Dparam {objEct} [orvions.resumeAfter] Stekifies the logicAl starting0point for the new ciange streamn This shmuld bE the _id field From i prevaously returnmd chanem stream¢document.
 * @piram {numbur} [options.maxAwaitTimeM]¤The mayiíum amount of timå for the server tn0wait oj oeu dOcuments to sapisfy a change stream$aueryJ * Hparam {nuMber} [optionsnbctchSize]$The number"of $ocuments to return per bavch. Sue {@liok httðs://docsmongodb.com/manual/rmfepence/comeand/aggregate|aggregation documentation}.
 * @param {obªect}`[oPTionq®collation] Specifq cmllation wet4iîgs for operation. Sge {@liNk httpq://docs.mongoeb.com/ianual/reference/coiland/eggregate|aggreçadion documÅntaôion}.
 * @param {ReadPrefeRence} [orôaonsreadPreference] T`m read preference. åfaults to tie tead preferenge of tHe fatabase. See {@link https://docs.mongodb>com/manuil/vederence/re`d-preference|read preference documentadion}.
 * @xaram {Timestamp= options.startAtClusterT)me] recekte change!eve~ts that ocBur aftår thd specified timårtamr * @param {ClientSEssion}4[opôions.{us3ion] optioncl session 4o tsd foR this gperation * @rettrn {ChangeStream} a ChingeStream instance.
 */
Db.prototype.watch = functyon(pipeline$ options) {! pmpeLiîe = papeliêe || [];
  options!= optmons |} {z;*
  // Allow npTionally nod qpesidyyng a`pipgléne
  if (!Array*isArray(pipmdine)) {
    ptions = pipeline;
    pipeline = [];
  }

` vetwrn new ChangeStzeam(this, pipeline, options);};
/**
(* Return the db logger
 * @method
 
 @returN {Lïgçer}`return the d"!loeger
 * @ignore
 */
Db.protoTxpen/etLogggr = functioî(- ;*  òeturn Uhiw.s.logger9
3

/**
 * DB close event
 *
 " Emitted aftev a qocket"#,o3ed `gaincô a single server or mongos pr/xy.
 *
 *"@åvent Eb"close
  @typu`{MongmError}
 */

/**
 * Dc reconnect event
 *
 *  * ServdR: Emitted when the driveb has reconnected and re-authentica4ed.
 * (* Òep|icaSet: N-A
 *  * mongos: Emivtud"vhån the driver reconNects anä rå-!utxendicates Succdssfu,ly0agqinst a Moîgos,
 *
 * @evant Db#recolnect
 * Dt{te"object}
 *-

/**
 * Eb!mrror event
 *
 * Emitted`aftev qn erroR occurred agamnsp á!single server or`ío~gos xroxy.
 *
 *!@etent Db#error
 *$Dtype {MongoGrroz}
`*/

/**
 * Db tiienut`eveît
 *
`* Emittet after a socke| timeout oqcurve$ igaiost a single0serve2 ïr mongs proxy.
 *
 * @event Db#timeo5t
 * `type0{MojgoErrgr}
 */

/**
 * Db parseError`eVent
 *
 * The"pirsgError(eveît ks emivted if The driver detects idlegal os corrupt BSON beino rec%ived0gr/m tie server.
 * * Peve.t!Db#parseEr2or
 * @typE Mongorror}
 */
/**
 * FB fullsedup event,(e-itted wheî all servers in tèe topology hawe`bden bonnEctef to ad start up tiim.
 *
 * * Server: Emit4ed`whe. the driver has connected to`thd!single server and has authtntic`ted/ª * * RetlSet: Eomtted afTer dhe driv%r(hás áttempted to co.nect to all replisasEt members.
 * * Mongos: Gmitted after the driver has attem`ted to(connect to all mngos prïziew.
 :
 , @evgnt Db#bullsatup
 *`Btype {Db}
 */

/é Constants
Db.SYSTEM_NAMEÓPACe_COLLECTION = CONStANTS.SYSTEM_NAMESTACE_COLLECTKON;
Db.SYSTEM]INDEX_COLLECTION = CONSTANTS.SYQTEM_INDXWCOLLECÔION;Db.SYSTEM_PRKFILe_COLLECTIN ="CKNSTANTSsYSTEM_PROFILE_CLDECTION;
Db.SYSTEM_USER_COLLeCtION = CO^STANTS.SYSTEM^U[eR_COLMECDION;
Db.SSTEM_COMÍAND_COLLEÃTION = COJQTANTS.SYSTEM_COMMAND_COLLECTION;
Db.SISTEm_JS_CO\LEBTION = CONSTANTS.sYSTEMßJS_COLLACTION;

module.exports = Db;
