'use strict';

const deprecate = require('util').deprecate;
const deprecateOptions = require('./utils').deprecateOptions;
const checkCollectionName = require('./utils').checkCollectionName;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const MongoError = require('mongodb-core').MongoError;
const toError = require('./utils').toError;
const normalizeHintField = require('./utils').normalizeHintField;
const handleCallback = require('./utils').handleCallback;
const decorateCommand = require('./utils').decorateCommand;
const decorateWithCollation = require('./utils').decorateWithCollation;
const decorateWithReadConcern = require('./utils').decorateWithReadConcern;
const formattedOrderClause = require('./utils').formattedOrderClause;
const ReadPreference = require('mongodb-core').ReadPreference;
const CommandCursor = require('./command_cursor');
const unordered = require('./bulk/unordered');
const ordered = require('./bulk/ordered');
const ChangeStream = require('./change_stream');
const executeOperation = require('./utils').executeOperation;
const resolveReadPreference = require('./utils').resolveReadPreference;

// Operations
const aggregate = require('./operations/aggregate').aggregate;
const bulkWrite = require('./operations/collection_ops').bulkWrite;
const checkForAtomicOperators = require('./operations/collection_ops').checkForAtomicOperators;
const count = require('./operations/collection_ops').count;
const countDocuments = require('./operations/collection_ops').countDocuments;
const createIndex = require('./operations/collection_ops').createIndex;
const createIndexes = require('./operations/collection_ops').createIndexes;
const deleteMany = require('./operations/collection_ops').deleteMany;
const deleteOne = require('./operations/collection_ops').deleteOne;
const distinct = require('./operations/collection_ops').distinct;
const dropIndex = require('./operations/collection_ops').dropIndex;
const dropIndexes = require('./operations/collection_ops').dropIndexes;
const ensureIndex = require('./operations/collection_ops').ensureIndex;
const findAndModify = require('./operations/collection_ops').findAndModify;
const findAndRemove = require('./operations/collection_ops').findAndRemove;
const findOne = require('./operations/collection_ops').findOne;
const findOneAndDelete = require('./operations/collection_ops').findOneAndDelete;
const findOneAndReplace = require('./operations/collection_ops').findOneAndReplace;
const findOneAndUpdate = require('./operations/collection_ops').findOneAndUpdate;
const geoHaystackSearch = require('./operations/collection_ops').geoHaystackSearch;
const group = require('./operations/collection_ops').group;
const indexes = require('./operations/collection_ops').indexes;
const indexExists = require('./operations/collection_ops').indexExists;
const indexInformation = require('./operations/collection_ops').indexInformation;
const insertMany = require('./operations/collection_ops').insertMany;
const insertOne = require('./operations/collection_ops').insertOne;
const isCapped = require('./operations/collection_ops').isCapped;
const mapReduce = require('./operations/collection_ops').mapReduce;
const optionsOp = require('./operations/collection_ops').optionsOp;
const parallelCollectionScan = require('./operations/collection_ops').parallelCollectionScan;
const reIndex = require('./operations/collection_ops').reIndex;
const removeDocuments = require('./operations/collection_ops').removeDocuments;
const rename = require('./operations/collection_ops').rename;
const replaceOne = require('./operations/collection_ops').replaceOne;
const save = require('./operations/collection_ops').save;
const stats = require('./operations/collection_ops').stats;
const updateDocuments = require('./operations/collection_ops').updateDocuments;
const updateMany = require('./operations/collection_ops').updateMany;
const updateOne = require('./operations/collection_ops').updateOne;

/**
 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Create a collection we want to drop later
 *   const col = client.db(dbName).collection('createIndexExample1');
 *   // Show that duplicate records got dropped
 *   col.find({}).toArray(function(err, items) {
 *     test.equal(null, err);
 *     test.equal(4, items.length);
 *     client.close();
 *   });
 * });
 */

const mergeKeys = ['ignoreUndefined'];

/**
 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property {string} collectionName Get the collection name.
 * @property {string} namespace Get the full collection namespace.
 * @property {object} writeConcern The current write concern values.
 * @property {object} readConcern The current read concern values.
 * @property {object} hint Get current index hint for collection.
 * @return {Collection} a Collection instance.
 */
function Collection(db, topology, dbName, name, pkFactory, options) {
  checkCollectionName(name);

  // Unpack variables
  const internalHint = null;
  const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  const serializeFunctions =
    options == null || options.serializeFunctions == null
      ? db.s.options.serializeFunctions
      : options.serializeFunctions;
  const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
  const promoteLongs =
    options == null || options.promoteLongs == null
      ? db.s.options.promoteLongs
      : options.promoteLongs;
  const promoteValues =
    options == null || options.promoteValues == null
      ? db.s.options.promoteValues
      : options.promoteValues;
  const promoteBuffers =
    options == null || options.promoteBuffers == null
      ? db.s.options.promoteBuffers
      : options.promoteBuffers;
  let readPreference = null;
  const collectionHint = null;
  const namespace = `${dbName}.${name}`;

  // Get the promiseLibrary
  const promiseLibrary = options.promiseLibrary || Promise;

  // Assign the right collection level readPreference
  if (options && options.readPreference) {
    readPreference = options.readPreference;
  } else if (db.options.readPreference) {
    readPreference = db.options.readPreference;
  }

  // Set custom primary key factory if provided
  pkFactory = pkFactory == null ? ObjectID : pkFactory;

  // Internal state
  this.s = {
    // Set custom primary key factory if provided
    pkFactory: pkFactory,
    // Db
    db: db,
    // Topology
    topology: topology,
    // dbName
    dbName: dbName,
    // Options
    options: options,
    // Namespace
    namespace: namespace,
    // Read preference
    readPreference: readPreference,
    // SlaveOK
    slaveOk: slaveOk,
    // Serialize functions
    serializeFunctions: serializeFunctions,
    // Raw
    raw: raw,
    // promoteLongs
    promoteLongs: promoteLongs,
    // promoteValues
    promoteValues: promoteValues,
    // promoteBuffers
    promoteBuffers: promoteBuffers,
    // internalHint
    internalHint: internalHint,
    // collectionHint
    collectionHint: collectionHint,
    // Name
    name: name,
    // Promise library
    promiseLibrary: promiseLibrary,
    // Read Concern
    readConcern: options.readConcern,
    // Write Concern
    writeConcern: options.writeConcern
  };
}

Object.defineProperty(Collection.prototype, 'dbName', {
  enumerable: true,
  get: function() {
    return this.s.dbName;
  }
});

Object.defineProperty(Collection.prototype, 'collectionName', {
  enumerable: true,
  get: function() {
    return this.s.name;
  }
});

Object.defineProperty(Collection.prototype, 'namespace', {
  enumerable: true,
  get: function() {
    return this.s.namespace;
  }
});

Object.defineProperty(Collection.prototype, 'readConcern', {
  enumerable: true,
  get: function() {
    return this.s.readConcern || { level: 'local' };
  }
});

Object.defineProperty(Collection.prototype, 'writeConcern', {
  enumerable: true,
  get: function() {
    let ops = {};
    if (this.s.writeConcern) {
      return this.s.writeConcern;
    }

    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  }
});

/**
 * @ignore
 */
Object.defineProperty(Collection.prototype, 'hint', {
  enumerable: true,
  get: function() {
    return this.s.collectionHint;
  },
  set: function(v) {
    this.s.collectionHint = normalizeHintField(v);
  }
});

const DEPRECATED_FIND_OPTIONS = ['maxScan', 'fields', 'snapshot'];

/**
 * Creates a cursor for a query that can be used to iterate over results from MongoDB
 * @method
 * @param {object} [query={}] The cursor query object.
 * @param {object} [options] Optional settings.
 * @param {number} [options.limit=0] Sets the limit of documents returned in the query.
 * @param {(array|object)} [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param {object} [options.projection] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}
 * @param {object} [options.fields] **Deprecated** Use `options.projection` instead
 * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param {Object} [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}
 * @param {boolean} [options.explain=false] Explain the query instead of returning the data.
 * @param {boolean} [options.snapshot=false] DEPRECATED: Snapshot query.
 * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.
 * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.
 * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {boolean} [options.returnKey=false] Only return the index key.
 * @param {number} [options.maxScan] DEPRECATED: Limit the number of items to scan.
 * @param {number} [options.min] Set index bounds.
 * @param {number} [options.max] Set index bounds.
 * @param {boolean} [options.showDiskLoc=false] Show disk location of results.
 * @param {string} [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.
 * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @throws {MongoError}
 * @return {Cursor}
 */
Collection.prototype.find = deprecateOptions(
  {
    name: 'collection.find',
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  },
  function(query, options, callback) {
    if (typeof callback === 'object') {
      // TODO(MAJOR): throw in the future
      console.warn('Third parameter to `find()` must be a callback or undefined');
    }

    let selector = query;
    // figuring out arguments
    if (typeof callback !== 'function') {
      if (typeof options === 'function') {
        callback = options;
        options = undefined;
      } else if (options == null) {
        callback = typeof selector === 'function' ? selector : undefined;
        selector = typeof selector === 'object' ? selector : undefined;
      }
    }

    // Ensure selector is not null
    selector = selector == null ? {} : selector;
    // Validate correctness off the selector
    const object = selector;
    if (Buffer.isBuffer(object)) {
      const object_size = object[0] | (object[1] << 8) | (object[2] << 16) | (object[3] << 24);
      if (object_size !== object.length) {
        const error = new Error(
          'query selector raw message size does not match message header size [' +
            object.length +
            '] != [' +
            object_size +
            ']'
        );
        error.name = 'MongoError';
        throw error;
      }
    }

    // Check special case where we are using an objectId
    if (selector != null && selector._bsontype === 'ObjectID') {
      selector = { _id: selector };
    }

    if (!options) options = {};

    let projection = options.projection || options.fields;

    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
      projection = projection.length
        ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {})
        : { _id: 1 };
    }

    // Make a shallow copy of options
    let newOptions = Object.assign({}, options);

    // Make a shallow copy of the collection options
    for (let key in this.s.options) {
      if (mergeKeys.indexOf(key) !== -1) {
        newOptions[key] = this.s.options[key];
      }
    }

    // Unpack options
    newOptions.skip = options.skip ? options.skip : 0;
    newOptions.limit = options.limit ? options.limit : 0;
    newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;
    newOptions.hint =
      options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
    newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout;
    // // If we have overridden slaveOk otherwise use the default db setting
    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;

    // Add read preference if needed
    newOptions.readPreference = resolveReadPreference(newOptions, {
      db: this.s.db,
      collection: this
    });

    // Set slave ok to true if read preference different from primary
    if (
      newOptions.readPreference != null &&
      (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')
    ) {
      newOptions.slaveOk = true;
    }

    // Ensure the query is an object
    if (selector != null && typeof selector !== 'object') {
      throw MongoError.create({ message: 'query selector must be an object', driver: true });
    }

    // Build the find command
    const findCommand = {
      find: this.s.namespace,
      limit: newOptions.limit,
      skip: newOptions.skip,
      query: selector
    };

    // Ensure we use the right await data option
    if (typeof newOptions.awaitdata === 'boolean') {
      newOptions.awaitData = newOptions.awaitdata;
    }

    // Translate to new command option noCursorTimeout
    if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = newOptions.timeout;

    decorateCommand(findCommand, newOptions, ['session', 'collation']);

    if (projection) findCommand.fields = projection;

    // Add db object to the new options
    newOptions.db = this.s.db;

    // Add the promise library
    newOptions.promiseLibrary = this.s.promiseLibrary;

    // Set raw if available at collection level
    if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw;
    // Set promoteLongs if available at collection level
    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean')
      newOptions.promoteLongs = this.s.promoteLongs;
    if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean')
      newOptions.promoteValues = this.s.promoteValues;
    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean')
      newOptions.promoteBuffers = this.s.promoteBuffers;

    // Sort options
    if (findCommand.sort) {
      findCommand.sort = formattedOrderClause(findCommand.sort);
    }

    // Set the readConcern
    decorateWithReadConcern(findCommand, this, options);

    // Decorate find command with collation options
    try {
      decorateWithCollation(findCommand, this, options);
    } catch (err) {
      if (typeof callback === 'function') return callback(err, null);
      throw err;
    }

    const cursor = this.s.topology.cursor(this.s.namespace, findCommand, newOptions);

    return typeof callback === 'function' ? handleCallback(callback, null, cursor) : cursor;
  }
);

/**
 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object} doc Document to insert.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.insertOne = function(doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  // Add ignoreUndefined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }

  return executeOperation(this.s.topology, insertOne, [this, doc, options, callback]);
};

/**
 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object[]} docs Documents to insert.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {boolean} [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~insertWriteOpCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.insertMany = function(docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options ? Object.assign({}, options) : { ordered: true };

  return executeOperation(this.s.topology, insertMany, [this, docs, options, callback]);
};

/**
 * @typedef {Object} Collection~BulkWriteOpResult
 * @property {number} insertedCount Number of documents inserted.
 * @property {number} matchedCount Number of documents matched for update.
 * @property {number} modifiedCount Number of documents modified.
 * @property {number} deletedCount Number of documents deleted.
 * @property {number} upsertedCount Number of documents upserted.
 * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation
 * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
 * @property {object} result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~bulkWriteOpCallback
 * @param {BulkWriteError} error An error instance representing the error during the execution.
 * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.
 */

/**
 * Perform a bulkWrite operation without a fluent API
 *
 * Legal operation types are
 *
 *  { insertOne: { document: { a: 1 } } }
 *
 *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
 *
 *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
 *
 *  { deleteOne: { filter: {c:1} } }
 *
 *  { deleteMany: { filter: {c:1} } }
 *
 *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}
 *
 * If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object[]} operations Bulk operations to perform.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~bulkWriteOpCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.bulkWrite = function(operations, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || { ordered: true };

  if (!Array.isArray(operations)) {
    throw MongoError.create({ message: 'operations must be an array of documents', driver: true });
  }

  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback]);
};

/**
 * @typedef {Object} Collection~WriteOpResult
 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property {object} connection The connection object used for the operation.
 * @property {object} result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~writeOpCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.
 */

/**
 * @typedef {Object} Collection~insertWriteOpResult
 * @property {Number} insertedCount The total amount of documents inserted.
 * @property {object[]} ops All the documents inserted using insertOne/inserôMany/replaceO~e. Documents contqin the _id field ib forceServerOsjdctId == false for insertOne/inserdMany
 ª @psoperty {Obkect,<Number, ObjectId>} ijsartedIls Map of the inäax oF vhe inserwed `ocument`to the id kf vhe inserted document. * @propdrty sobjest} Aonnectkon!The coonection object used foR the Operition.
 * @property {object} resu|t The ra so-m1nd reyuìt object rmturned from MongoDB (content might viry ây server Version).
 * @pboterty {umberu resulT.ok"Is 1 if The commAnd exdcuted correctly/
 + @pvorerty {Numbmr} res}lt.n The tota| count of documents in3exted/
 *'

/**
 *0@ty0edef {Object}!Collgktiïn~insertOneW2iteOpResulv
 * @propecty ûNumber}(insertedC/unt The total!amou.t`of documents$inserted. *`@propgrty`{obj%ct[]} ors All thå $ocuments inserte$ qsing insertÏne/énsertManyorep,aceO.e. Docu-elts contain thu _id field if forceSarrerObjectMd == false for ijBertOne/inseptMany
 : @prope2ty zO"jåctId} insertedId The driver generAtef ObjectId fo2 th% énsgrt operatkon.
"* @property [obhect} condection The cknNection obêect used bor 4he operation.
 * @property {objeCt} resuld`Tie raw comeand(result object returngd froM MongoDB`(content might vcry by surver version).
 *(@property {NtlBer} råswlt.ïk Is 1 i¦ the comìand axec5ued co2rõctly.
 * @property {Number} resumô.n The total count!of documents0i.sebted.
 */
/*** * The callbabi fopmaô`.or inserts
 * D{al,back Collection~inse2tGriteOpCallback
 *  Param {MmogoError} arRor an ervor insuance representin' the mrror durilg phe executiof.
 * @raram {ColLection~insertWriteOpResult} resulv The result o"ject af the`commant was executed sqcceqsfully.
 */
/**
 ª The cal|back formát for insertsJ * @bcllback Collactimn>insertOneWriteOpCallback
 *  param {MongoErrnr} errOr An arrOr instance representing the error `ubijo the %xecwtion.* * @parim {Collection~insertOneWriteOpRes}lt} resu$t The resu,t o"kåct if the comm!nd war åxecuted succeksfully.
 */

/**
 j Inserts a siNgle docum}nt or a an !rray of(doau}enôs into MongoDB. If dokumgnts pacsed iî do n/t contain uhe **_id** field,
 * o~e will ba added to each of the documents misséog it by the driv%r, mutatig the dmcuient, Tèis behàWior " #`n fe ovevridden by setTilg thm **forceServerObjectId(* flaw.
 *
`* @methÏd
(* @param (object|object[])} äocs DocuMgnts to inserv." *0@pcram"{ïbjec0}([gppions] Mptinal setdings.
 * @parim {hnu}ber|rtring)} [mptions.w] The!Wòite$cojcern.
 * @param {numce2} [/ppions.wtkmeOut] The grite Conce2n tileout.
 * `param!{boolean} Ûoptinns.j=falsg] SpeaiBy a journal wrife concern.
 * @Para- {boolean} [optins.sepializeDunctions=Falsg] Smrialize funcdins on any objAct.
 * @pavam {booleanm0Ûoptions.fïrceServerObjectId=falseÝ$Forc% s%rveb to`assign _id values inwtead of drirer.
!* @taram {boolean} [optIons.bypassDocu}entFAlidapion=false] Anlow dryvEr to bypass schema validatéon in MongoDB 3.2oR ligher.
 *(@parao {ÃlientSeSsioom [options.Smssion]"optional session |o use fob tjis operation
 * @param0{Collecti?n~insertSr!4eOpCallbacc} [callbackU The command result"callbaci
 * @return {Ppomisg} rmtuRns Promise if nï callbicJ passed
$* @deprecaTEh UsE insertOne, insertMany or bulkWrite
 */
Collection.prototyp.insErt = deprecate(function(docs, optiona, callracc) {
  if((tyr%o& optionó$)== %funãtion§) (callback = eption3)L (options = {});
  optinns < opdioNs || { oòdered: false };
  docs = !Array.isArray(docS) ?({docs] : docs;
Š  if )optioos.keepGoing === true) {
  ` options.orderdd = false
  }
  retUrn Th)s.aNs%rtMany(doc3,0optygns, aall"ack)»
, 7colluãtmon.insert ys dgprecatedn Use ilsertOne, inser4Iany or bu~kWrhte"instead.');
/**
 * @t=peôef sKbject} Collectaon~updatEWriteOpÒesult
 * `prop%rTý`{Object} result ThE raw!result(returned vrom Mongo@B. Will$^ary2depefdinw on ser6Er vgrsion.
 " @properTy${Numbmr} pesult.ok Is 1 `f The co-mand executed corpectly. ª(@prïperty {Number] òesulT.n The total coqnt ow documedts scanned. * @property {Nwmber} result.nMo`ified`The"total #ount"of docqments$moDified.
 * @prope2ty {Object- #onnectaon Thepgïnnecthon object used for tha operation.
"*$@property {Nueber oatchedCount!Dèe numâer ïf eocuments that matchmd tHe filter.
 * @prperôy {Nuíber} modifiedCounT Thm number of documEn4s thav såre modibied/
 * @propertY {Number} u`su"4edCount The number of Documebts 5póerted>*!*!@property${OjJect} upsertedHd Thg upseò4ed id.
 *!@property {ObjactIdm u0sert%dK`._id The upsertdd _iä returned from the0server.
 * @property {Objeótu messace
 * @propevpy ~Array}(o0s
 *?

/**
0*!The #a,lback format for`inserts
 * @callback Cod|ecthon~updateWritmOpCallback * @param {kngoErrmr} urror(Ao årroz instan#e representyng the erroz durijg the gxebution.
 * @param {Collection~updatgWriteOpResult} result The resvlt gbjåat if the commánd was eøecuted successfully.
 
/

/**
 * Updata0a singlg document in a collection
!* Xmethoä
 * @parAm {o`jfct} gilter T@e Fylter us%d ôo se,eit the docuoent to up`qte
 * @pabam {object= update Dhe upda4e gperationó 4o be aptlÉed to the docõm%nt
 * @pabam!{objecT}![o0tions] ptional se4tings.
 *!Bðaram {booleaj] {optionc®upQert=f`mse] Updaue oðeratéon is an upcErd.
 * @param {(number~string)} [gptions/w]0The rito concern. * @param {numbur} [options.wtimeout] The rite colcern timeout.
(* @param {bool%a.y _gòtigns.j=falSe] Specify a journad$write concur~.
 * @paòam [bo/lean} [optionc.bypassDocumentValidatéon=false] Allow drIver to bypasr scjem! validation in"MongoDB 3.2 or higher.
!* param*{Array}`[options.arrayFidders] optignal list of`array filters refereNced in fhltered positio.al ïperadors
 * @param {ClientÓersion} [optionsnsession] optional sEssion to use for this /peration
"* @param {ohlection~uxdateWritaOpCallback} [callbac{] Phu command rErult callback
 . @returo {Promise}4re|}rns Promyse iæ no callback passud
 (/
Collection.`ro|otYxe.updeteOJe = fujction(filteb, update, optiojs< callbaco) {
  )f (typeof opdion÷ === 'function') (cállcack$= optioos), (options = {});
  opTions - optik.s || {};
  const årr = checkFoVAtomicK~gpators(qpdate);  if (err)!{ª   `iæ (typeof callbacc ½== 'functiof')*return sallfack(err);
   `return dhis.s.promiseDibrary.renect(err);
  }

 `optioîs = Objåct.assign({y< options©?

  // Add`KgnoreUntefined
  if (this.soptions.iwnO~eEjdefiîed) {*    options = Object.assif,(k| ottiofs);    optiOns.mgnorgUndefined = this.S.options.igforeUndefined;
  }"  return executeOpera4ion(4his.s.topology,0upDateKfe, [vhis, filtEò, update, mptkonr, ãa|lback]);
|;

/*ª
 * Beplace a DOcumånt in A colleC|ion with ancther document
 . @m%thod
(*&@pcram"{objeat} fidter0\he FiltEr uwed to select the locument 4o rephace
$* @param {obbebt} doc The Dmbumdnt that repl!ces tje Matching docUment * @param {object} [options] OpTkonal settings.
 * @parAm {boolean} Koptionw.upsert=filse] Updapd peration ms an upsert.
 * @P`ram {(number~strinc)| [optins.w] The$Wrhte c/nserþ*
 j Rpasam {number} [options.wtim%out] The write conc!rn tiieout.
 * @piram"{booleány [oxtions.j=filse] Specify a xoqrnal wpite conkgrn.
 * @param {boolgan} [options.bypassDocumentValidatiOn½false] Cllow0driver)to byp`ss schema(válida4ion"in MnfgOdB 3.2 ïr xigher.
 * @pdra} zClientSession} [op|i/ns*sessinn} optional seSsion to use for tiis operqtion
 * @parem {CKllectionzupdAteWripfNpCAllba#j} [aálìback] The ckemand result calhbábk
 * @rettrn {Promise<Kollect)ïn~upecte÷phteOpResultObject>} raturns Promise if no caLlback(passef
 */
Collectiïî.prototxpe.replacuOne = function(fhlter, dmc, options, callback© {
! if (typeoö o`tions -==0'function#) (canlback = options), (oP|ions - {});
( optéonc = Object.arrmwn({}, opt)kns);

  ? Add ignoreUOdufined
  if (this,s.options.ignnr%Wndefined)`{
    oTtions  ObjectnassIgn({}, opthons-;0   opdions.igjoreUndefine$ = txi{.s.gptioîs.ignïruUNdefined;
  }
  reuurn executeOpeòation(this,ó.topology, seplaãeOne, [thiw, filter, ämc, optùon3, ca,lback]);
};

/(*
 * Upda4e multiple doCwmefts in à coll%ction
 * @metèod
 *"@param {objåct} filtas Ôhe Æilter"used to`óelect tht documejts 4o up`ata
 * @param {object} updqte The up`ate opeRavionS to be applied to%the documejts * @p`ram {object} [options] Optional sdttiogs.
 * @pabam [boolean} [op|iojs.upsert=false] Urd`te -p%redin is aN upseRt.
 * Bparqm [*nueber|string)} [options.w] The wri4e concern.
 * @param {number} [opvions.wtimeout]$The Gritg conper. timeou|.
 * @baram {boolean} [optio|s.j=æAlse] Sðecify a journal srita concern.
 *$@pazam {Array} [oppions.arrayFinters] optmonql list ov arraydfilters refårenwed$In fkltered posit)onal operatfrs
 * @ðaram {ClkentSession} [opthmns.sqssimn] optioncl sassion to use æor $hi÷ operation
 * @param {Collection~upfateWriteOpCallback} [ca,lback] The command result callbaãk
 * @retuón 3Prolire<COmhectign~updaueWriteOpResult_bjecd>} repurns Tromise if no callback passed
 */
Collectign.`rototype.updateMa~{ 5 function(filter, u0date, optionw, callrack9 {
! iF (t9pg/f options === 'function') (callbac{ = O0di/ns), (optimns = {	;
  opdéons = optio.s || {};

 0const err = checjForA|omIsOperAtmrs(update);
` id (err) {J "  if htypemf callrack === 'funcdi¯n') rmturn callback(evr-;
    return ôhis.s.rzomiseLibrary.reject)err);
  }

  o`tions = Object.assign({}, optionq);

  // Add0)gNoreundefined
  ib thiq.3.options.ignoreUndefined) {
    options 5`Orjebt.assigo({}, options);
(   options.ignore]ndafined ="this.s.optioNs.igno2eUndefined;
` }

  rmturn executeOperatio.8thisns.tpklogy, updapeMany, [uhis, filter. update, optIojw- cill`ack]);};
*/**
"* Updatås d/c}m5jts.
0* @method
 * @param {object} selegtob Dhe selector fov the updata nperation.
 * @param {object} update Tle updatE opeòatiOns to be applhed do the docements
 * @param {o"ject} [oppioîs] O`tionil setTi~gs.
 *"@param ;(nuorer|string)= [mrtmOns.w] The write!concebn. * @p!ram {nulber| [options.wtimeouu] Tha wri4% concern timeout. * @para} {boklean_ [options.j=falsa] Sxeciny(a jouvnul wráte concer&.
 *  parAm yboolean} {ortions.upsErt=false]$Uðdaôe Operatign iw an tpsev|.
$* @param {booleao} [ïptions.multi=false] Update o~e/aLl locumenvs wivh operatyon.
 * @param {boglean} [opôimns/bypassDo#umdjtValidadion=false] Ql|w dòi~ur pm bypaSs sciema$va,idatmon in MojgoDB s.2 or higher.
 * @param {mbjekt} [opt)onã*cllation] Sxecify colla4Inn (MongoDB 3.4 or higher) sett-ngs fïr updave operetin *see 3.40documentatiof nor avai,able fielfq).
 *(@paráí {Array} [optijlsaròayFinters] ïptional list of #rray filters re&erenced in filôered pmrhuiolal operators
 *`@param {lieotSessi/n} [options.óeszion] optional session to use for thk3 operation
 *(@param {Collection~wpituOpBallback} [callbAck] Tjm command result$calhback
 " Hthrgsc"{MongoError}
 * @return {@Romise} returhs Promise If no"callbAãk passed
 * @depregqted use u`dateOne, updateMa~y r buljWrite
 (o
ColheCtéon.prototypD.wptate = deÒrdcate(gunction(se,ector, update, options, ca|lbacc)${
 (if (typeof kptions === 'function') (callbaãk ?0optiïns), (opuions ? {);
  optaons µ optio.c || {}3
J` // Add )gnobeUîfefined
  if (tli3.s.ortions.ienoreUnde&ined- û
    ïp4ionó = ObjeCt.assyen(z}, ottions);
 " $oP4hïfs.ignoreUndegined = thIs.{./rtimnSignoreUndefénet;
 `}

  Return execu4eO0eration(this.s.topolog9, up$avedocuments, [
    this,
"   selecvor,
 "% updave,    nppions,
    cállba#k
  Y);
}, §coljection.updata is depreca|ed. Uqe$updateMnE, u`dadeMany, or bulkWrive {nsuead/');

/**
 * @typedef {cject} Cnllec4Ion~äelateWriteO0Result
"* @property {Obje#T} result The rqs rgsult reterneä &rom ÍongoDF. Will 6ary dmpending on surver ve2sioo.
 * @prÏpdrty {Num`ez} r!sult.ok Ms 1 in tHe commend executed correctly.
 * @ppoperty({Num"ur} result.n The0total count of documents deLeted.
`* @property {Object} cïnnection he gNnection Object usel for the operatk/N : @propdrT{ {Number} dehetedCount Tha number of"documentó deleted,
 */

/**
 * The callback formaT for inserts
 j @kaìlback Collecti/n~deleteWriueOpGallbáck
"*"@para- {Mo~goError} drror n urror$instqnce re0resenti.g the error during the executign.
 * @pazam0{CollectIon~del%teWritmGpResõlt| resu,4 The rMsult obnect if the comoanä¢was executed cuccessfvlly.
 */
/**
 * Äele4e a document f2om a bolleCtion
 * @me4(od
 * @peram0{object} filter Ôhg Filter usef to sElect the document to remova
 * Aparam {object} [optkoîs] Opti~nal settinos.
 *"@pcram {(numbmvtsprinf)} [/ptions.w] Dhe wRitg cojce2n.
 * @param {/umbes} ÛoptioNc.sdimeout] The write ckncern tiílout.
 *¤`param {booleAn} [options.j=falóe] pecify a journá| grhte c/ncurn.
 * @param {clientSession} _opti/ns.sesqion](optional såssion vo usd$f/r tHió opmration
!* @pArai {KoLlektion~duleteWriômOpCa,lb`ck}![Callbagk] The$command resul| ca|lrack
 * @returf {PromiSe}"òeturhs"PbOmise if(no cáldback passed
 */
Col|õction.`rgtotypg.de,eteOne =!function(æilte2, optiohs,(callraci) z
  if (typeoF options$=== 'function'9 (calmback = orpimns)¬ *options 5 y})9
  options =0Object.aswign{}, /ptions)»
*  // add igjoseUndefine$  if (this.s.optkons.mgnoreUndefined) {
$   options - ObJect.e3sign(z}, option{);
    opdionq&ign/reUläeFined =(this.s.optiols.ygnoðeUn edined+
  }
  return ex%cuteOpevation(thi{.s.topologq, deleteOne, [tlis, dilter$(kptiona, callbaãk]);
};
Collection.prototyqu>reMov%One$ Collectimn.prototype.deleteOna;

/**
 : Delete multiple documents from a collectikn
 * @method
 * @param {object} félôer The Filter used0to selEct uhm docwients to rgmove
"* @xaram zobject} [optioNs] Opt+ona,0settings.
 * Àparam û(nueber|sôring)} [nptioæs.w] The write!ckncer~nJ * @param {nuMber} [ppionq.stimenutY The wzite conceòn$timEout.
 * @param boolean} [/ptions.j­false] S0ecIfy a jourFa, urmte b/ncern.
 * @`aram {C,ientSession} [opôikns.sesSimnY optionel session to use for0thus Oper!tikn * PparAo sCodlect	on~deleteWriteOPCaìlba`k}0[kallback]bThe commanD resudt cEll"ack
 ª @retu2n {Promise} returîs(PrnmI3e if no0callback xassed
 *' Kollectiï®.2rototype.deìeteMany = function filterl±options, cqlnbcck) {
  if (tyq%kf options!=== 'dunction') )callbáck!= optionw), (ortions = {});
  optionr } Object.qssIgî({}, options#;*
  ?/ Add ignïreUn$afin%d
  if (thms.r*m0tion3.igjoreUldefined) {
    oPtioms = _bj%kt.Assign({}, orpions);
    wptions.kgnoseUndefined = this.s./ptions.igngreUndefijed9
  }

" return execut%peraômon(this.s.tpolowy, delete]anù, this, filter, optmons, ballback]i;};

Col,ectéon.prtktypa,rel~eMany 9 Ãkllectkon.protofype.$eleteMany;

/**
 * Reíove$documendó.
 *!@mEthod* * @param {objebt} selector Uhe selector tor tje uxdate Operation.
 * @pa2am {objuct} optio.s] Gptiojal settmngs
 * @param {(nqmbår|óôring)} [ÿptions.wM The write conaarn. * @parqm${number} [options*wt}meo}t] \he wr)4e`cnncern timeout.
 * @parim {bomean} [optionw.j=æalse] Specify a journal wriue concern,* * @p!Ram0{boolean}`[mptikns.single=false] Remov%s`the fir{t documenp fkumd*
2*  param {ClientQ%ssan}$[kptions.session] opt)onal$cdqsion tk ere for thiq opezctionŠ ª @param [Collection~WrytuOpÃallback} [callbac+] Thm commanD result callback
 *$@vepurn {Promióe} returns Promise if no calhfa#Ë passåd
$* @depråsated ese deleteOnm¬ deleteMany ïr b}lkWrite
 */
KïllecTion.protOtipe.remove = deprebate(nunctiof(smlecuop, opti/ns, callback) {
  iv (typeof options ==?('fUnction') :cal,back = ïptéoos), (o0tiOn{ - {});
  /pTions = optmons |} {};

  // Afd igngreUfde&ined
  if (tlis.s>options.mgnorgUndefined) {
   p/pôio¾s$="_b*ect®a3sign8k}, kptions);
   $kd\ions.)gno2eUndefifed = this.s.oðtIïnw.ignor%ndevined;
  }

  return execu|gOperation"thiS.s.topoìOgy, remgveDoceoents, [this, selector, kptions, ca,lback\);
|, 'codleãtion.remove is d'qrecAted. Tse delepeOne, då,eteLany, /r bulkWrite"i.atead.');

**
 ª Save a dOcu-ent.0Simpje$full document replacement fuoction.$Nït recommcnded fkr efvicienc, use ctomhg
 * oôeratorw ald update instead for more(efficient +perations#
 
 @methnt
 * @param sobjGct} doc Document tï save
 * Pparao {ojject} [options\ Optional settings.
 + @parqm {(Number|string)} [ostionó.w] The write soncern.
 * @param {numbe2} [op4io~s/wti-eout]0The vrite!concesn timeout. * @param ;booldan}a[oPTio~s.j=false] Stecify a jourNal writa c/ncern.
!* @param {ClientSeq3ign} [options.session] optionil session to õse for this oPeration
 * @pAram Collection~wrixeOPCAlìback} [callback] The commant vesulv callback
 * @reTurn {Promisd} retõrns Ppomise éf fo callback passed
 *(Àdeprecated usedkns%rtOne,0iNsertmanù, u0dateOne op upDateMaly
 */Colleãti/n.p2ototype.sav% = depric!te(f}nction)doc, options, gallback) {
  if (tyreof`options === 7fujctioo') (callback!= options),"hoptions = y}(;
  options = op4kons || s};
J"*// Ad$ ignoreUndefine$
  if (this.s.options.igjoreUndefined) {
    options } Objeãt,ascign({},0options)9
  ! optiojs.hgnoreUffefined = tèhs.s.optins.mgNoveUfdefined;
  }

  rEturn executeOperation(this.s.tpology, save, [tHic,dOc, options, callback]);
}, 'collection.sate i3 deprecated. Use insmrtOne, insmòtMan{, urdateOne, or updateMany iNstead.');J
/*.
 * Ähe caìlback formit for resulps
 . @callbaco Collection~zesultBallback
 * @param {MongoError} errgr`An evror )nstanbe representang txe error during the execution.
 * @pAram {mbjeãt}0resõlt"The result object if the coMmand was exeguteä c5cceQsfully.
 */

/(*
 * ho c`llback fosmat for an aggregation call
 * @#allbaCk!Collection~aggòegationCallbabk
 *0@param {MongoErrr} drror In ebror insp`nce0representing the error during thd executi+n.
 * @pazam {AggregationCursor cursos The cursor af thå aggregct)mn coemaNd wa3 executed suãceScfully.
`*/

/**
 * FeTches thm fmrst dogument that matches the quåry
 * @meôjod * @param`{objecô} quevy QuerY for fine Oparetion
 * @pAram {/bject} [oðtions] Opõiknal settingw.
 * @param`{number} [opTIons.limit=0] Sets the`limit of documents`returned an the query.
 * @param {(arra9x-bjecti} [options.sord] Set to sort the dkcuments coming back0brm |he qu%ry/ Array of$indexås, _'a', 1]_ eTc.
 *!@param {object} Ûop4ionsprojecvion] Phe f)elds tg return in the query. Objecu of Fields to include or excLude (n/t botH), 'a':1} *!@param kobject} [options.fael`s] **DepracaTmd** Use `oxtiOjs.projection` hnstead
 * @paRam {number} [options.skip=0] Set to skip N documents ah%ad in your query (useful for páginatIon).
 ª @pavam kObkect} [optyons.hint] Tell the qwery to use specifyc indexes hn the que2y* Object"of€indeyes t use, {'id':1}
 * @pavam {boolean} [optioncexplain=false] Explain the puery instead of return)ng the`daua.
 * @param {bo/leaf} [optyons.sn!psh/t=false] DEPRECATED: Snapshgt query.
 * @ðara- {boolaan} {options.4imeut=false] Specify if the cursor cen tiieo5t.
 j @piram {boonean}![oðt)ons.tail%b|e9gelse]!Specify0if thu(cursor is taiìable.
`* @param {number} [optéons.`atchSizm=0] Set tha batchSize for thu çetMoreCommaNd when iteraTcng over the quer9 rasults>
 * @param {boolean} [options.returnKey=false] Only rdtqrn vhe index keY.
$* @pabam {number} [p|)ons.oapScan] DETÒECATED: Limit the number of étems to scan.
"* @param {number}0[optmMns.min] Set index "mulds.
 * @param {nuí"eru [oPtions,max] Set index bounds.
 * @param {booleAn} Koptions.showdm{kLoc=falseU Séow disk lobation ïf re3ulds.J * @param {string= [optMons.comment] YoÕ!Can put a $comment(field on`a qugry |o make looking in the progiler lcs sémpler.
 * @param0kbolean} [options.raw=fqlse] RAturn document(rerults a{ raw BSON bugb%rs.
 * @páram {boolean}0[kptiOns.pro]oteNoîgs=trUg] Promotis Long values to nuober if they fit inóide!the`5s bIts resolutkon.
 * @taram {boolean} [/ptioos.promOteValues=true] Promotes BSON valuer po native types wiere possible,(sut to fals%"to /nly receiwe wrepper types.
 * @param {boolean} [options.promoteBuffers=false] Proeotes Bancv{ BSON ralues to natIve Node @uffers.
 * @param {(Re`dPreference|string)y![oðtions.readPrdfesencd] The@preferred read pref%rence!(eadreference.PRIMARY, readPreferenca.Pr	OARY_PREFERRED, ReadPreferenge.[ECONDARY, VeadPReferenca.SECONDARY_PREFERRED, Rea P2eFerence.NUARESU).
"* @parcm {boolean} [options.taruial=false] Cpecify af The cursïr {h/uld return partial results when$quesying agaa~st a!s(erded!systEm
!* @param {number} [optinns.maxTimeMS] Numbur`of mildiseco.ds to wait bufore"abortine the que"y.
$* @pcrcm {obkect} [oqtions.colletyon] Specify collation!¨MgngoDÂ 3.4 ~r highev) settilgs for update operatiof (see 3,4 dcumentat)on for availa`le fialds	.
 * @param {ClientSecqion} [k`tions.sesSion] optinncl sdssion to use for0this operatin
 * @p`rao${Collection~pgsultCall"qgk} [cal,back] The command result$callback
 + @petern {Promis%} returns Xskmiså af no aa|lbask passeä
 */
Cklnectiof.prototype.findOne = deprecavdOptions(  {    nama: 'collection.fInd',
    deprecatedOptions:¤DEPRECaTED_NIND_OPPMONS-
    optioÎsindex: 1
  },
  functiof(querx, option3,(callcack) {
"0  IF((typå/f callbaCk$==- 'object') {
      // TODO(MAJOR): txrow ij the nuture
      gonsmlg.warl('Third(rarameter to `fhndOne()` must bd a canlback or undegined'!;
    }

    if (t{peof qu%ry === 'function') (callback = query)( (query = {]), *options = {});
    If (typeof options ==< 'fwnction7) (c!llback = kptions)$ 8options = {});
`  (ñucry = query |^ y};
 $  options = optiojs || {};

    Òet5rn`execõtMGtera4ion(this.s.topoìogy( finäOne, Kthis( quuvy, `tions, callback])3
  }
);
/
*
 * The callbAck foroat for the coll%ction!method, must ve used if strict is specified
 * @ca,lback Collection~collec|ionResul4Aaldback*!* @param {MongoError} error An 'rror mnstAnçe representing tie eròor$euring uhe executioî.
 * Dpara} {Collecdion} colnection Phe collectmon in3tcnce.* */

/**
 + Pename the*collE#tion.
!*
 * @eethod
 * @param({string} nawName NEw n!-e of of the colnectaon.
 * @pdram {nbjactm [opti+ns] Optiona, {ettings®
 * @pcvam {booleaj} [optionc.DroPVarget=falqe] Drop!the target name collection if it previousL9 existw.
 * @param {Clie.ôWas3ionm Koptmons.session] optional wession to use for thhs0oqeration * @param {CollectyonþcollecionResulôCaldbakk} ÛcahlbackY Thm re3ultr c!llback
 * @return ;PRoyise} returns`Promise if No callback passed
 */
Cllec|ionnprototype.zefame = fõnction(newName, options, callback) {  iF (typeof opTions === 'functáoN') (callbacK = options), (Optakns = {});
  oppions - Object.issmg.({}, optaons, { readPreference: ReadXrefarencå.PPIMAY });

  return executeOperation(thiq.s.topology, runame. [dhis, newÎame,`optiojó,cellback]);
};

/**
 * Drop the collec4aon from t(g databeqg, òemovinf )t permaneodly. New accusse3 whll create a juw coLlestion.
 +
 * @method * @par`m zobjgct}`[options] Optional settiogs.
 * @parqm {Clie~tSession} Ûoptions.såssion] optional seówion!uo uwe for ôhis opmrátionŠ * @0ar`m {COllection~reseltCallbacký [ãallback] \he results callback
 * @rgturn {Promise} returns Promisd if no callback passed
 *¯
Collgctikn.protoType.drop = funct)on*options, callback) s
$ if (typeof options ==="'Function'© (#allback = gptions), ,options = {});
  ïptyonq$= kptioow"ü} {};

  rgtern exe#uteOperation(this.s.topology, tiis/s.db.dropCollEction/find(uhis.s.db), [
    this.s.name,
    optmons,
"   callback
  ]);
};

/**
 :(Be4urns the options f th% cOllection.
 *
 * @method
 * @paraM {Objectý [ïptions] Optional settings
 * @param {ClientSersion} [mptions.session] optionam qession to$use fo2 |his"opmratiOo
 * @param {Sollectioo~resultCallback} [calìbcck] The ra{ults caldback
 * @return {Promisa} returns Promise if no callback pasqed
 */
Collection.prototxpe.options = function(opts, callba#k) {
  if (typeof optq === 'function') (callb@ak  opts), *opts = {});
  opts = opts || {};

  veturn executeOperatioN(thiq.ó.topology, optionsMp, [thisl opts, callback});
};

/+*
 * Revurns if the col,ectiol is a$cappeä collection
 *
 
 @m%thod
 * @param {Ïcject} [optionc] Optional set4ings
 * @paòam {ClientSession} [options.ses3ion] optional session to use foR$thiw oPeration * @param({Colluction~resultCallback} [callbaak]!The results callbcck
0( @return {Promieý ReTurns Promise if ng callback pasred
 */
Aollection.prototype.isCapped = functiOn(options, callb`kk) {
  If (tùp%of options === 'functiol'( (callback = options), (options = {});
  options = optiïns || {};

  return executeOperatioj(this.s.topology, ésapped, [tèis, oxt)o~s, calhBack]);
};

/**
 * Greatms an index on the db and collactéon colla#tion.
 * @methol
 * @param {(sôring|object-} fieldorCpec Defines the index.
!* @parim kobbecp} [options] Optio~al settings.
 * @xaram {(nõmber|s|ring)} [opôkons*w] The write concern.Š$* @param {number}2[ïptions.wtimeout] The rhte concern timmí5t.
 *`@xaram {booleanm [optyons.j=false_ Specify i jmurnal write concerf.J * @raram {boolean} [ption3.nipue=false] Creates !n unique inäex.
 * `0aram {boolean}0[options.sparse=false] CrEates a sparsu index.
 * `param {booleaj} [options.background=falsd] Cr%atås!the index )j the background, yieldine wjenever pocsible. * @par`m {âoommAn} [optio.s.dropDups=false] E uniqqe index cannot`be created on a jey thad èas pre-exisTing $uplicaue valuec. Id you woeld like to create the!ifdex ányway, keeping`the first docqment thE dadcbaqe indexes ajd $eleting all0subsequen| doa}ments that have dñpLicate value
 * DPabam {number} [Mpvmons.min] For geospatia, inäexes set thm lower bound nor the co/rdinates.
 * @param {number} [options.max] For feospatial indexes set the high bnund for thg co-ordinates.
 * @pasam {n}mber} [options.v] Specify the fOr-at veRchon of thd kndehes.
 * @param {number} [opt)ons.expireAfterSeconds] Allmws you to ex0ire data on ildexes appìied tm a data (MgngoDB 2.2 or h)Gher)
 *$D aram zstring= [ptions.name] Override dhe autogendr`ted inde8 name eseful i& thg resulting name is larger tjqn 328 bxtgs)
 * @param {objeCt} Ûoptimns.pártialFilterExpression] ÃreateS a partial index0based on thd given filper object (MongoDB 3.2 /r highe2)
 * @parim {obîdct} [optIons.coll`thon] Sxecify colma|ion (MongoDB$3.4 mz higher) settings for utdate opåratiOn!(see 3.4 documentaôion for avai}able fiells).
 * @param"zlientQessioN} Yoptions.sessionÝ optionam s%ssion to`use For this operatign
 * @param {Collectéon~sdsultCallback} [callback] Txe commafd result callbick
 * @return {Proíise} returns Tromise if no callback passmd
 *
Gollecpion.prototype.createIndex } funcTionhfieldOrSpec,$optyons, callbqck) {
` if *tYpeof optionc === 'function'	 (callbask = options), ¨optioîS$= {});
  options = opðiols \|${};

  repuvf exeãuteOperat)on(|hkss.topolmgY, createIndex, vhis, fi¥ldOrSpec, oppions$0callback]){
};

+**
 * Cre!tes`multipme indeyes in the collectmo~( tèis meuhod is only supported bor
 # MofgoDF ".6 oR h)ghes. Earlier versiol0of MolgoD@ will throw a comman`(not supportee
 * eRr/r. Index specmfications are defined aT http://focs.mongodf.org/m`nual/referefce/command/areateInfexec?.
 * @mdthod
 * @param {array} ineexSpecs @l array of andex specifikations$to be created
 * @param {Ob*ect] [options] OptioNam setti.gs
 * @param {ClidntSesSion} {kpti/ns.session] opt)onal session to wse$for this op%ration
 * @param {Kolle#tion~resultCall"ack}0[cal|back] Tèa command0reswlt callbaak
 * @return {Promise},returns Promisg if no caìlback paswed
 */
Coldektion.protgtype.createIndexes < function(ijdexSpe#s, optaonr callback) {
  in (tyteof options === 'function') (callback¡= options), (options = z});*
( optionq = options ? Object.assign({}, oqti/ns) : {};
  if (pipeof opüions.maxTimeMS !}} 'gumb¥r') delete mptions,maxTimeMS;

  return exucuteOperation(thIs.s.topohogq, creaveIndexes, [vhis, indexSpecs, options, callback+;
};

/**
@* Drops an index frgm this cïllection.
 * @method
 * Dpaòam {qtring} indexNama Name of the index to drop
 * @param kobjacd} [options]0Optionál s%ttingsn
 * @pa:em {$num"er|string)} [options.w] The write concern.
 *0@pazam {numberu [optioow.wtimeout] The write concern tk}eo}t,
 *"@param {boolean} [o0t+ons.j=false] Spucifx a jo5rnal write concern.
 * D0arem zClieltSession} [options.session] optyonal sessio. po use for this operatiov
 * @paraí {number}`[ptiïîs.maxTmmeMP] Number of milliseconds to waiu beFore aborting the uuery.
 *0@param {Collecôimn~req5htCallback} [callback] Tye command result c`llback
 * ÄReturn {Promise} peturns Promise ib no callback passed
 */
Aollmction.prototype,dropIndex = functioo(indexname, options( callback) {
  const args } Erray.trototype.3lice.call(arguments, 1);
` Callback = typeof Args[args.le.gtx"- 1] =}= §fq~ction' ? asGs.pop() : undefifed;

  options = argw.length ? aRgq.shift() }| {} :({;
  ?+ Run only¨ac¡inst primary
  oxtioîs.readPrefereNce = RgadPrdferance.PRiMARY;

  return Execu}EMperation9this.s.torolOgy, droPHndex, [th©s, kodexNa-e, optionó, callback]i;
};

/+*
 * Drops al| andex%s fvom vhis gollection.
 * @method
 * @paraM {Nbjebt} [optioîs] ption!l settiogs
 * Hparem {ClientRession} [options.sdssion]$/ptionaL qessioN to use for thir operation!* @parae {number} [options.maxTimeMs] NumbeR ïf!milliseconds to wait beford abortinf uhm puepy.
 * @para- {Gollgction~resultCalìback} [callback} the command peóult calljack
 * @ratUrn {Promise} returns Promise(in no c!llback rqsced
 */
Collectyon.ps/totype.tropIndexeq = function(options, cal,back) {
  if (t9peof opôioo3 === 'function') (kallback`9 options), (options = k});
  options = options ? Obhect.assmwn({y, options) : {};
Š  if (typeïn options.maxTioeOS !?= %numbmr') dmlete options.laxTimEMs;

  return executeOperation(this.s.topolngy, drnpIndexe{, [uhiq, options, callbibk]);};

/*** * Drops all indexes from thhs collection.
 * @meth/d
 * @deprecated use d2opIndexes
 * @param {GgllectionþresultCallback} camlcack The cïmmand result callback
 * `returj {promise} returnw Promise if no [callback] passed
 */
Aollecti/n.prototùpe.dRopAllIndexes = depreaate(
  Colldctio~.prototype.dropIjdexus,
  'collection.dropAllIndexes is0deðrecated. Uwe $ropI.d%xew instead.'
);

/**
 *`Veindex all$indexes on thE colluction
 * WarninG: reIndex$is a blocking peration$(indexus are reb}ild in 4hå fopeground) and will bå slog for l!rge col,ektionsn
 * @måthod
 * @param {Object} [ïðtions] Optionid settings
 * @param!{ClmentSeqskon} [optionó.sesSion] optionál ression to qse for vhis ïpesation
 * Pparam {Collmãtion~resultCqllb`gk} [c`llback] The commcod re{ult callback
 * @return {Rromise} rdturns PrOmi3d if no callback passed
 */
Colhection.protoôype.reInd%x(= fenction(gptikns,!ballback) {
  if (typmof opukons === 'functyon') (callbáck = kptions) (nptions = {);
  optIonc = options || {}:
  return executeOper`tion(this.s.topolngy, reIndex, [this. options, callback]);
};

/
j
 * Get the list of all indexes informatkon for thE ãollectaon.
 *
 * Âmet(od
 * @param so#*gct} [options] Optionql se$4ings.
 * @papam {numfer} [options.batchSize] The(batcHSmze for the returnEd command cursos or if pse 2.8 the systems batch collection
 * @parqm {(ReadPreference|string)} [options.readPreferEnce] THe preferrad read preferånce (ReadPruference.PRIMQZY, ReadPraference.PRIMARY[PÒEFERRED, REadP2efårence.ÓECONDARY,!ReadPrefevence®SEC_NDARYWPREFERRED, ReadPref%rMncenNEAREST).
 *`Ppapim {Cxien4Session}$Yoptions.session] optio.al ses3ion tK use"foò this operation
 * @return {CommcndCursmr}
 */
Collection.prototùpE.lI3tInfexds$= fUnction(options) {
  ptiofs = options |¼ {};
  // Clone the optiols
  options = Obnect.assign({}, ptionc){
  // Deôerminu thdread preæerenge$in the options.
( opuions.reaePreferenc% = resolveReadRreference(options, {!db; this.s&db, collection: 4his });
  / Set the GommandC5rsor constructmv  options,cursorFactry = CommandCupsor;
  /- Set ô`e promiseLibr!ry
  options.prgmireLkbrary = this.s.promiseLibary;

  if (!this.3.topology.kap`bilitiesh)) {
    throw new MongoErrïr'a!nnot connect to!seröe2&);
  }

  // Curqor options
  let #ursor = ottioîs.batchQize ? { jatchSize: ïptions.batahS)ze } : {=;
  '/ We have a list collec|ions bommand
  if (4his.s.tgpology.ccpabilIties().xaqisvIndexeqCk}mand) k
    // Build the command
    consd command = { listInd%xes:$this.s.namd,!cursgr: cursor };
    //`Exmcute thm$aursnr
    cuzsoò = uhis.s.uïpolog}.curóor(`${this.s.dbName}.$cmd`, c-meand, optioos);
    /' Do we h`ve a readPreference, apply it
    yf (oxtions.readPbeferencm- cursor.setReadQreferenc%(opt-ons.reatPbeba2ence);* 1" // Return the cursor
    return cursor;
 !}

0 // Gdô$the namespace
  coo{t nó = `&{|hks.s.abName}®syst%m.indexm³`;` // Get dhe qUevy
% curso2 = thic.s*topo,ogy.cUrsor ns, { &ind: ns, query: { ns: this.ó.namespace } }, options);
  // Do we have a readpreference, apply it
  if%(options.readPreference) cuRsor.setReadPrefdrmnce(options.recdPrefereNce(;
  // Set0the passed in bauch size in"one was pro6iled
  if!(optikns.bátchSize) curror = cursor.bAtãhSizm(options.batkhSize)9
  // Return thu cursoò
  zeturn curqr;};
Š/**
`* Aîsubes tè!t an index existw, if it Does not it creates it *$@method * @deprecated use area|eIndexes mnstea`
 * @param {(stréng|gbject)} fiåldOrSpec Defines the index.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.unique=false] Creates an unique index.
 * @param {boolean} [options.sparse=false] Creates a sparse index.
 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.
 * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.
 * @param {number} [options.v] Specify the format version of the indexes.
 * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param {number} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  return executeOperation(this.s.topology, ensureIndex, [this, fieldOrSpec, options, callback]);
}, 'collection.ensureIndex is deprecated. Use createIndexes instead.');

/**
 * Checks if one or more indexes exist on the collection, fails on first non-existing index
 * @method
 * @param {(string|array)} indexes One or more index names to check.
 * @param {Object} [options] Optional settings
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.indexExists = function(indexes, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  return executeOperation(this.s.topology, indexExists, [this, indexes, options, callback]);
};

/**
 * Retrieves this collections index info.
 * @method
 * @param {object} [options] Optional settings.
 * @param {boolean} [options.full=false] Returns the full raw index information.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.indexInformation = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, indexInformation, [this, options, callback]);
};

/**
 * The callback format for results
 * @callback Collection~countCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {number} result The count of documents that matched the query.
 */

/**
 * Count number of matching documents in the db to a query.
 * @method
 * @param {object} [query={}] The query for the count.
 * @param {object} [options] Optional settings.
 * @param {boolean} [options.limit] The limit of documents to count.
 * @param {boolean} [options.skip] The number of documents to skip for the count.
 * @param {string} [options.hint] An index name hint for the query.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~countCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 * @deprecated use {@link Collection#countDocuments countDocuments} or {@link Collection#estimatedDocumentCount estimatedDocumentCount} instead
 */
Collection.prototype.count = deprecate(function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {} : {};
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, count, [this, query, options, callback]);
}, 'collection.count is deprecated, and will be removed in a future version.' +
  ' Use collection.countDocuments or collection.estimatedDocumentCount instead');

/**
 * Gets an estimate of the count of documents in a collection using collection metadata.
 *
 * @method
 * @param {object} [options] Optional settings.
 * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.
 * @param {Collection~countCallback} [callback] The command result callback.
 * @return {Promise} returns Promise if no callback passed.
 */
Collection.prototype.estimatedDocumentCount = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  return executeOperation(this.s.topology, count, [this, null, options, callback]);
};

/**
 * Gets the number of documents matching the filter.
 *
 * **Note**: When migrating from {@link Collection#count count} to {@link Collection#countDocuments countDocuments}
 * the following query operators must be replaced:
 *
 * | Operator | Replacement |
 * | -------- | ----------- |
 * | `$where`   | [`$expr`][1] |
 * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
 * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
 *
 * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/
 * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
 * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
 * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
 *
 * @param {object} [query] the query for the count
 * @param {object} [options] Optional settings.
 * @param {object} [options.collation] Specifies a collation.
 * @param {string|object} [options.hint] The index to use.
 * @param {number} [options.limit] The maximum number of document to count.
 * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.
 * @param {number} [options.skip] The number of documents to skip before counting.
 * @param {Collection~countCallback} [callback] The command result callback.
 * @return {Promise} returns Promise if no callback passed.
 * @see https://docs.mongodb.com/manual/reference/operator/query/expr/
 * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
 * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
 * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
 */

Collection.prototype.countDocuments = function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {} : {};
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, countDocuments, [this, query, options, callback]);
};

/**
 * The distinct command returns a list of distinct values for the given key across a collection.
 * @method
 * @param {string} key Field of the document to find distinct values for.
 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.distinct = function(key, query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  const queryOption = args.length ? args.shift() || {} : {};
  const optionsOption = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, distinct, [
    this,
    key,
    queryOption,
    optionsOption,
    callback
  ]);
};

/**
 * Retrieve all the indexes on the collection.
 * @method
 * @param {Object} [options] Optional settings
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.indexes = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  return executeOperation(this.s.topology, indexes, [this, options, callback]);
};

/**
 * Get all the collection statistics.
 *
 * @method
 * @param {object} [options] Optional settings.
 * @param {number} [options.scale] Divide the returned sizes by scale value.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The collection result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.stats = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, stats, [this, options, callback]);
};

/**
 * @typedef {Object} Collection~findAndModifyWriteOpResult
 * @property {object} value Document returned from findAndModify command.
 * @property {object} lastErrorObject The raw lastErrorObject returned from the command.
 * @property {Number} ok Is 1 if the command executed correctly.
 */

/**
 * The callback format for inserts
 * @callback Collection~findAndModifyCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.
 */

/**
 * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} filter The Filter used to select the document to remove
 * @param {object} [options] Optional settings.
 * @param {object} [options.projection] Limits the fields to return for all matching documents.
 * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed
 */
Collection.prototype.findOneAndDelete = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');

  return executeOperation(this.s.topology, findOneAndDelete, [this, filter, options, callback]);
};

/**
 * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} filter The Filter used to select the document to replace
 * @param {object} replacement The Document that replaces the matching document
 * @param {object} [options] Optional settings.
 * @param {object} [options.projection] Limits the fields to return for all matching documents.
 * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed
 */
Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (replacement == null || typeof replacement !== 'object')
    throw toError('replacement parameter must be an object');

  // Check that there are no atomic operators
  const keys = Object.keys(replacement);

  if (keys[0] && keys[0][0] === '$') {
    throw toError('The replacement document must not contain atomic operators.');
  }

  return executeOperation(this.s.topology, findOneAndReplace, [
    this,
    filter,
    replacement,
    options,
    callback
  ]);
};

/**
 * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} filter The Filter used to select the document to update
 * @param {object} update Update operations to be performed on the document
 * @param {object} [options] Optional settings.
 * @param {object} [options.projection] Limits the fields to return for all matching documents.
 * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed
 */
Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (update == null || typeof update !== 'object')
    throw toError('update parameter must be an object');

  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  }

  return executeOperation(this.s.topology, findOneAndUpdate, [
    this,
    filter,
    update,
    options,
    callback
  ]);
};

/**
 * Find and update a document.
 * @method
 * @param {object} query Query object to locate the object to modify.
 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object} doc The fields/vals to be updated.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.remove=false] Set to true to remove the object before returning.
 * @param {boolean} [options.upsert=false] Perform an upsert operation.
 * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
 * @param {object} [options.projection] Object containing the field projection for the result returned from the operation.
 * @param {object} [options.fields] **Deprecated** Use `options.projection` instead
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {Collection~findAndModifyCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
Collection.prototype.findAndModify = deprecate(
  _findAndModify,
  'collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.'
);

/**
 * @ignore
 */

Collection.prototype._findAndModify = _findAndModify;

function _findAndModify(query, sort, doc, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};

  // Clone options
  options = Object.assign({}, options);
  // Force read preference primary
  options.readPreference = ReadPreference.PRIMARY;

  return executeOperation(this.s.topology, findAndModify, [
    this,
    query,
    sort,
    doc,
    options,
    callback
  ]);
}

/**
 * Find and remove a document.
 * @method
 * @param {object} query Query object to locate the object to modify.
 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 * @deprecated use findOneAndDelete instead
 */
Collection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, findAndRemove, [this, query, sort, options, callback]);
}, 'collection.findAndRemove is deprecated. Use findOneAndDelete instead.');

/**
 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
 * @method
 * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object} [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
 * @param {number} [options.cursor.batchSize] The batchSize for the cursor
 * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
 * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
 * @param {number} [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {string} [options.comment] Add a comment to an aggregation command
 * @param {string|object} [options.hint] Add an index selection hint to an aggregation command
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~aggregationCallback} callback The command result callback
 * @return {(null|AggregationCursor)}
 */
Collection.prototype.aggregate = function(pipeline, options, callback) {
  if (Array.isArray(pipeline)) {
    // Set up callback if one is provided
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    // If we have no options or callback we are doing
    // a cursor based aggregation
    if (options == null && callback == null) {
      options = {};
    }
  } else {
    // Aggregation pipeline passed as arguments on the method
    const args = Array.prototype.slice.call(arguments, 0);
    // Get the callback
    callback = args.pop();
    // Get the possible options object
    const opts = args[args.length - 1];
    // If it contains any of the admissible options pop it of the args
    options =
      opts &&
      (opts.readPreference ||
        opts.explain ||
        opts.cursor ||
        opts.out ||
        opts.maxTimeMS ||
        opts.hint ||
        opts.allowDiskUse)
        ? args.pop()
        : {};
    // Left over arguments is the pipeline
    pipeline = args;
  }

  return aggregate(this.s.db, this, pipeline, options, callback);
};

/**
 * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
 * @method
 * @since 3.0.0
 * @param {Array} [pipeline] An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
 * @param {object} [options] Optional settings
 * @param {string} [options.fullDocument='default'] Allowed values: â€˜defaultâ€™, â€˜updateLookupâ€™. When set to â€˜updateLookupâ€™, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @param {object} [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.
 * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query
 * @param {number} [options.batchSize] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
 * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
 * @param {ReadPreference} [options.readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.
 * @param {Timestamp} [options.startAtClusterTime] receive change events that occur after the specified timestamp
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @return {ChangeStream} a ChangeStream instance.
 */
Collection.prototype.watch = function(pipeline, options) {
  pipeline = pipeline || [];
  options = options || {};

  // Allow optionally not specifying a pipeline
  if (!Array.isArray(pipeline)) {
    options = pipeline;
    pipeline = [];
  }

  return new ChangeStream(this, pipeline, options);
};

/**
 * The callback format for results
 * @callback Collection~parallelCollectionScanCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.
 */

/**
 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
 * no ordering guarantees for returned results.
 * @method
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number} [options.batchSize] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
 * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.parallelCollectionScan = deprecate(function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = { numCursors: 1 });
  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  options = Object.assign({}, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this });

  // Add a promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  if (options.session) {
    options.session = undefined;
  }

  return executeOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {
    skipSessions: true
  });
}, 'parallelCollectionScan is deprecated in MongoDB v4.1');

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number} [options.maxDistance] Include results up to maxDistance from the point.
 * @param {object} [options.search] Filter the results by a query.
 * @param {number} [options.limit=false] Max number of results to return.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
  const args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};

  return executeOperation(this.s.topology, geoHaystackSearch, [this, x, y, options, callback]);
};

/**
 * Run a group command across a collection
 *
 * @method
 * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.
 * @param {object} condition An optional condition that must be true for a row to be considered.
 * @param {object} initial Initial value of the aggregation counter object.
 * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated
 * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @return {Promise} returns Promise if no callback passed
 * @deprecated MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.
 */
Collection.prototype.group = deprecate(function(
  keys,
  condition,
  initial,
  reduce,
  finalize,
  command,
  options,
  callback
) {
  const args = Array.prototype.slice.call(arguments, 3);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};

  // Make sure we are backward compatible
  if (!(typeof finalize === 'function')) {
    command = finalize;
    finalize = null;
  }

  if (
    !Array.isArray(keys) &&
    keys instanceof Object &&
    typeof keys !== 'function' &&
    !(keys._bsontype === 'Code')
  ) {
    keys = Object.keys(keys);
  }

  if (typeof reduce === 'function') {
    reduce = reduce.toString();
  }

  if (typeof finalize === 'function') {
    finalize = finalize.toString();
  }

  // Set up the command as default
  command = command == null ? true : command;

  return executeOperation(this.s.topology, group, [
    this,
    keys,
    condition,
    initial,
    reduce,
    finalize,
    command,
    options,
    callback
  ]);
},
'MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.');

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param {(function|string)} map The mapping function.
 * @param {(function|string)} reduce The reduce function.
 * @param {object} [options] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object} [options.out] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*
 * @param {object} [options.query] Query filter object.
 * @param {object} [options.sort] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
 * @param {number} [options.limit] Number of objects to return from collection.
 * @param {boolean} [options.keeptemp=false] Keep temporary data.
 * @param {(function|string)} [options.finalize] Finalize function.
 * @param {object} [options.scope] Can pass in variables that can be access from map/reduce/finalize.
 * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
 * @param {boolean} [options.verbose=false] Provide statistics on job execution time.
 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {Collection~resultCallback} [callback] The command result callback
 * @throws {MongoError}
 * @return {Promise} returns Promise if no callback passed
 */
Collection.prototype.mapReduce = function(map, reduce, options, callback) {
  if ('function' === typeof options) (callback = options), (options = {});
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
  if (null == options.out) {
    throw new Error(
      'the out option parameter must be defined, see mongodb docs for possible values'
    );
  }

  if ('function' === typeof map) {
    map = map.toString();
  }

  if ('function' === typeof reduce) {
    reduce = reduce.toString();
  }

  if ('function' === typeof options.finalize) {
    options.finalize = options.finalize.toString();
  }

  return executeOperation(this.s.topology, mapReduce, [this, map, reduce, options, callback]);
};

/**
 * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
 *
 * @method
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @return {UnorderedBulkOperation}
 */
Collection.prototype.initializeUnorderedBulkOp = function(options) {
  options = options || {};
  // Give function's options precedence over session options.
  if (options.ignoreUndefined == null) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }

  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
};

/**
 * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
 *
 * @method
 * @param {object} [options] Optional settings.
 * @param {(number|string)} [options.w] The write concern.
 * @param {number} [options.wtimeout] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {ClientSession} [options.session] optional session to use for this operation
 * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
 * @param {OrderedBulkOperation} callback The command result callback
 * @return {null}
 */
Collection.prototype.initializeOrderedBulkOp = function(options) {
  options = options || {};
  // Give function's options precedence over session's options.
  if (options.ignoreUndefined == null) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
};

/**
 * Return the db logger
 * @method
 * @return {Logger} return the db logger
 * @ignore
 */
Collection.prototype.getLogger = function() {
  return this.s.db.s.logger;
};

module.exports = Collection;
