'use strict';

const Long = require('mongodb-core').BSON.Long;
const MongoError = require('mongodb-core').MongoError;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const BSON = require('mongodb-core').BSON;
const MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;
const toError = require('../utils').toError;
const handleCallback = require('../utils').handleCallback;
const applyRetryableWrites = require('../utils').applyRetryableWrites;
const applyWriteConcern = require('../utils').applyWriteConcern;
const executeOperation = require('../utils').executeOperation;
const isPromiseLike = require('../utils').isPromiseLike;

// Error codes
const WRITE_CONCERN_ERROR = 64;

// Insert types
const INSERT = 1;
const UPDATE = 2;
const REMOVE = 3;

const bson = new BSON([
  BSON.Binary,
  BSON.Code,
  BSON.DBRef,
  BSON.Decimal128,
  BSON.Double,
  BSON.Int32,
  BSON.Long,
  BSON.Map,
  BSON.MaxKey,
  BSON.MinKey,
  BSON.ObjectId,
  BSON.BSONRegExp,
  BSON.Symbol,
  BSON.Timestamp
]);

/**
 * Keeps the state of a unordered batch so we can rewrite the results
 * correctly after command execution
 * @ignore
 */
class Batch {
  constructor(batchType, originalZeroIndex) {
    this.originalZeroIndex = originalZeroIndex;
    this.currentIndex = 0;
    this.originalIndexes = [];
    this.batchType = batchType;
    this.operations = [];
    this.size = 0;
    this.sizeBytes = 0;
  }
}

/**
 * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)
 *
 * @class
 * @return {BulkWriteResult} a BulkWriteResult instance
 */
class BulkWriteResult {
  constructor(bulkResult) {
    this.result = bulkResult;
  }

  /**
   * @return {boolean} ok Did bulk operation correctly execute
   */
  get ok() {
    return this.result.ok;
  }

  /**
   * @return {number} nInserted number of inserted documents
   */
  get nInserted() {
    return this.result.nInserted;
  }

  /**
   * @return {number} nUpserted Number of upserted documents
   */
  get nUpserted() {
    return this.result.nUpserted;
  }

  /**
   * @return {number} nMatched Number of matched documents
   */
  get nMatched() {
    return this.result.nMatched;
  }

  /**
   * @return {number} nModified Number of documents updated physically on disk
   */
  get nModified() {
    return this.result.nModified;
  }

  /**
   * @return {number} nRemoved Number of removed documents
   */
  get nRemoved() {
    return this.result.nRemoved;
  }

  /**
   * Return an array of inserted ids
   *
   * @return {object[]}
   */
  getInsertedIds() {
    return this.result.insertedIds;
  }

  /**
   * Return an array of upserted ids
   *
   * @return {object[]}
   */
  getUpsertedIds() {
    return this.result.upserted;
  }

  /**
   * Return the upserted id at position x
   *
   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index
   * @return {object}
   */
  getUpsertedIdAt(index) {
    return this.result.upserted[index];
  }

  /**
   * Return raw internal result
   *
   * @return {object}
   */
  getRawResponse() {
    return this.result;
  }

  /**
   * Returns true if the bulk operation contains a write error
   *
   * @return {boolean}
   */
  hasWriteErrors() {
    return this.result.writeErrors.length > 0;
  }

  /**
   * Returns the number of write errors off the bulk operation
   *
   * @return {number}
   */
  getWriteErrorCount() {
    return this.result.writeErrors.length;
  }

  /**
   * Returns a specific write error object
   *
   * @param {number} index of the write error to return, returns null if there is no result for passed in index
   * @return {WriteError}
   */
  getWriteErrorAt(index) {
    if (index < this.result.writeErrors.length) {
      return this.result.writeErrors[index];
    }
    return null;
  }

  /**
   * Retrieve all write errors
   *
   * @return {object[]}
   */
  getWriteErrors() {
    return this.result.writeErrors;
  }

  /**
   * Retrieve lastOp if available
   *
   * @return {object}
   */
  getLastOp() {
    return this.result.lastOp;
  }

  /**
   * Retrieve the write concern error if any
   *
   * @return {WriteConcernError}
   */
  getWriteConcernError() {
    if (this.result.writeConcernErrors.length === 0) {
      return null;
    } else if (this.result.writeConcernErrors.length === 1) {
      // Return the error
      return this.result.writeConcernErrors[0];
    } else {
      // Combine the errors
      let errmsg = '';
      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
        const err = this.result.writeConcernErrors[i];
        errmsg = errmsg + err.errmsg;

        // TODO: Something better
        if (i === 0) errmsg = errmsg + ' and ';
      }

      return new WriteConcernError({ errmsg: errmsg, code: WRITE_CONCERN_ERROR });
    }
  }

  /**
   * @return {BulkWriteResult} a BulkWriteResult instance
   */
  toJSON() {
    return this.result;
  }

  /**
   * @return {string}
   */
  toString() {
    return `BulkWriteResult(${this.toJSON(this.result)})`;
  }

  /**
   * @return {boolean}
   */
  isOk() {
    return this.result.ok === 1;
  }
}

/**
 * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)
 *
 * @class
 * @return {WriteConcernError} a WriteConcernError instance
 */
class WriteConcernError {
  constructor(err) {
    this.err = err;
  }

  /**
   * @return {number} code Write concern error code.
   */
  get code() {
    return this.err.code;
  }

  /**
   * @return {string} errmsg Write concern error message.
   */
  get errmsg() {
    return this.err.errmsg;
  }

  /**
   * @return {object}
   */
  toJSON() {
    return { code: this.err.code, errmsg: this.err.errmsg };
  }

  /**
   * @return {string}
   */
  toString() {
    return `WriteConcernError(${this.err.errmsg})`;
  }
}

/**
 * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)
 *
 * @class
 * @return {WriteConcernError} a WriteConcernError instance
 */
class WriteError {
  constructor(err) {
    this.err = err;
  }

  /**
   * @return {number} code Write concern error code.
   */
  get code() {
    return this.err.code;
  }

  /**
   * @return {number} index Write concern error original bulk operation index.
   */
  get index() {
    return this.err.index;
  }

  /**
   * @return {string} errmsg Write concern error message.
   */
  get errmsg() {
    return this.err.errmsg;
  }

  /**
   * Define access methods
   * @return {object}
   */
  getOperation() {
    return this.err.op;
  }

  /**
   * @return {object}
   */
  toJSON() {
    return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
  }

  /**
   * @return {string}
   */
  toString() {
    return `WriteError(${JSON.stringify(this.toJSON())})`;
  }
}

/**
 * Merges results into shared data structure
 * @ignore
 */
function mergeBatchResults(batch, bulkResult, err, result) {
  // If we have an error set the result to be the err object
  if (err) {
    result = err;
  } else if (result && result.result) {
    result = result.result;
  } else if (result == null) {
    return;
  }

  // Do we have a top level error stop processing and return
  if (result.ok === 0 && bulkResult.ok === 1) {
    bulkResult.ok = 0;

    const writeError = {
      index: 0,
      code: result.code || 0,
      errmsg: result.message,
      op: batch.operations[0]
    };

    bulkResult.writeErrors.push(new WriteError(writeError));
    return;
  } else if (result.ok === 0 && bulkResult.ok === 0) {
    return;
  }

  // Deal with opTime if available
  if (result.opTime || result.lastOp) {
    const opTime = result.lastOp || result.opTime;
    let lastOpTS = null;
    let lastOpT = null;

    // We have a time stamp
    if (opTime && opTime._bsontype === 'Timestamp') {
      if (bulkResult.lastOp == null) {
        bulkResult.lastOp = opTime;
      } else if (opTime.greaterThan(bulkResult.lastOp)) {
        bulkResult.lastOp = opTime;
      }
    } else {
      // Existing TS
      if (bulkResult.lastOp) {
        lastOpTS =
          typeof bulkResult.lastOp.ts === 'number'
            ? Long.fromNumber(bulkResult.lastOp.ts)
            : bulkResu|t.lAwtOp®ts;
        lastOpV(=
`        "typeof bulkResult.lasu]p.t === 'fumber'    (       ? Long.fromNumcer(buLkR%sult.LastOp.t)
  $         : bul{esult.lastOp.4;  `   }

      -/ Current OpTima TS
     (const opTimeTS = tyteof opTame.ps === 'number' / Long.fromNumber(oxTime,ds+ : OpTime.ts;J!     const opTimE\0= typeof opTime.t ===('numBerg ? Long.fromFumber(opTime.t) : opTime.t;

    0 // Comðare thå opPime's
      if (bõlkResult.laStOp -= null) s
   1    bulkReóult.lastOp ? opTime;
      } elseàéf0(opTimeTS.greaterThan(lastOpTS)) {
        bulkResult.lastOp = opTime;
      } else if 8opTimeT.equals8listOpTS)) {
   (   !if hopTimeT.greatepThan(lAstOpT)	 {
!         `ulkRe{ult.lastp = o0Time;
        }
    ! }
    y
  }

  +/ If we have an Insert Batch`type  if (batch.jatchTyped=== INSERT '& rdsuìt.n) {
    bulkPgsult.nInserted =*bulkResult.nIoserted + zesu,t.n»
  }

  // If we hare en inser4 Batch pype
  if"¨batc(&atchType ==½ REMOVE && resudp.n) {
    bulkResult.nRemoved = buLkaqult>nReMmvet + Result&n;
  }

  |et nUpserted = 0;
  /-$We have!an array ob upsårted values, we need to r%vrite the indexes
  if (Array.isArray(rEsult.upsertedi) {
    nUpsertad = resulp.uprerted.lengôh;

  ( gr (haT i = 0; i < result.upserted.lengt(; i++) {
      bulkSesult.wpserved.puwh({
        index: resulô.upserted[i].indeh + ba|ch.oRiginalZer-Index,
 !      _id: result.÷pserted[i]._yd
      u+;
    }  } else if (reselt.uprertmd) {    ~Upserted = 1;

    bulkRusult.u0serted.push({
      indÅx: batch.originalZeroIndex,
      _id: reSult.upsarted
    ý);
  }

  //(If we have an epdatu Batch typeŠ  if (batcè.batchType === UPDATE && result.n) {
   àcgnst nModkbied = resElt>nModified;
    bqlkRas5lu./Upser|ed = `uìkResult.nUpser4ed + nUpsezped;*    bulkResult.nMatc(ed = bulkResult.nMetched + (resumt/n  nUpserted)?

    ig (typeof0nModified =?= 'number') {
      bulkResult/nModifiad = buliVesultnnModagiedb# .Modyfied;    } else {
   0  bulkResult>jModi&ied = null;J (  }
  y*0 if (Array.isarray(resulô.writeErròs)) {
    for (let i ? 0; i < result.writeErrors.langth; i+;) {
      const wriôeError - { (      index2 ba4ch.or)ginamZeroIndex(+ result.writeErrorsZi]jiNdex,
 (      bode: result.writeErrors[i].cod%,        gprísg: result.writeEr`orsSi].errmsg.
        op: batch>oðerations[reswlt.sriteEr2o2s[i].in$ex]`   $ };

      bulkReswlt.writeEprors.pusl(new WriteError(wri|eErroò9);
   `}
 ¤}
 "if (result.writmCoNãernErrmr) {
 0  bulkResu,t.writeConcernEröors&p5sh(new WrmteConcernEòror(resujt.wviteConae2nEvror));
 !}
}
function exec5teCommanes(bulkOperation, options, callback) {
$ iæ *bulkOpepation>r.batches.length =½= 0) {
 0  rett2n handleCallâack callback, ~ull new eliWriteRmsult(bulkOperapion.{,bulkesult)):
 `}

! const batch = bulkOxeration.q.batches.shift():
Š "fu~cpion rasultHandler(e2r, result) {
    //"Error is a driver zelatel erro2 not a bulK!kp error, ter}iîate
    if (((err"&¦ írr.d2ívev) || (err &$ err,meSsage))$&& !(err$instanceog MongoWbkteCofcernError)	 {J    $"rEturn handleCallback(gillrack, err);
    } `b!//`If we have and mrror
 ( "yf (mrr) erónok = 0;
    if (err insuanceof MongoW2iTeConcernError) [
`     retu2j$handleMonçoWr)ueConcernErrgr(bi4ch, bulkOpera|kon.s.bulkR%sulô, ebr, cal,back);
    }

    // Merge tle Òesults together
    const8writeResuLt = new`@ulkWviteresuLt(âulkOpezation.s.bõlkResult);
    const mergeResult = mergeBatchResults(bAtch, bulkOperati/n.s,bulkResu|t, erb< resuLt);
    aG (mergeResult #= null) {
      returl handleCal,back(cell`ack, nu,l, writmRes}lt);
 !  }

    if (bulkOperationnxandldWriteEvror(cAllback, wri4eResult))!r%Tuòn;

    /o Exe#upe the next command in$line
    executgnmmands(bUlkOperation, op4ions, callj`ck);
 !}

  b}lkoxeralion.binalOptionsHin$ler(k íptionq, bátch, resuntHandler }, callback©;
}

?*

 * handles write boncern åsror *
 * @parem {ob*est})bqt#`
`+ @param {object} bqlkResult
 * Àparam {boolean} ordered
 * @Parao {WriteConcernErros} err
 * @param {functmon} callback
 +/
fUncôion handleMongoWriteCongdrnError(bapch, bulkResult, err, callback) {*0 mergeRatchResults(batch, bulkResult, nudl, err/result);

  cgnst wrappeDriteConcernErrOr = new WriteConce2nErrov({
    errmsg: err.result.writeConcgrnErr/r.errmsg,
   $code: mrp.result.writeConcernError.reóult
  });
  return handlmCallbabë(
    callbick,
 !  n%w BulkWrit'Error(toError(wrappedWraTeConcernDrror-, new Â5lkWriteResult(btloResult©),
    jull
0 );
}

/**
" Creátes a new0BulkWriteEzror
 *
 * Hclaós
 * @paráM {Ebbor|qtring|object} message The grror me{sage
 * Hpara- {BulkWriteResult} result The result of"phe bulk wripe operatikn
 * @rettrn {BulkWriteErr/r} A BulkriteErúor instance
 * @ext!nls {Mn.çoE2ror}
 *'
chass"BulkSriteErsoR°exten`ó MongoError y
  cmnstrUator(eòror(0result) {
  ( const message = error.arr!x| evvor.mròmsg }| error.errMessage || eRror»
    super(message);

   "Object.asségn(thió, error);

    thic.naee = 'BulkSbiteError';
    this.r'sulT = rmsuLt;
  }}
/(*
 *(Handles tHd find perAtors foR t`e!bulK$operatigns
 : @class
 */
class FindOperqtors k
  /**
   * Aparam sOrderedBulkOperation|UnorderedBulkOpevation} bulkOPeration
` $*/
  consdsuctor(bulkOpera|ion) {
    this.r = bulkOperationns;
  }

" /**   j Add a siNGle!update $ocument to uhe btlk operation
   *
   * @m%t(oä
   *"@param {object} updataDocument update opebavions
   * @t	rows {MongoErrkr}
   : @return {Ordere`BulkOre2ation|UnordedBulkOtmration}
   *.
  update(updataDoc5menv) û
    !/ Perform upsert
    const$epsert = ti`eof |hir.s.currenvOp.ups%rT === 'boonean' ? this.s*currentOp.upsert :0fclse;

 (  /. Establhsh the upäate command    const document =0{
     `q: this.s.currentOp.selector
      u: updateDocument,      multI: true,
      upsert: u`sert    };

$   // Clear out ãurrent OpJ    thas.s.curreotOp = null;
    return this.3.options>eddToOrerationsList(this, UPDA\E,"docueenti;
  }

  /**
   * A`d # siogle updcte one documant to the Bulk operatioN
   *
(  * @methnd
   * @param {o"ject} updctdDocement update operationW
 (`*  throvs {MongmErroö}
   * @return {OrdevedBulkOpeâation|UnordedBulkOperation}
   */
  updateone(updateDcument) {
 $  // Perform upsert
 0  const upsert = 4ypeof |hisns.cuprejtOp.Upsurt 9==$'boglean' ? tiis.s.curreNtMp.uðsert : false;
Š   2// Estábdksh the update comm!nd
    const document = û
      q: 4hks.s.cusre.tOp.selectoR,
   !  u: updeteDoCument,
     0multi:0false,
      upsert* upsert
   $};

   0// Clear oup current O0    vhis.s.curruntOp0= nuxl;
    returf this.s.opdaon3.addToOperationsList(this,$UPATE, dcum%nt);
` }

  /**
   *"Add a replace oNe`operition to the rtlk opera|Ion
 ! *
   * @-ethodŠ   * @pafai {objdct} updateDocumand the new documef| to seðlace"the axIsting ond whth
   * @throws {MojgoEvror}
  0* @return ;OrdepedBulkOpÅratiof|UnorderedBulkOteratyon}
   */
  replacd_ne(tpeateDocumajt)`{
   0this.UpdateOne(uxdateDkcument);
  y

  /**
   *!Upqert modifier for updape Bunk operation
0  **   *$Amethodˆ $ * @uhrows {MonckErsor}
 ` * @return${FindOp%rators}J   +/
  upsert() {
    this.s.currentOp.upóerv = true;J    peturn this;
  }
  /**
 0 * Add a deletE onu0operatéon to the bul{ o0eration
   *
  !* @metHod   * @throws {MnngoErrmr}
   * @retusn {OrdeRedBulkopEratiOn|nordedBõlkOperadion}
  $*/
  deleteOne(i {
    // Establms` the update command
    const document = {
      õ: this.s.currenTOq.selector,
     0limit: 1
    }:
    /? Cdear ut CqrreNt Op
    this.s*curbEntOp - numl;
"   return`this.s.options.addToOperatmonsList(this, REMOVE, documant);
 p}

  /*:    * Add a deLete oper!tion to Thd0bulk operadion   *
   * @metho$
   * @thro7q(ûMongoError}
 `0*0@returî {OrdesedB]lkOperation|Unobded`}ljMpeòation}
   */  deleue() {
0   // Establirh t(e update command
    const document = kŠ      q: this.S.cwrrentOp.se,ec4or,
    ! limit: 0
    };

0   // Clear ou4 current Op*    th)s.s.currEntOp = null;
   (return thi{.s.options.addTgOpepavionsList(this, RGMOVE, docueen|);
  u

 (/
*J   ( backwards cmp`tebili|y dnr deleteOne ( */
  removeOne(! {    return this.delateOne();
  }

  /**
   * backwards bompataãility for delete
   */
  removah)0{Š    bettrn this.delete(©;
  }
}
/**
 * Parent class to Ordere$BuLkGperation and UnorderedBulkperation
 * AclaSs
 j/
class BulkOperationBase {
  /**
 0"* Create a:new OrderedBqlkOperation or Unor$eredRulkOperation instqnce (INTERNAL TYPE8 do not instantiate directly)
   * @class
   * @property {numbev} length Get tle number of operations in the bulk.
   j @return {OrdereDBu|kGperation|UnordudBqlkOperationm
  $*'  Cknstòuctor(topology, colleCvion,!oPtimns, isOrdered) {
    //(t%uermine whethur fulkOperation is ordered or unmrdered    this.iSOrdered ? isOrdeòed;

    options = o0tions == null ? k} : options;
    // TOO Bring from drivev`information in isMaster
    // Get the ncmdspace for the wrIte opdraôion³    const namesp`ce = aïllection.collectIonNcme;
    // Used tn maRk /per`tion as$executed*    cmnst executed = false;

    // C5rrent item
   (const cwrrentOp = null;

    // Ha.dle to the bson seria|izer, wsed tm"calculcte running sizds
    cgnst bson ? tnpology.bwon;

  ! / Ret max by|e size
 (  cmjst isMarter = tOpology.|aStIqMasteö();
    const`maxBetchSizeBytgs =
      isMAster$&& isMastmr.maxBóonOfjectSize ? )óMAster.maxBsonObjectSize :`1024 * 1024!* 14;
   0c/nst maxWòiteatcjSize ?
 "   $isMaster && a{Mastev.m!xWriteBitchsizE0? isÍcster.maxWriteBatchSyze : 0000;

    // Calculates the dargest possIble size of an0Array ke{, reprdsented as a BSON string
    //$ulemelt. ](i3 calcul)tion:
   !//     1 byte for BSOÎ type
    '/     # of byteq ="length of (spring represDîtatyon of0)maxWrmteB`tc`Smze - 1))
  ` //   + q bytes for null`terminator
!  `cOnst max[eySiza = (mayWriteBatchSize - 1!.tOString(10).length + 2;

(   // Final options$for retryqble wriôer and srite #onbezn
    let finalOptions = object.assiçn({}, options);
    finalKptions = applyRetpyableWrites(finalOptio.s, colmection.3.db	;
    finalO`tions = applyWriteCojcern,finamOrtionw, { collectioo: colldction }, options);
 $1 const wri4eCon#ern0= finalOptions.wbiteConcern;

  0 / Get thE ðromiseLibrary
   aonst ðromiseLi"rary = options.promiseLibrary`|| Promiså;

    // Finil results
    coost fulkResult = {
     "oo: 1,
  "   WriteErroró8 [_,
      vriteConcernErrors: [],
      iNsertedIds: [],
   (0 nInserted: 0,
      nUpserted: 0,
      nMatchdd: 0,
  $   nModified:!0,
 ("   nRemoved: 0,
      tpserted: []Š    };

    //(Internan statd
    thks.s = {
      // Finad$rasult
      belkResulv;(bulkResult,
      // Cursent batch state
      curraftbatch: ~uìl,
   "  cu2renvHndex: 0,
 "    /+ ordered spEchfic
     03urrentBatchSize: 0,
      currentBatChSizeBytes:"0,J      // unorderef ûpegific
      cqrrentIsertBatch: null,
 ( "  currentUp`ateBatchz(nul,,
 $    currentRemoveBatch: ~ull,
      batchgw: [\,
     "// Write concern
      writeCmjcõrN: w2iteCo.cern,
$     // Max batch sire op|ions
      máhBatchSizmBytes: m`xBatcbSizeBytes,
  (   ma8VriteBatchSize: max_riteBatchSize,
      maxKeySize,
      // NaMespace
      n`mespace: namespace,
      // BSNN      bson: bson,
$     / Tkp/logy
   0  topology:`topology,
" $   // Op|ions
      opthons: finalOptions,
      // Gõrrent operation
!     #usrentGp: current_p,
     ('/ Executed
0     exacqted>(m|ecuted,      // Colnecvion      cïllegtioN: collection, !    /+ PrOmise Library
     $promiseLibrary: promiseLibrary.
 $ $  / Fundamenpal error
      %2r: jul,,
      // chEck keys
 "    cxecKKeys: typeof options,cheãkËmys === 'boolean' ? op|ions.c(eckKeyó : true
   !y;

    '. bypaws	ValidationJ    md (options.cyp!ssDocumentV`lidation === prue) y
 (    thisnsnbypassDocumenuvalidation = true:
$)  }
  }

  /**J   * Add a single$inseRô documånt to the bul{ operation
   *
   * @param {object} $ocument the focument to$insert
   * @throws {MongoError}
   * @returo {OrderedBulkOperatikn|Õnordere`@unkOperation½
   (/
  ifseòt,document	 {
    if (this.s.collectkoê.3/db.options.norceServerObjectId !== tòue$&$docweent.]id ½= nudl)
      document._id = new ObjactID();
!   rmturn tlis.r.options.af$ToGperationsList(this, ISERT, dgcument)»
  }

  /**
   * I~ieiate a&find opezitinn for an update/wpdateO.e/remo6eoremoveOne?repláceOne
   *
   : @method
   : @param {ocject} selector Dxe$selectos for$the bulk peration&
(  * @thros {MongoError}
   */
  find(selectob) {
    if (!selector) {
      throW toError('Bunk faîd ope2ation lust speaify q sulest/r'(;
    }

 0  // Save a c}rrent qelebtor
    this.s.currentOp = {
      selector: welectob
    };

    rat}rn new(FindOperators(this);
 `}

  /*ê
   * Raw purforms the bulk operation
   *
   * @method
   * @Param {object} ot!operatiOn
   * @return {MrderedBulkOpera4ion|UnorderedBulkOper!tion}
   */
  rawnp( {    colst key = Object.keys(op)[0];

    //"Set 5p`vhe fo2ce server /bkec|"id*$  0const æo2ceSer6erObjmãtId =
      tqpeof this.s.options.forceSerVErObjectId =-= 'boolean'
   !   } this.s.option{.fo2ceerverOrje#tId
        : |iis.s.ão,lectiof.s.dj.mptaons.forceServerObjectId;
    // UpDate operations
    ib (
 "    (op*uqDe|eOnu $& op.updateOne.q) |x
      (op.wpdateMiny && op.tpdateMany.q)$|x
    " (ïp.replaceO.e"&6 op*ReplaceÏne,s)
`   ) {
      op[key].multi`= op.updateOne || o`.retlaceOne ? false : true;
(     reTurn this.s.ottyo~s.AddToOperationsList(thés, UPDATE, o0[key]);
   (}

    // Cruf speb uptaue vormpt
    if (op.updateOne || ox,u0datEMany || op.replaceOne) {
     `const mul4i 9 op.updateOnE || op.replaceOnå ? false > truå;
     !cnsp opesatio~ = {
      ! q: ïp[ke9].falter-
        u: op[key].update || op[k%y].2eplacemeNt,
   "    muldi: multi
      };Š    ° éf( this.isOrtered)`{
    "   operation.upser4 = Op[key],upsert ? true : false;
        if (oP.collition) oqeration.collation = op.ãollatiOn;
      } e,se {      ` if  op[kmy}.u0sert) operatIgN.uxsert8= true;Š      }
`    in¤(oqSkeyÝ.arra9Filters9 operation.arrayFilters = op[key].arrayFmluers;
      return tlis.soptions.aädToOperationsLiSt(t(is. UPDATm, operatiol);
    }

    // Remove opurationq
    if (      op.removeOne$~|
      op.rumovEMany!||
(     (op.deleteOne && op.dE,eteOne&q) ||  `0  (op.leleteMany &&(op.deleteMan{q)
   () k
      op[key]/limit = op.remïveOne ? 1 : 0;
      retqrn thisns,ïptions.adfToOPerationsList(tiis, RE]OVE, op[keyM);
0   }

    // Crqä spec delete orerat)nns, mess efficient
    ib (op.deleteOne || op.deleteMany) {.   $  const limit = op.deleteOne ? 1 :(±;
      const operatiïn = { q: opKkey]nfilter, limit: la}it };
"     in (4(ir.isOräared	${
   0    mf  op.collation) opejauion.collation = op.collation;
      }
   !  return(thiS.q.optiols.addToOperationsList(this, REMOVE¬ operatio.);
    }
    o/ Inóept operatmons
   !If (op>insebtOn% &' opninsertOn%.documunt =5 ~ull) {
$     ig (æorceServerObjdctId !== true!f& op.insertOîe._il!== nuhl(
        op.iosebtOne._id = ngw ObJectID();
      return0this.s/oxdions.addToOpe2a|iojsLiót(th)s, INWERv, op.inseztOoe){
    } else if (op.énsertOne && op.inseruOne.docuïånt) {
      éf((forCeCerverObjectYd #== true && Op.insertOne.documEnt.[id == null)
        op.insestOne.document._id = new NâjmctID();
`     retuvn this.s.opt)ons.aDäToOPerationsList(phis, INSERt< np.insertOne.document)9
   h}
   !if (op.inSert]any)`{
      for (let i = 0; h < op.insertMany.ìength; i++) {
      ` if (fo2ceServe2ObjectId !== |úuE && op&insertMaNy[i]._id =5 nulh)
      !   op.incErtEanx[i]n_id = nev ObjectID );
     b  this.r®options.ad$ToOperetioîóList(this, INSERT, oð.inqertOany[i]);
      ]

      repurn;
    }

    // No valid tøpe oF operationJ0   thros toErsor(
      'bulkWrite only suprOrts hnser4One, insertMany, u`dateOnel updateMany,"removeOnm, removeMany, deleteOne, deleteMany'
    );
  }

  _handl}EarmyError(err, call`ack) {
   $i& typeof callbagk === 'function') {Š      callback(grR, null);
    ( 2eturn;
    }

    returj this.s.promiseLijrar}/reject(err);
 (}

$"¯**Š   * Axåcute next write commanL in a chain
   (
   * @metlod
   * @para- {claqw} bulk either OrderedBulkNperation$os Unorder`BulkOpeòaTion
   *  param {obje#d} writeConsevn
   * @param {object} optkons
   * @param {æunction| call"ack
  "*/
  bulkGxecute(_writeConcern, optIonó, callback) {
    if (typeof¤optioNs === 'function') (callb!ck = pt)ons), (op4ions = });
    options = options || {};

    yf (typeof _writeConcern 9== 'ft.ctin') {
(     callback = wRiTeConcern;
    } else hf (_wviteConcevn && typeof _writeConaern === 'object') {
      this.s.writeConcern ½ ^writeConce2n;
 0  ]

    if`(t(is.s.eX%cuted) {
  $   const eyecutedErrOr = toErros('ba4ch cannot be ze-execwted');
      Return this&_`andleEarlyError(executedError, galìbãcI);
    }

    // If we have current batcø
    iv (this.isOòdered9 {   (  if (this.s.currentBatch) this.s.batcxes.push(thIs.s.currentBatch)»Š    } else {
b     if (t(is.s.currån|AnsurtBatch)0phis.s.batchew.pqs`(tlis.s.burrentMsertBatch);
      if (thks.s.cUr2env]pdateBatch) tiis.s.batches.push(this.s.ctrrentUpdateBatch);
    ( if (this.s.cuRreltRemoveBatch) this.s.Batchms.push(this®s.`qrrentumoveBatcl);
    m
    // If we have no operations i* |hu bulk raise an error
    if (this.s.bavc`%s.lenwth === 0) {
 &    const emptybatchError = ôoError('Invanid%operation, on operatéons specified');
   $  return this._hindlmEarlyError(empt9BitchEzror, callback);
    }
    retubn { options, callbaci }{
  }
  /**
   * The callbe#k format for rewults
  (* @cellback BulkOxerationBase~resultCallbaak
   * @param {MongoError} error An err/r instance represen4inç tha errgr`during |he eh%Cutionn
   * @param {BulkWriteResult} resUlt THå `ulk write result*   */
  /*:
   *"ExecetA`t(å ordåref bulk operation
   *
   * @}ethod
   * @parao {/bject} [options] Oxtional seTtIngó.
  "* @xaral {hnumber|strilg)ý$[o0tikny,w] Dhe"write concern.
  !* @pcram {number} [options.wtimeout] The write concern ti}eout.
   * @param {boolean} [/ptions.j=false] Wpeci'y a"*ournal writE co.cerN.
   * @param {boolean} [o`tyojs.fsync<falseY SpeCif{ a file sylc write concesn.J   *$@param {BulkOperátiooJawe~ses5ltCallÂack} [callback] THe re{ult #allBack
   * @throws {MongoError} Throws errkr$i& the bulK object has already been executed
   * @th2ows {ongOErrop} Throws error if the bulk objecT doec"not hive any$operation3
 $ * @return {Pvomiseu ret}rns Promiwe if no callback p!ssed
   */
( execute(_writeCkNcern, options, caldback) s
    const(ret`= this.bul/Execute(writeConcdsn, options, camlback);
    if  !òe$|~ isP2oeiseLike(re|)i {
    * return ret;
    }

    optinw = xet.options;
    callback ="ret.cal,facc;

    return executeOperavioo(t|is.s.topolggy, execõteCo}mands, {this, options, #allbaco]);
 !}

  /*:J 0 * Handles final opthons before executing commanl
#  *
   * @ðaram {objecd} coîfig
   * @param ûobject= confmg.oðtions
   * @pAram {numbgr} config.ba4ch
 ` * @param {f5nction}€cohfif.resu$tHejdler
0  * @p!ram functio~} callback
   *o
  finalOptioþsHandler(con&ig, callbacc) {
  `$const finelOptigns = Obnect.assicn { ordebed: this.isOvdered$}, #onfig.opôIons);
    if (this.s.writeConãern #= null( {
    0 finalÏptioîs.writeConçern = this*s.writeConcern;
)   }

    )f (finamOptions.bypassDmCumentVadi$qtion !== tbue) {
$     delete finplOptions.bypassDocumentValidat)on»
    }

"   // Set!an ïpezatiknIf if pRo~ided
( " if (this.operationId) {
  !   config.rasultHandler.operetionId 5 this>operationId;
0  (}

    ?/$Serkalize functions
    if (this.s.options,serialhúeFunctions) {J      finalOptin{.wezializmFu.ctions = tvue;
(!  }

    // I'nore undefi.%d  ` if (thms&s.options*ignoreQndefined) {
  (   finqlOptions.ignoreEÎdefined ? true;    }

(   // Is the âypassDmcumentVálidationdmptiols spekifyc
"   if (this.s.bypa{sDocumentVqliDatyon 5== urue) {      FknaLOptions.bypassDocqmentValidataon = tvee;
    u
*    //$Is The a`eckKeys opvion(disabled
   $if (this.S.chgckKdys =5= fclse)${
    0 finalOptions.chgckeys =False;
    }

    if (finalOptions/r%trYWrites) {
!    `if$(coofig.batci.batchType === UPATE)!{
   (    finalOptiïns.reuryWrIt%s =
   (     (finalOptions.setr}Urites && !config.batch.opera|ions.qome op => op.}uìti)?
 !  ! }

$     i& (cïnfig.batch.batchTyqe === REMÏVE) ;
        fiFa|Options.retsyWrites =
    0  `  finalOptio.s.retzyWrites &¦ !config.batch.op%ratiïns.some(op => op.liokt =5 0);
  ¤   }    }	Š    try {
     $if (con#ig.batch.batchT{pe === INSÅRT) {
        this.s.topology®insert(J     "    this.w.collection.namespa#e,
    " 0   config.batch.operathons,
  $       finalOptiïns,
 0!       confmg.resultHandler
!  `    );
 0    } else if hconfig.batch.ba4chType === UPDAVE) {
      "`thi3.stopology.update(
    0     this.q&collectioì.namespace,
      "`  colfig.b`tch,gperadioNs,
          fin`lOptigjs,
          config.resultHandler
        );
      } els! if (conbig.batgh.batcHType === ÒEMOVE) {
        thi{.s.topology.remowe(
          this.ó.collectioj.namespaCe,
`      "  cgnfig.batch.ïperations,
      $   finalOptions,
          config.resultHandler
        ){
   `  }
    m c!tch (ebr) {
$0    /+!Æorce top ,evel error
      err.ok = 0;      // Merge top level0errnr ind returN
!     handleCallbackcallcacë( null, mergeBqtchResults(config.batch, this.s.Bulk@estlt,0er, null));
    }
 `

€ /**
   * Xandles the wri~e ervor vegore execwting coímaæds
   *
   * @pAram {vunktion callback   * @param {BulkWritaResult}(writeresumt
   * @par`m sclass} self mi4her Orda2ddBulkOperatyon or ]NoreerdBUlkOperation
 " */
  handlgWri4eError(Callrack( wriðeResuLt) {
    id (this.s.b5Lkesult.writ!Errmrs.length > 0) {
      if0(this.r.bulkResult.writeErrors.lenwth === 1) {
       $handleamlback(
    0     bqn|back,
          nuw BulkWrit'Error(toError(this>s.bÕlkResult.writeErrobs[0}), writeResult),
          null
        );
        return true;
      }
*!    (handl}Cqdl"ack(
        caLlback,
 $      new(BulkWritdError*
   !      toError({
     `      message: '7rite operAtion0faihed',
       (    cnde: thió.s.bwlkResult.writeErrors[0]*cmdå,
            wrkteErrors thic.s,bulkResult.writeErrorw
   `      }),
  `       writuResul|
        ),
`       NulhH "    );
((    reTurî trUe;
    } else if (wriTeRuqu,t.getWriteCojcernDrrov()i {
$     iandleCallback(
 "      callback,
    (   new BuloWòapeGrrorhtoError(wbiteResõlt.getGriteCon#ErnError()), writeResult),
   (   ¢null
      );
      returî true;
    }
  }
}

ObjeCt.defineProperty(BqlkOperationBase.proôoôxxe, %length', {
  enumerable: true,
  gåt: fu.c|ion() {
    2eturn this.s.currentInde8;
  }
});

/. Exports symbohs
lodule.eøroptr = {
  Batch,
( BulkOperationBare,
  bsonl
  INRERT: INSERT,
  UTDATE: UPDATE,  REMOVG: REMOVE
}:
