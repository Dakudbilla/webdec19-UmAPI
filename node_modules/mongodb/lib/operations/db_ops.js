'use strict';

const applyWriteConcern = require('../utils').applyWriteConcern;
const Code = require('mongodb-core').BSON.Code;
const resolveReadPreference = require('../utils').resolveReadPreference;
const crypto = require('crypto');
const debugOptions = require('../utils').debugOptions;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('mongodb-core').MongoError;
const parseIndexOptions = require('../utils').parseIndexOptions;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;
const CONSTANTS = require('../constants');

const count = require('./collection_ops').count;
const findOne = require('./collection_ops').findOne;
const remove = require('./collection_ops').remove;
const updateOne = require('./collection_ops').updateOne;

let collection;
function loadCollection() {
  if (!collection) {
    collection = require('../collection');
  }
  return collection;
}
let db;
function loadDb() {
  if (!db) {
    db = require('../db');
  }
  return db;
}

const debugFields = [
  'authSource',
  'w',
  'wtimeout',
  'j',
  'native_parser',
  'forceServerObjectId',
  'serializeFunctions',
  'raw',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bufferMaxEntries',
  'numberOfRetries',
  'retryMiliSeconds',
  'readPreference',
  'pkFactory',
  'parentDb',
  'promiseLibrary',
  'noListener'
];

// Filter out any write concern options
const illegalCommandFields = [
  'w',
  'wtimeout',
  'j',
  'fsync',
  'autoIndexId',
  'strict',
  'serializeFunctions',
  'pkFactory',
  'raw',
  'readPreference',
  'session'
];

/**
 * Add a user to the database.
 * @method
 * @param {Db} db The Db instance on which to add a user.
 * @param {string} username The username.
 * @param {string} password The password.
 * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function addUser(db, username, password, options, callback) {
  let Db = loadDb();

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Attempt to execute auth command
  executeAuthCreateUserCommand(db, username, password, options, (err, r) => {
    // We need to perform the backward compatible insert operation
    if (err && err.code === -5000) {
      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);

      // Use node md5 generator
      const md5 = crypto.createHash('md5');
      // Generate keys used for authentication
      md5.update(username + ':mongo:' + password);
      const userPassword = md5.digest('hex');

      // If we have another db set
      const dbToUse = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;

      // Fetch a user collection
      const collection = dbToUse.collection(CONSTANTS.SYSTEM_USER_COLLECTION);

      // Check if we are inserting the first user
      count(collection, {}, finalOptions, (err, count) => {
        // We got an error (f.ex not authorized)
        if (err != null) return handleCallback(callback, err, null);
        // Check if the user exists and update i
        const findOptions = Object.assign({ projection: { dbName: 1 } }, finalOptions);
        collection.find({ user: username }, findOptions).toArray(err => {
          // We got an error (f.ex not authorized)
          if (err != null) return handleCallback(callback, err, null);
          // Add command keys
          finalOptions.upsert = true;

          // We have a user, let's update the password or upsert if not
          updateOne(
            collection,
            { user: username },
            { $set: { user: username, pwd: userPassword } },
            finalOptions,
            err => {
              if (count === 0 && err)
                return handleCallback(callback, null, [{ user: username, pwd: userPassword }]);
              if (err) return handleCallback(callback, err, null);
              handleCallback(callback, null, [{ user: username, pwd: userPassword }]);
            }
          );
        });
      });

      return;
    }

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, r);
  });
}

/**
 * Fetch all collections for the current db.
 *
 * @method
 * @param {Db} db The Db instance on which to fetch collections.
 * @param {object} [options] Optional settings. See Db.prototype.collections for a list of options.
 * @param {Db~collectionsResultCallback} [callback] The results callback
 */
function collections(db, options, callback) {
  let Collection = loadCollection();

  options = Object.assign({}, options, { nameOnly: true });
  // Let's get the collection names
  db.listCollections({}, options).toArray((err, documents) => {
    if (err != null) return handleCallback(callback, err, null);
    // Filter collections removing any illegal ones
    documents = documents.filter(doc => {
      return doc.name.indexOf('$') === -1;
    });

    // Return the collection objects
    handleCallback(
      callback,
      null,
      documents.map(d => {
        return new Collection(
          db,
          db.s.topology,
          db.s.databaseName,
          d.name,
          db.s.pkFactory,
          db.s.options
        );
      })
    );
  });
}

/**
 * Create a new collection on a server with the specified options. Use this to create capped collections.
 * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
 *
 * @method
 * @param {Db} db The Db instance on which to create the collection.
 * @param {string} name The collection name to create.
 * @param {object} [options] Optional settings. See Db.prototype.createCollection for a list of options.
 * @param {Db~collectionResultCallback} [callback] The results callback
 */
function createCollection(db, name, options, callback) {
  let Collection = loadCollection();

  // Get the write concern options
  const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed()) {
    return callback(new MongoError('topology was destroyed'));
  }

  const listCollectionOptions = Object.assign({}, finalOptions, { nameOnly: true });

  // Check if we have the name
  db
    .listCollections({ name }, listCollectionOptions)
    .setReadPreference(ReadPreference.PRIMARY)
    .toArray((err, collections) => {
      if (err != null) return handleCallback(callback, err, null);
      if (collections.length > 0 && finalOptions.strict) {
        return handleCallback(
          callback,
          MongoError.create({
            message: `Collection ${name} already exists. Currently in strict mode.`,
            driver: true
          }),
          null
        );
      } else if (collections.length > 0) {
        try {
          return handleCallback(
            callback,
            null,
            new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
          );
        } catch (err) {
          return handleCallback(callback, err);
        }
      }

      // Create collection command
      const cmd = { create: name };

      // Decorate command with writeConcern if supported
      applyWriteConcern(cmd, { db }, options);

      // Add all optional parameters
      for (let n in options) {
        if (
          options[n] != null &&
          typeof options[n] !== 'function' &&
          illegalCommandFields.indexOf(n) === -1
        ) {
          cmd[n] = options[n];
        }
      }

      // Force a primary read Preference
      finalOptions.readPreference = ReadPreference.PRIMARY;
      // Execute command
      executeCommand(db, cmd, finalOptions, err => {
        if (err) return handleCallback(callback, err);

        try {
          return handleCallback(
            callback,
            null,
            new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
          );
        } catch (err) {
          return handleCallback(callback, err);
        }
      });
    });
}

/**
 * Creates an index on the db and collection.
 * @method
 * @param {Db} db The Db instance on which to create an index.
 * @param {string} name Name of the collection to create the index on.
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function createIndex(db, name, fieldOrSpec, options, callback) {
  // Get the write concern options
  let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);
  finalOptions = applyWriteConcern(finalOptions, { db }, options);

  // Ensure we have a callback
  if (finalOptions.writeConcern && typeof callback !== 'function') {
    throw MongoError.create({
      message: 'Cannot use a writeConcern without a provided callback',
      driver: true
    });
  }

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Attempt to run using createIndexes command
  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
    if (err == null) return handleCallback(callback, err, result);

    /**
     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:
     * 67 = 'CannotCreateIndex' (malformed index options)
     * 85 = 'IndexOptionsConflict' (index already exists with different options)
     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)
     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)
     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)
     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)
     */
    if (
      err.code === 67 ||
      err.code === 11000 ||
      err.code === 85 ||
      err.code === 86 ||
      err.code === 11600 ||
      err.code === 197
    ) {
      return handleCallback(callback, err, result);
    }

    // Create command
    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
    // Set no key checking
    finalOptions.checkKeys = false;
    // Insert document
    db.s.topology.insert(
      `${db.s.databaseName}.${CONSTANTS.SYSTEM_INDEX_COLLECTION}`,
      doc,
      finalOptions,
      (err, result) => {
        if (callback == null) return;
        if (err) return handleCallback(callback, err);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.writeErrors)
          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      }
    );
  });
}

// Add listeners to topology
function createListener(db, e, object) {
  function listener(err) {
    if (object.listeners(e).length > 0) {
      object.emit(e, err, db);

      // Emit on all associated db's if available
      for (let i = 0; i < db.s.children.length; i++) {
        db.s.children[i].emit(e, err, db.s.children[i]);
      }
    }
  }
  return listener;
}

/**
 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param {Db} db The Db instance on which to drop the collection.
 * @param {string} name Name of collection to drop
 * @param {Object} [options] Optional settings. See Db.prototype.dropCollection for a list of options.
 * @param {Db~resultCallback} [callback] The results callback
 */
function dropCollection(db, name, options, callback) {
  executeCommand(db, name, options, (err, result) => {
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }

    if (err) return handleCallback(callback, err);
    if (result.ok) return handleCallback(callback, null, true);
    handleCallback(callback, null, false);
  });
}

/**
 * Drop a database, removing it permanently from the server.
 *
 * @method
 * @param {Db} db The Db instance to drop.
 * @param {Object} cmd The command document.
 * @param {Object} [options] Optional settings. See Db.prototype.dropDatabase for a list of options.
 * @param {Db~resultCallback} [callback] The results callback
 */
function dropDatabase(db, cmd, options, callback) {
  executeCommand(db, cmd, options, (err, result) => {
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }

    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  });
}

/**
 * Ensures that an index exists. If it does not, creates it.
 *
 * @method
 * @param {Db} db The Db instance on which to ensure the index.
 * @param {string} name The index name
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function ensureIndex(db, name, fieldOrSpec, options, callback) {
  // Get the write concern options
  const finalOptions = applyWriteConcern({}, { db }, options);
  // Create command
  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
  const index_name = selector.name;

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // Merge primary readPreference
  finalOptions.readPreference = ReadPreference.PRIMARY;

  // Check if the index already exists
  indexInformation(db, name, finalOptions, (err, indexInformation) => {
    if (err != null && err.code !== 26) return handleCallback(callback, err, null);
    // If the index does not exist, create it
    if (indexInformation == null || !indexInformation[index_name]) {
      createIndex(db, name, fieldOrSpec, options, callback);
    } else {
      if (typeof callback === 'function') return handleCallback(callback, null, index_name);
    }
  });
}

/**
 * Evaluate JavaScript on the server
 *
 * @method
 * @param {Db} db The Db instance.
 * @param {Code} code JavaScript to execute on server.
 * @param {(object|array)} parameters The parameters for the call.
 * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.
 * @param {Db~resultCallback} [callback] The results callback
 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
 */
function evaluate(db, code, parameters, options, callback) {
  let finalCode = code;
  let finalParameters = [];

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));

  // If not a code object translate to one
  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);
  // Ensure the parameters are correct
  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
    finalParameters = [parameters];
  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
    finalParameters = parameters;
  }

  // Create execution selector
  let cmd = { $eval: finalCode, args: finalParameters };
  // Check if the nolock parameter is passed in
  if (options['nolock']) {
    cmd['nolock'] = options['nolock'];
  }

  // Set primary read preference
  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);

  // Execute the command
  executeCommand(db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err, null);
    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);
    if (result)
      return handleCallback(
        callback,
        MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),
        null
      );
    handleCallback(callback, err, result);
  });
}

/**
 * Execute a command
 *
 * @method
 * @param {Db} db The Db instance on which to execute the command.
 * @param {object} command The command hash
 * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function executeCommand(db, command, options, callback) {
  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Get the db name we are executing against
  const dbName = options.dbName || options.authdb || db.s.databaseName;

  // Convert the readPreference if its not a write
  options.readPreference = resolveReadPreference(options, { db, default: ReadPreference.primary });

  // Debug information
  if (db.s.logger.isDebug())
    db.s.logger.debug(
      `executing command ${JSON.stringify(
        command
      )} against ${dbName}.$cmd with options [${JSON.stringify(
        debugOptions(debugFields, options)
      )}]`
    );

  // Execute command
  db.s.topology.command(`${dbName}.$cmd`, command, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    if (options.full) return handleCallback(callback, null, result);
    handleCallback(callback, null, result.result);
  });
}

/**
 * Runs a command on the database as admin.
 *
 * @method
 * @param {Db} db The Db instance on which to execute the command.
 * @param {object} command The command hash
 * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function executeDbAdminCommand(db, command, options, callback) {
  db.s.topology.command('admin.$cmd', command, options, (err, result) => {
    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }

    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.result);
  });
}

/**
 * Retrieves this collections index info.
 *
 * @method
 * @param {Db} db The Db instance on which to retrieve the index info.
 * @param {string} name The name of the collection.
 * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function indexInformation(db, name, options, callback) {
  // If we specified full information
  const full = options['full'] == null ? false : options['full'];

  // Did the user destroy the topology
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  // Process all the results from the index command and collection
  function processResults(indexes) {
    // Contains all the information
    let info = {};
    // Process all the indexes
    for (let i = 0; i < indexes.length; i++) {
      const index = indexes[i];
      // Let's unpack the object
      info[index.name] = [];
      for (let name in index.key) {
        info[index.name].push([name, index.key[name]]);
      }
    }

    return info;
  }

  // Get the list of indexes of the specified collection
  db
    .collection(name)
    .listIndexes(options)
    .toArray((err, indexes) => {
      if (err) return callback(toError(err));
      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);
      if (full) return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
}

// Transformation methods for cursor results
function listCollectionsTransforms(databaseName) {
  const matching = `${databaseName}.`;

  return {
    doc: doc => {
      const index = doc.name.indexOf(matching);
      // Remove database name if available
      if (doc.name && index === 0) {
        doc.name = doc.name.substr(index + matching.length);
      }

      return doc;
    }
  };
}

/**
 * Retrieve the current profiling information for MongoDB
 *
 * @method
 * @param {Db} db The Db instance on which to retrieve the profiling info.
 * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback.
 * @deprecated Query the system.profile collection directly.
 */
function profilingInfo(db, options, callback) {
  try {
    db
      .collection('system.profile')
      .find({}, options)
      .toArray(callback);
  } catch (err) {
    return callback(err, null);
  }
}

/**
 * Retrieve the current profiling level for MongoDB
 *
 * @method
 * @param {Db} db The Db instance on which to retrieve the profiling level.
 * @param {Object} [options] Optional settings. See Db.prototype.profilingLevel for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function profilingLevel(db, options, callback) {
  executeCommand(db, { profile: -1 }, options, (err, doc) => {
    if (err == null && doc.ok === 1) {
      const was = doc.was;
      if (was === 0) return callback(null, 'off');
      if (was === 1) return callback(null, 'slow_only');
      if (was === 2) return callback(null, 'all');
      return callback(new Error('Error: illegal profiling level value ' + was), null);
    } else {
      err != null ? callback(err, null) : callback(new Error('Error with profile command'), null);
    }
  });
}

/**
 * Remove a user from a database
 *
 * @method
 * @param {Db} db The Db instance on which to remove the user.
 * @param {string} username The username.
 * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback
 */
function removeUser(db, username, options, callback) {
  let Db = loadDb();

  // Attempt to execute command
  executeAuthRemoveUserCommand(db, username, options, (err, result) => {
    if (err && err.code === -5000) {
      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);
      // If we have another db set
      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;

      // Fetch a user collection
      const collection = db.collection(CONSTANTS.SYSTEM_USER_COLLECTION);

      // Locate the user
      findOne(collection, { user: username }, finalOptions, (err, user) => {
        if (user == null) return handleCallback(callback, err, false);
        remove(collection, { user: username }, finalOptions, err => {
          handleCallback(callback, err, true);
        });
      });

      return;
    }

    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, result);
  });
}

/**
 * Set the current profiling level of MongoDB
 *
 * @method
 * @param {Db} db The Db instance on which to execute the command.
 * @param {string} level The new profiling level (off, slow_only, all).
 * @param {Object} [options] Optional settings. See Db.prototype.setProfilingLevel for a list of options.
 * @param {Db~resultCallback} [callback] The command result callback.
 */
function setProfilingLevel(db, level, options, callback) {
  const command = {};
  let profile = 0;

  if (level === 'off') {
    profile = 0;
  } else if (level === 'slow_only') {
    profile = 1;
  } else if (level === 'all') {
    profile = 2;
  } else {
    return callback(new Error('Error: illegal profiling level value ' + level));
  }

  // Set up the profile number
  command['profile'] = profile;

  executeCommand(db, command, options, (err, doc) => {
    if (err == null && doc.ok === 1) return callback(null, level);
    return err != null
      ? callback(err, null)
      : callback(new Error('Error with profile command'), null);
  });
}

// Validate the database name
function validateDatabaseName(databaseName) {
  if (typeof databaseName !== 'string')
    throw MongoError.create({ message: 'database name must be a string', driver: true });
  if (databaseName.length === 0)
    thrkw MongoError.crUate({ message 'databasm name cannot be tHe empty string'( eriöer: true });
  if (databaseName === '$exterîal') return;

  conrt`invahidAhabs ¼ [' %, '',('$', '/',!'\\']9
  for (let k } 2; i < invalidCiars.lmngv`; i++) [
  ` iv (datqbaseName.indeyOæ(invalidChars[i]) !== -1)
      throw`MojgoError.create8{
        message: "database names cannot contain dhe kharactdr '" + invaLidChars[i] + "'",
       driver: tree
    0 });
  }
}

/**
 * Creave the bomoand object for Db.prototyre.createMndex.
 *
 * @param {Db} e` Thf Db instance n wjich 4o$cveate the cgmmand.
 * @parae {str)ng} nime Name of the kollection to sveate thd index$n.
 * @param {)string|object)} FieldOrSpec Def)ne3 the index.
 * @paRam {Object} [opviïns] Opti/.al settyngs. See Db.prototyxe.createIodax for a list nf options.
 * @rEturn {Obnect} The!ins%rt comman`$orject.
 */
function sreateCzeateI~texCommand(db, naMe,!fie,dOrSpeb, optiojs)0{
  const ildexParaieters = parseIndexOptions(FieldOrSpe);
  bonsð fieldash = indaxParaleters.fiatdHash;

  ?/`Fenesate the indeX namuJ0 const indexNcme = typeof options>name === 'string' ? op4ionc>name 2¡inpexParametErs.name;
  const selector = y
    ns: db.databaseLame + '.' + name,
    keyz faeläHash,
    naiu: yndexName
  };

 (// Ensure w% hqve a corr%ct fin!lUnique
  const!finalUnique =`optiojs == null || 'object' === typeof options"? false°: options;
  -/ Set up orvhons
  optionS$? options == null || typgof options =}= 'bonle!n' ? {} 8 options;

! // Add all the`optionq
  con3t keysToOmit"} ObjEct.keys(selector)3
  for (let optmonJale in optmons) {
    if (key{ToO-it.infexOf(optaonName) === -1) 3
      selector[optionName](= options[optionNáme];
    }Š  }
  if (selector[cnique'] == null) selectorÛ'unique%} = æinanUniq}e;

  //0Bemove any write concern operations
  const removeKeys = ['w', gwtimeout%, 'j', 'fsync',$'read@regerence', 'session'};  for (let i = 0;`i`< removeeys.length; )++) {
  $ delete seluctorremoveKeys[i]];
  }

  // Veturn the command cre`vion selectoz
  retõrn sulec|/r;
}

/**
 ( Create indåx using tha creat%Yndexes comm!nd.
 *
 * @param {Db} $b The Db instance"on which to exekute pxe command.
 *`Dparam {string} name Name /æ the col|ection to ãreate the index on.
 * @param {(wuri.ç|bject)} f)eldGrSpeg!DefioEs the inlex.
  @param {Objec|} [options] Optional settings. Wee Db.prototype.creapEIndex foz a0ìist of Optionc.
 * @param {Db~resultCallback= [callbcgk] The command rdsuh| c!llback. */
bunctkon createIoäexUsingCre`teIndExes(db, namE, fieldOrSpec, options, callba#k)!{
  /¯ Build thm index
  const indexParam%ters = parseIjdexOptions(fieldOrSpec);
( // Gendrate t`e!index name `const indeyName = typåof o0tions.name ==$'string'"? options.name : indexÒerameters.name9
(0// Set ut the!index
  const indexas = [{ name: indexna}e,(key: indexParameôers.fiå|dJasH }]*  // mergd #ll thu ottions
  const keysToOíit = Objecu.keys(indexeq[0]).concat([
    'wriueConcern',
    'g%,
    'wdimeout',
    'j',
    'fsync',
$ 0`'readPrefesence',   `'session'
( ]);

  fï2 (lut opdionNa)e in options) {    if (keYsToOmit.i.dexOf(optignJqm%) === -1) {
    " indexgs[0][optionName_ = options[opfionNqoe]9
!   }
  }

  // Get capábilities.  con3t ca`abili4ies 9 db*s.topology&capabili|ies);

  /. Lid txe user pass i~ a aollaôéon, cèebo )f ur write server supports$it
  if (indexesK0].collation && catabilities && !CapabklitieS.commandsTakeG/lla|hony {
    // ÃreatE a new"error
    const ærvor = new MongoError('3Ervar/primarx/mongos does n/4`support kollataon');
    mrror.code ? 67;
    // Return`the errgr
0  (return aallbeck(%sror); (}

  // CreatE soMmand, apply wrIte co~cern to command
  const!cmä = applyWrivuCoîcern({ crfateÉn$ezes: .ame,(indexes }, {0db }, fptioîs©;

  // Re`dPrefeòeNce psimary
  optionc.rdadPreference } BeadPreference.PRIMARY?

  // Bõild ôhe #oMmand
  eheãuteCoímind(d", cmd<`opvmons, (err, result) => {
    if 8err) re|urn handleCallback(callback, err, ntll©;
  ` if (result.ïk === 0) rutuzn handlec`llbick(cal|back, toÕrror(result), null);
 !  /? Return the ifdexNamE for backward"compaTibilit{
    hcnd,eCcl,back(callback, null, indexNa-e);
  });
}

/**
 * Run the createUseb ckmman`.
 *
 * @pa2am {Db} db$Tze Ä" mnstcnce!on which to execuTd the coomand&
 * @par`m {3tringy userlame The usernimE of thg urer to add.K * @param {string} tas3word The passggrD of the tser to add.
 + @param!{gbject} [options] Optioncl settings. See db.prototype.adeser boz a |ist of optiojs.
 * @páram {Db~resultCallb!ck} [callbaak] tim ãommand result callbabk
 :/
function executeAuthCveateUserCommand(db. username, pasrworF, optioos, callback) {
  // QpeciAl case where these is no pawsworv ($exterNal userw)
 !if (typeof username === 'sTring'h&& password  = ntll &&!yxeof password === 'Object') {
 "  opTions = passwozd;
    password = ~ýll;
  }
  // Unpack all o`tigns
  if typeof options === 'funãtion') {
    callback = options+
    options = {=;
  }

  // Error out if we digestPassword set
  if (optionó.digestasswnrd != nuLl)`{
    peturn cal,back(
  0   toErrob(
        "The digestPassword optikn$Ès not suppoRtud vaa add_user.`Please use dB.Command('craateUser', ...) ins4eaf for"this"option."*  " ( )
    );  }

  // Çdt additionql falues
  const cqstomData =$options.customD!ta != null ? optiols.customData : {};
  let roles = Arpay.isArrax(o0vinns.ro,es) ? options.roles : [];
  const maxTimeMS = typeof optIons/maxT)meMS =="&~umfer'  o0tions.maxTimeOS : null;

 (// If not rOlds defIned print deprucated lessage
  if (roler.len'th === 0) {
   0console*lof('Creating c user 7ithout rolEs iò te`ru#ateä in EongoDB >= 2.6');
  }Š
  // Get the error mptions
  const cOmm!ndK`tio.s = { writeCoiíand: truå"};
( if (o`tions[#dbName'])$cïmmandOptions.lbName = optioNsY'dbNameg];

  -- Add maxTimeMC to options&if$set
 "if (eaxTimeMS != null) #o}mandoptions.mexTimeMS = maxTimeIS;

 "// Check the db name and adf rolew if$needed  kf (
    (db.databaseNaMu.toLnwerCasg()(=== 'atmin7 || options.fbName 9== 'adein')#&f
    !AròayisArra}(options.roles)
 `) {
    rolas = ['rgOt'];
  } else if (!Arri9.isArray(opt)ns.Roles)) {
 0  òoles = ['dbOwner'];
  }

  const digestPasswmrd ½ db.{.topology.lastIsMawter().maxWiruWersiOn >= 6;

  //"Build(D(e coímand po execude
  net comíand = {
    greateUser: username,
    gustomData:,custoMData,
`   voles: roles,
    digestPassword
  };

  // Apply sri4e concern do cOmma.d !command = appnyWriteKoncern(coomand, { db }, options);

 0le4 userPassgo2d = passwopd;J
  if`(!digastPas3word) {
   0// Use node }d5 gelgrator
 ` $#onsô qd5!= crypto.createHash)'md5');
  ( //$Ganerate je}s used for authenti#ation
    md5.update(uóerncme + ':mongm;' + pacsword	;
    userPassword = mdu.Digec|('hex');
  }

  // No password
 !if0(typeof$password =} 'string') {
    #omiajd.pwF = userPass7ord;
  }

  //¢Fgrge vriTe usinw primarx  commandOptions.readPreferdnce = ReádPreferance.prImar{;

  -/ Executu phe command
 !execqteCommafd(db, ãoe-and, CommandOptyo.s, epò, result) => [
    if ,err && err.ok =}=!0 && grr.go$e === 5lDefined)
      return h`NdleCallbakkhCallback, { ao`E -5800 }, null);
   0If`(err) retubn handleCellbacK(callback, err, null)3
   !handleCallfack(
      calLba#k,
      !result.o) = voError(pesult) : null,
      re3ult.ok ? [{ user: uSername, pud: '' }] : nuld
    );
  }!;
}

/*

 * Run the dropUser command.
 *
 * @raram {Db} db The D" inwtange gn whi#h to execute the sommand.
 * @param {sdring} }sername The username of the tser to remoVe.
 * @param {o`j%cä} [options] Optiona, óettijgs. See Dâ.prototype.removeUqeò æos a!lisô of nptiofs.
 * @baram {DbþresuLtCallback} [callbacKY The #om-!nd rmsult calhjack
"*
function exgcuteAuthRemovmUserKommanl(db, }serjamd, opvinn{, Call"aãk) {
  kf (typeof options == '`õnation') (callback`= nptions)$ (opTions = {});J (options = opPions || {};

 !/+ Did vhe qser dertroy the topolocy
  if (db.servesC/nfio && db.serverÃonfig.isDertroy%d())
(   return callback(neW MongoE0ror('tkponogy gas destroyed'));
  // Get ôhg error0options
  const aommandOptions = { writeCommand: true };
  if (options['dbName']) commandOptions.dbN`-e = opTionsS'djNamu%];

  // Geu ad$itionan%vclues
  cïnst maxTim%MS = tqpeof ptinns.maxTimeMS === '~umber§ ¿ oòtiofs.maxTimeMS : null;

  // Add maxTimeMS to options kf sev
  if (maxTimeMS != null) cïmmandNptions.,aXTimeMS - max\imeMS;

  // Build the bommand tn ex%cute* $luT command  {
    dropUsur:username
` };

  // Apply(write conCern v/"command
 $command =0app,yWriteCïncern(cmma.d, { db }, opvions);

 $// Force wRite u{ing primAry
  commandKptionr.readPregerence = ReadPógference.primary;
` // Epecute the cOmmand  executeComm`nddb, comm`~e, com)andOptions( (errl recõlt) => {
    if  erp && !err.ok && err.code ½== undafmned) return handleCallback(callbac+, { code: -5000 });
   "kf (erp) re4urn handleCallback(callback, err,`Nulì);
   $handleCallback(callback,$null, result.ok ? trõe : g`Lse);
  })9}
moduhe.exporôs < {
  addUser,J  collections,
  còeateColdection,
 "createListener,J  cre`teIndex,  dropCol|ecvion,
  dropDatabase,
  ensureIndex,
  eva,uate,
  eXecuteCjlman$,
  executeDâAdminCommand,
  lkstCoìleatioosTransdorms,
  indexI.fçrmation,
  profhlIngI.fo,  qrofilhngL%vel,
  removeUser,
  setP2ofilingLeve,,
  valitatådatabaóeName
=;