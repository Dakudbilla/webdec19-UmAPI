'use strict';

const applyWriteConcern = require('../utils').applyWriteConcern;
const applyRetryableWrites = require('../utils').applyRetryableWrites;
const checkCollectionName = require('../utils').checkCollectionName;
const Code = require('mongodb-core').BSON.Code;
const createIndexDb = require('./db_ops').createIndex;
const decorateCommand = require('../utils').decorateCommand;
const decorateWithCollation = require('../utils').decorateWithCollation;
const decorateWithReadConcern = require('../utils').decorateWithReadConcern;
const ensureIndexDb = require('./db_ops').ensureIndex;
const evaluate = require('./db_ops').evaluate;
const executeCommand = require('./db_ops').executeCommand;
const executeDbAdminCommand = require('./db_ops').executeDbAdminCommand;
const formattedOrderClause = require('../utils').formattedOrderClause;
const resolveReadPreference = require('../utils').resolveReadPreference;
const handleCallback = require('../utils').handleCallback;
const indexInformationDb = require('./db_ops').indexInformation;
const isObject = require('../utils').isObject;
const Long = require('mongodb-core').BSON.Long;
const MongoError = require('mongodb-core').MongoError;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;

let collection;
function loadCollection() {
  if (!collection) {
    collection = require('../collection');
  }
  return collection;
}
let db;
function loadDb() {
  if (!db) {
    db = require('../db');
  }
  return db;
}

/**
 * Group function helper
 * @ignore
 */
// var groupFunction = function () {
//   var c = db[ns].find(condition);
//   var map = new Map();
//   var reduce_function = reduce;
//
//   while (c.hasNext()) {
//     var obj = c.next();
//     var key = {};
//
//     for (var i = 0, len = keys.length; i < len; ++i) {
//       var k = keys[i];
//       key[k] = obj[k];
//     }
//
//     var aggObj = map.get(key);
//
//     if (aggObj == null) {
//       var newObj = Object.extend({}, key);
//       aggObj = Object.extend(newObj, initial);
//       map.put(key, aggObj);
//     }
//
//     reduce_function(obj, aggObj);
//   }
//
//   return { "result": map.values() };
// }.toString();
const groupFunction =
  'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';

/**
 * Perform a bulkWrite operation. See Collection.prototype.bulkWrite for more information.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object[]} operations Bulk operations to perform.
 * @param {object} [options] Optional settings. See Collection.prototype.bulkWrite for a list of options.
 * @param {Collection~bulkWriteOpCallback} [callback] The command result callback
 */
function bulkWrite(coll, operations, options, callback) {
  // Add ignoreUndefined
  if (coll.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = coll.s.options.ignoreUndefined;
  }

  // Create the bulk operation
  const bulk =
    options.ordered === true || options.ordered == null
      ? coll.initializeOrderedBulkOp(options)
      : coll.initializeUnorderedBulkOp(options);

  // Do we have a collation
  let collation = false;

  // for each op go through and add to the bulk
  try {
    for (let i = 0; i < operations.length; i++) {
      // Get the operation type
      const key = Object.keys(operations[i])[0];
      // Check if we have a collation
      if (operations[i][key].collation) {
        collation = true;
      }

      // Pass to the raw bulk
      bulk.raw(operations[i]);
    }
  } catch (err) {
    return callback(err, null);
  }

  // Final options for retryable writes and write concern
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);

  const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
  const capabilities = coll.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if (collation && capabilities && !capabilities.commandsTakeCollation) {
    return callback(new MongoError('server/primary/mongos does not support collation'));
  }

  // Execute the bulk
  bulk.execute(writeCon, finalOptions, (err, r) => {
    // We have connection level error
    if (!r && err) {
      return callback(err, null);
    }

    r.insertedCount = r.nInserted;
    r.matchedCount = r.nMatched;
    r.modifiedCount = r.nModified || 0;
    r.deletedCount = r.nRemoved;
    r.upsertedCount = r.getUpsertedIds().length;
    r.upsertedIds = {};
    r.insertedIds = {};

    // Update the n
    r.n = r.insertedCount;

    // Inserted documents
    const inserted = r.getInsertedIds();
    // Map inserted ids
    for (let i = 0; i < inserted.length; i++) {
      r.insertedIds[inserted[i].index] = inserted[i]._id;
    }

    // Upserted documents
    const upserted = r.getUpsertedIds();
    // Map upserted ids
    for (let i = 0; i < upserted.length; i++) {
      r.upsertedIds[upserted[i].index] = upserted[i]._id;
    }

    // Return the results
    callback(null, r);
  });
}

// Check the update operation to ensure it has atomic operators.
function checkForAtomicOperators(update) {
  const keys = Object.keys(update);

  // same errors as the server would give for update doc lacking atomic operators
  if (keys.length === 0) {
    return toError('The update operation document must contain at least one atomic operator.');
  }

  if (keys[0][0] !== '$') {
    return toError('the update operation document must contain atomic operators.');
  }
}

/**
 * Count the number of documents in the collection that match the query.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} query The query for the count.
 * @param {object} [options] Optional settings. See Collection.prototype.count for a list of options.
 * @param {Collection~countCallback} [callback] The command result callback
 */
function count(coll, query, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  options.collectionName = coll.s.name;

  options.readPreference = resolveReadPreference(options, {
    db: coll.s.db,
    collection: coll
  });

  let cmd;
  try {
    cmd = buildCountCommand(coll, query, options);
  } catch (err) {
    return callback(err);
  }

  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.n);
  });
}

function countDocuments(coll, query, options, callback) {
  const skip = options.skip;
  const limit = options.limit;
  options = Object.assign({}, options);

  const pipeline = [{ $match: query }];

  // Add skip and limit if defined
  if (typeof skip === 'number') {
    pipeline.push({ $skip: skip });
  }

  if (typeof limit === 'number') {
    pipeline.push({ $limit: limit });
  }

  pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });

  delete options.limit;
  delete options.skip;

  coll.aggregate(pipeline, options).toArray((err, docs) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, docs.length ? docs[0].n : 0);
  });
}

/**
 * Build the count command.
 *
 * @method
 * @param {collectionOrCursor} an instance of a collection or cursor
 * @param {object} query The query for the count.
 * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.
 */
function buildCountCommand(collectionOrCursor, query, options) {
  const skip = options.skip;
  const limit = options.limit;
  let hint = options.hint;
  const maxTimeMS = options.maxTimeMS;
  query = query || {};

  // Final query
  const cmd = {
    count: options.collectionName,
    query: query
  };

  // check if collectionOrCursor is a cursor by using cursor.s.numberOfRetries
  if (collectionOrCursor.s.numberOfRetries) {
    if (collectionOrCursor.s.options.hint) {
      hint = collectionOrCursor.s.options.hint;
    } else if (collectionOrCursor.s.cmd.hint) {
      hint = collectionOrCursor.s.cmd.hint;
    }
    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.s.cmd);
  } else {
    decorateWithCollation(cmd, collectionOrCursor, options);
  }

  // Add limit, skip and maxTimeMS if defined
  if (typeof skip === 'number') cmd.skip = skip;
  if (typeof limit === 'number') cmd.limit = limit;
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;
  if (hint) cmd.hint = hint;

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, collectionOrCursor);

  return cmd;
}

/**
 * Create an index on the db and collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function createIndex(coll, fieldOrSpec, options, callback) {
  createIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
}

/**
 * Create multiple indexes in the collection. This method is only supported for
 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {array} indexSpecs An array of index specifications to be created
 * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function createIndexes(coll, indexSpecs, options, callback) {
  const capabilities = coll.s.topology.capabilities();

  // Ensure we generate the correct name if the parameter is not set
  for (let i = 0; i < indexSpecs.length; i++) {
    if (indexSpecs[i].name == null) {
      const keys = [];

      // Did the user pass in a collation, check if our write server supports it
      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
        return callback(new MongoError('server/primary/mongos does not support collation'));
      }

      for (let name in indexSpecs[i].key) {
        keys.push(`${name}_${indexSpecs[i].key[name]}`);
      }

      // Set the name
      indexSpecs[i].name = keys.join('_');
    }
  }

  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });

  // Execute the index
  executeCommand(
    coll.s.db,
    {
      createIndexes: coll.s.name,
      indexes: indexSpecs
    },
    options,
    callback
  );
}

function deleteCallback(err, r, callback) {
  if (callback == null) return;
  if (err && callback) return callback(err);
  if (r == null) return callback(null, { result: { ok: 1 } });
  r.deletedCount = r.result.n;
  if (callback) callback(null, r);
}

/**
 * Delete multiple documents from the collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} filter The Filter used to select the documents to remove
 * @param {object} [options] Optional settings. See Collection.prototype.deleteMany for a list of options.
 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
 */
function deleteMany(coll, filter, options, callback) {
  options.single = false;

  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
}

/**
 * Delete a single document from the collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} filter The Filter used to select the document to remove
 * @param {object} [options] Optional settings. See Collection.prototype.deleteOne for a list of options.
 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
 */
function deleteOne(coll, filter, options, callback) {
  options.single = true;
  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
}

/**
 * Return a list of distinct values for the given key across a collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {string} key Field of the document to find distinct values for.
 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
 * @param {object} [options] Optional settings. See Collection.prototype.distinct for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function distinct(coll, key, query, options, callback) {
  // maxTimeMS option
  const maxTimeMS = options.maxTimeMS;

  // Distinct command
  const cmd = {
    distinct: coll.s.name,
    key: key,
    query: query
  };

  options = Object.assign({}, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });

  // Add maxTimeMS if defined
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;

  // Do we have a readConcern specified
  decorateWithReadConcern(cmd, coll, options);

  // Have we specified collation
  try {
    decorateWithCollation(cmd, coll, options);
  } catch (err) {
    return callback(err, null);
  }

  // Execute the command
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.values);
  });
}

/**
 * Drop an index from this collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {string} indexName Name of the index to drop.
 * @param {object} [options] Optional settings. See Collection.prototype.dropIndex for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function dropIndex(coll, indexName, options, callback) {
  // Delete index command
  const cmd = { dropIndexes: coll.s.name, index: indexName };

  // Decorate command with writeConcern if supported
  applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options);

  // Execute command
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (typeof callback !== 'function') return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  });
}

/**
 * Drop all indexes from this collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {Object} [options] Optional settings. See Collection.prototype.dropIndexes for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function dropIndexes(coll, options, callback) {
  dropIndex(coll, '*', options, err => {
    if (err) return handleCallback(callback, err, false);
    handleCallback(callback, null, true);
  });
}

/**
 * Ensure that an index exists. If the index does not exist, this function creates it.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function ensureIndex(coll, fieldOrSpec, options, callback) {
  ensureIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
}

/**
 * Find and update a document.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} query Query object to locate the object to modify.
 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object} doc The fields/vals to be updated.
 * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.
 * @param {Collection~findAndModifyCallback} [callback] The command result callback
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
function findAndModify(coll, query, sort, doc, options, callback) {
  // Create findAndModify command object
  const queryObject = {
    findAndModify: coll.s.name,
    query: query
  };

  sort = formattedOrderClause(sort);
  if (sort) {
    queryObject.sort = sort;
  }

  queryObject.new = options.new ? true : false;
  queryObject.remove = options.remove ? true : false;
  queryObject.upsert = options.upsert ? true : false;

  const projection = options.projection || options.fields;

  if (projection) {
    queryObject.fields = projection;
  }

  if (options.arrayFilters) {
    queryObject.arrayFilters = options.arrayFilters;
    delete options.arrayFilters;
  }

  if (doc && !options.remove) {
    queryObject.update = doc;
  }

  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;

  // Either use override on the function, or go back to default on either the collection
  // level or db
  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;

  // No check on the documents
  options.checkKeys = false;

  // Final options for retryable writes and write concern
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);

  // Decorate the findAndModify command with the write Concern
  if (finalOptions.writeConcern) {
    queryObject.writeConcern = finalOptions.writeConcern;
  }

  // Have we specified bypassDocumentValidation
  if (finalOptions.bypassDocumentValidation === true) {
    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
  }

  finalOptions.readPreference = ReadPreference.primary;

  // Have we specified collation
  try {
    decorateWithCollation(queryObject, coll, finalOptions);
  } catch (err) {
    return callback(err, null);
  }

  // Execute the command
  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
    if (err) return handleCallback(callback, err, null);

    return handleCallback(callback, null, result);
  });
}

/**
 * Find and remove a document.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} query Query object to locate the object to modify.
 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object} [options] Optional settings. See Collection.prototype.findAndRemove for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 * @deprecated use findOneAndDelete instead
 */
function findAndRemove(coll, query, sort, options, callback) {
  // Add the remove option
  options.remove = true;
  // Execute the callback
  findAndModify(coll, query, sort, null, options, callback);
}

/**
 * Fetch the first document that matches the query.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} query Query for find Operation
 * @param {object} [options] Optional settings. See Collection.prototype.findOne for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function findOne(coll, query, options, callback) {
  const cursor = coll
    .find(query, options)
    .limit(-1)
    .batchSize(1);

  // Return the item
  cursor.next((err, item) => {
    if (err != null) return handleCallback(callback, toError(err), null);
    handleCallback(callback, null, item);
  });
}

/**
 * Find a document and delete it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} filter Document selection filter.
 * @param {object} [options] Optional settings. See Collection.prototype.findOneAndDelete for a list of options.
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 */
function findOneAndDelete(coll, filter, options, callback) {
  // Final options
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.remove = true;
  // Execute find and Modify
  findAndModify(coll, filter, options.sort, null, finalOptions, callback);
}

/**
 * Find a document and replace it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} filter Document selection filter.
 * @param {object} replacement Document replacing the matching document.
 * @param {object} [options] Optional settings. See Collection.prototype.findOneAndReplace for a list of options.
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 */
function findOneAndReplace(coll, filter, replacement, options, callback) {
  // Final options
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
  finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;

  // Execute findAndModify
  findAndModify(coll, filter, options.sort, replacement, finalOptions, callback);
}

/**
 * Find a document and update it in one atomic operation. This requires a write lock for the duration of the operation.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {object} filter Document selection filter.
 * @param {object} update Update operations to be performed on the document
 * @param {object} [options] Optional settings. See Collection.prototype.findOneAndUpdate for a list of options.
 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
 */
function findOneAndUpdate(coll, filter, update, options, callback) {
  // Final options
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
  finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false;

  // Execute findAndModify
  findAndModify(coll, filter, options.sort, update, finalOptions, callback);
}

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param {object} [options] Optional settings. See Collection.prototype.geoHaystackSearch for a list of options.
 * @param {Collection~resultCallback} [callback] The command result callback
 */
function geoHaystackSearch(coll, x, y, options, callback) {
  // Build command object
  let commandObject = {
    geoSearch: coll.s.name,
    near: [x, y]
  };

  // Remove read preference from hash if it exists
  commandObject = decorateCommand(commandObject, options, ['readPreference', 'session']);

  options = Object.assign({}, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });

  // Do we have a readConcern specified
  decorateWithReadConcern(commandObject, coll, options);

  // Execute the command
  executeCommand(coll.s.db, commandObject, options, (err, res) => {
    if (err) return handleCallback(callback, err);
    if (res.err || res.errmsg) handleCallback(callback, toError(res));
    // should we only be returning res.results here? Not sure if the user
    // should see the other return information
    handleCallback(callback, null, res);
  });
}

/**
 * Run a group command across a collection.
 *
 * @method
 * @param {Collection} a Collection instance.
 * @param {(object|array|function|code)} keys An object, array or function exrressing the kays to oroup by/
 * @param {ocJect} condition En opuioNa,!condition that musu be true for a row tO be con{idered.
 * @param {object} iNaôial Éîitial value of tie aggseeauaon counteò object.
 * @param {(functiof|Cnde)} rgducm The Reduce gunction aggregates (raduces)`the objects iterated
 * @param ;(functi_l|Cole)} fin`lizm Qn optional fuîction 4o be run on each iv%m in t(e resUlt set just before the item")3 retur.ed.
 * @papam {boolean} áommInd S`ecif{ if you wmsh to run ushng the!internal group0#omm`nf or usilg eval, defaump is true.
 * @param {object} [opt)ons] O0tional sgtténWs. See Colluction.prototype.grMup Fo2 a lmst of options.
 * @param {ollection~resultÃallback} [callback] The coímaN$ result callback
 *!@deprebated`MongoDB 3.& or`hégher wéll ng longer sqpport the$gsoup cmmmand. We"recommen` Rewriting uskng the aggrEgathon fram%work®
$*/
functio. group(coll, ke9s, cmndktion, initict, reducd, finilize, #oMmand, optioos| callback) {
  // Execute uskng the commanf
  yf (kommanf) {
    const"re$uceFuoc|ion = 2efuce && reduce._bso~type ===('Code§ ? reducE : new Code(reduce);

    conSt selEctor = { " "  group: {
        ns:0ãolh.w.name,
  $     $reduce:(reeuceFuncti/n,J  `     cond: condition,
        initial: initial,
        outº 'hnlIne'
      }$   };Š
    // if finalize is defined
    mf (fijQlize0!= null) smlector.g2oup['finalize'} = fhnalize;
    // Sut up group seleatOr
$   if ('function' === typ%of keys || (keys &' keys._bsoltype === 'CodE'9)${
      selector.grouP.$ke{f } keys && keys._bsoNtypu!=== 'Code' ? keys : new AoDe(keys);
    } else {
      const hasl = {};
      keys.forEacH(cex => {
a     " hash[kEy] = ;
      });
      sedector.group.kay = lash;
"   }

 `  nptigns = OBject.assmgn({}, options);
    //@Ensure we have |he right rÅad preference mnheritanc%
 `  optioos.readPreference =%resohveRaa$PReberence(oPtions, { db: cll.s®df, coll%CtioN: cnll });

0   // Eo we have"a reAdConcern specifIed
    decorateWithRua$Koncern(selector, coll, optionq);
    // Hyve we speCifked collationJ    try {
     $decor`teWidhCllation(selector, coll, options)3
    } cavcj (err-"{
      rdturn calmbackerr, nell);
`   ?

    / Execuug command
    exeãuteAommand(coll.w.db, semebtor, option3, (err, result) => y
      yf (årr! retur~ hajdleCallcack(callback, årr, null);
      iandleGallback(callback, null, rdsõlt.retval);
    }!;
  } edse {Š$   /¯ recte execution sCope
    const scOpe  reduce != null && reduce.^b{ontype === 'Cgde6 ? rmduce.sgope : {};

    scope.ns = col|.sname3    scope.keys  ieys;
    scope.sjndition = aondition;Š    scopu.initi l = initial;

  0 // Pass in thu function text 4o exacute within mongodbn
    const groupfn = groupFunction.ruplace(. reduce;/, reduce.toString() * ';'	;
"(  evaluaTe(coll.s.db, new Cde(groupfn, scope)- ~ull, options, (err, results) => {
 !    if (err) retu2m handleCallbacc8call`ack, err,$null);
$     ha.dlecallcack(callback¬ nulm,`results.resunt || results)»
    }	;
  }
}
¯*"
 * Retrmeve all0the Indexes on2pèe collection.
 *
 * @method
 * Àparam {CollEction} a Collection i*stancd.
 * @qaram {Object} [options] Optional settiNgs.$See Cllection.prototypeªindexas dor"a list of options> * @pazam {CollEction~recudtCallback} Ocallb`cc] The boimand result callback
 */
fUnction iNdexes(coll((options, callâack) {
  options = OcjEct.aósign({}, s full: t2uí , optikns);
  indexInfobmá4ionDb(coll.s.db, aol|.s.nb-e, options, callbask);
}

/** * Ch%ck$if one or iore indexes!exist on the #gllegtIon. Uhis faals On"the first index txAt doesnt exist.
 + * @mmthod
 * `0ar`m {Collection} a Collecthon instance&
 * @param {(sdrinc|arra{)} ind%xes0One or0more index names to chmck.
 * @PaRam {Objecv} [opt)ons] Optional settingr. See Cgllection>pòototype.inde|xists gor a lIst of mttmons.
 * @param {Con|egtion~rewUltÃalìbagk} {callback] Tèe$commanf result0callbaãk
 */
funstion iode|Axmsts(coll, andexeq, optéons, callback) {
! kndexInformation(coll, gptmons. (err, kndexInfosmation) ?> {
  " // If*we have an"error retupn
    if (err != null)0return handmeCallbcck8callbacj, erv¬ numl);!   o/ Let's$cheak wos the kndex name3"   if ()Arrai.asArray(in`exas	©
      seturn handleCalhback(caldback, null, indexInformation[ineexesM != nuLl)+    // Check In list of indexes
    for (het i = 0; i  indexås.length9 i++) {
      if (indåx	nfoRm!4ionindexes[i]] ==!null) {
        return hanl|eCallb`sc(callback, null, fálse);*      |
€   }

    // All jeys fouNd`returN tvue
    returj handleCallbask(callback, null, trua);
  })9*}

/**
 * Retrheve this co|lection's index info.
 *
 * @method
"* @param Co|lec4éoj} a Collection Instance.
 
0Apqr!m {objeCt= [options] Ïptional setting3. See"Collection,prtodype.intexInformation For,a lis| ov options.
 * @param ;Agllactio.~resultBa|lbcck} [calnraci] The"command veóult cál,baCk
 */
function in`exInformation(coll, options, cellback) {
  index‰nfoRmaTionDb(coll.s®db, colm.s.name, option3, callback+;
}

func4ion ansertDocummnps(coll, docs- optioNs, callba#k) y
  if (typeof options =}= 'funcôioî') (aallback = options!, (ktdioîs"< {});
  options = oxtions || {};
  // Ensure we are operating(kn an array op docs
  docs$= Array®iÓArray(docs) ?0docs : [d/cs]:

  ?/ Final options fob rgvryable wrétes a~d write cnncern
  ldt finalOxuions  ObjEct.cssign({}( op4igns);
" vinalOptigns0= apzlyRet2yableWvites(finalOptimns, coll*s.`b);  binanOptions = ápplyWrIteCkncern(fi~alOptions, { dbº coll.s>db, collection:`coll }, options){

  -/ If keep0going"s%t`unordered
 dig (finalO8tionS.keepGoinã!===#true) dinalOptio~s.rdered ? false;
  dinalOptho.s.serializeFunctions = options.surializeFunct)ons || cll*s.sezial)zgFqnctions
  docs = prepareTocs(coll,`Docs, options);*  +/ Fila inserts
  collns.toPology.iîsept(coll.s.fA}espace, docS, finaLOptions, *err, re{ult( => {
    if (callback ½= null) re4urn;
 0  iF (err) return handleCallback8Galdback, err);
  $ yf  reqult == nµll) returj hanfluCallback(kallback, null,0null);
    if (resultraswlt.code) raturn`han`feCall`ack(#hllback, toError(sesult.rewtlt));   `if (vesult/result.7riteEvrgrs)      råturn handleCalLbcc+(sallback, vnError(result.resuLt.w"iteErrors[0]));
    // Add focs to the <)st
   !result.ïps = dmCs;    // Seturn the results
   "haNdleCallbac{(callback, nu~h, resulT);
  })+


/**
$* I~serp a single docu-dnv into the colLdction. See Ãoìlection.prototype.hnsertOn% for more informãtion.
 *
 * @method
 & @ðaram${oLlEctyon} a"Aollection instance.
 * @paral¨{object}$kc Document to!insdrt.
 * @parem {obzect} [options] Opdional settingó. Sge Collgction.protntype.inserôOne for a list of kptions.
`* Aparao {Colleatio~~insdrtOneWpiTuOpCallback [callback] Thd coomand result callback
 */
function hnrertOne(cohl< toc, options, callback) {
  if (Array.isArray(doc()0{
   $returo call"ack(
    ( IoneoError.creatg({ Mesqagez 'dOc parameter lust be an o`ject', driver: true })
    );
  }

  iNsertDocyments(coll,"[äcc], options- *erb, r)(=> {
    if (gellbAck =½ null) retern{*    iF`(err && callbAck) return callc`ck(esr);
    // Woòkaround for Pre 2.6 Servgrs
  ` if 8r == ~ull) return0ce|lback(null, s resudt: { ok: 1 } });    / Add values to dop ldven to enqure crud spec compatibility
    r.insertedCount = r.result.n;
 d  r.insertedId = doc._id;
    )f (callback) callback(nul,< ò!;
  });
}

-**
 * Inserts an array of documents intm MkngoDB. If documents pa{sed in do not contail the **_i`(* field,
 * one sill be add-d to each mf the documents missine it by the driver, -etating`the dOcumeît. Thiq behavi/r
 . can be ov%rridden by0wetthng0the **fOrceServurO"jectIl** flagn
 *
 * @metèoD
 * @param zCollecpion} a Ckllectin instance.
 * @param {obj%ct[]}(vocs Documefts$to inse`t.
 * @paRam {numbe2} [oðtions] Optional settingr. See Collecvion.pbototype.insertMany for a list of optins.
 * @para- {Cllection~insertWréteOpScllbabk} [callbaak]`The command result callback
`*/
function insertMa~y(coll, doãs, opdions, callback) {
  if (!Array,isArray8docs)) {
   (r%t5rn cmllback(
      MïnwoError.create({ message: 'doks parametep must be an `rray Of dOcumdnts', driver: true })
    );
  }š
  // If keex`going set unordereä
  options['serialhzeFunctions'] = optho.s['serializeBunctions/] || coll.s.seriahizeFunctimnw;

  docw = p2upareDocs(coll, docs, options);

  // Generáte the bulk write operatioîs
  const oparavions ½ S    {
    ` insertMany: doCs
 ` 0}
  ];
  bUlkVrite(coll, operatiols, optignsl (err, res}lt) =6 {
(   if (err) return callback(errl nµll);
"   calmback(jUll$ -ap	nSertMansResul|s(docs, result));
  }	;
}

fwncpéon mapInser`MályRestlts(dncó, R) {
  const finalZesuLt ½ {
    result> y ok: 1,"nº r.inqevôedCount`},    ops: dmcs,
    insertelCountº R&insertedCownt,
    insertedYds: r.inse2tee)ds
  };

  if(*r,getLestOp())`{
    fin`lResult.òesul|.opTimg = r,getLawtop();
  }

! retusn!finclRewUlp;
}
O*

 * Detezmine wHether the cnllectaon(is$e gapped collection.
 *
 * @method
 " @parem {ollection} a Collection iNst!nce.
 * @rcram sOb*mct} [options] Op4ional sEttings. S-e Collection.`rktotype.isCcpped for a"list of options.
 : @parcm {EollectioN~resultCallbac+ý [callbaCk] \ie pesults caìlback
 */
dunction isCappeD(coln- optionc, callback) {
  opôionsOp(co,l,0optikls, (ebp,$document) => {
    af (err)"rutuRn hanäleCallback(callback, err);
    haodleCallb!ck(ãallâack, nuld, !!(document && docume~t.capped)):
  })+
}
/*j * Rtn Map Råduce across a col|ection. Be awAre that"tha inli~e mption for out will revurn an arraY of results not a gollectaon.
 .
 * @method
 *"@pazaM {Collectioo} a Collectiol instance.* * @pabam {)f5nctiootruring)} map The mapping function.
 ( @param {(function|string)} reduce The reduce function.
$* @pcrcm {object} [/pdk/ns]0Kptional settings. Óg% COlmectiKn.ðrototy`e.m`pZe`uce for`a d	st of options. * @pcram {CollectionzresultCallvaCk} [call"abk] The command result callback
 */*funcpion mapReduãe(coll, map, reducu¬ options, ballback) {
  const oapCommandHash"= {
`   mapred5ce: coll.s,>ame,
    ïav: map,
    ruduce: reduce
  };

  // Exclusion list
  const Ezclu{ionList ="['ruadPrdfermnce', 'wession', 'bypassDocumentalidction'];
  // Add any"ïthuR0options pawsad inJ  nor (let n in options) {
0   if ('sc?pe' ==- n) {      mapCommandHashKn\ = processScoPe(optmons[n]);
`   } else {
    0 / Onlx inclufe +æ nkt in exclu{ion liwt
      hf (exclu3ionLit.indexof(n) === -1( {
        mapCommandHash[n] =!Optionó[n];
     0}
  ! }  }
  options = Object.ewsign({}, options9;

  // Eîsure we have the right`read prefeòence inhevItance
  options.readPreFe2eîce = reSolveRe`dXreference(optionr, { db: coll.r.dc, conlmcTion: coll });

  //!If we!have a read preferense and inlile!is not set`as output fail harl
  if h
    options.readPreference !== FalsE &&
    optinns.rEadPpevergnc% !=- 'prim!ry' &&
    options['out']06&
    (o`tiols['out'].inlaoe !== 1 "& optionsY'out'] !== 'inline')
  + {
(   // Fgrce readPreferunce t/ pr)íary
  0 optionsnreatPreference = '0rimary';
    // Äecorate command with 7riteConCern if supported
  `$appl{WriteConcerg(mapCommandHash, { db: coll.s&db, colh%ction: coll }, options);
  } else {J    `%corat%WidhReadConcern(mapCommanäHasH, aoll, optionr):
  =

  // Is(âypassDocumentValidatcon¤specifie`
  iv (options.bypassEocumentVa|idation === 4rue) {    mapCommàndJarh."ypassDOcu-entValidation = options.bypassDocumdntValidatin;
  }

0 // Èave v% stecéfidd collation
  tvy {    decorateWithCollatin(maxCommandhash, coll,$optiojs);
  } catch 8err+ {Š   !return cahlback(err, null);
  }
  // Execute command
  ehecqpaCoímant(coll.s.dc, mapCommandHash- options, (err,àbesqlt) =< {:    if (err) retus~ handleCallbaCk(cadlba#k, err);
    /' Check if we hkve an error
    if!(1 !== result.ok || result.err || result.errmSg) {
    " retUrn4(andleCallbAck(camnjack, toUrror(zesult));(   }

    // Create statystics value
    const statq } {];
    if (reóult.tim%Millis) rtats['procg3stime']  result.timeMillis;
    if (result&counts) stats['counts'] = result/counts;
    if (resulv.timing) wtat['timing'_ = råsul6.timing»

    // invoked with mnlinE?
    if`(resuht,results) {
      // If we wisx foò no verbosity
      If  op|mons['Verbo{e'] == lqml | !ortions['verbose']) {
        betur~ handlmcallbagk callfack, null, re3ult.resu,ts);
      y

      return handleCÁl`back(callback, ntll, { restdts: result.resultq, stqvs: {tats });
    }

    // The retUrned colì%ctimn
    let collection = null;

    /¯ If we have an mrjecô its a diffdrent db
    if (result.result != nu,l && typemf recult.result === 'objeãt')¢{
      aons| d/c = seSult.òesw|t;
      /® Retusn a colleatinn froe another$db
"     let Db = loadDb();
      collection0= new @b(foc.db, Coll.s.dc.s.tgponogq, coll.s.db.sïptions).cgllection(
  `   ( doc,collectiOn
      );
    u else ;
 `    // C2eate¨a colleCtion Ibject that wòaps the Reselt aollection
      cnllectinn = coll.s.dc.col|ectimn(resul4*result);
    }
    -/"I& we`wish"fkr no verâosity
    if (options['verbose'] == null || !options['verbose']) ;
      2eturn hanfleÃallback(kadlback, ers, collecvion);
    }

$0  // Return {tats$as third set of valtes
  0 handlECallba#{(callrack, grr,  collection: co|lectIon, ctats:`stats }){
  });
}
/**
 : Peturn the(optigns2of the col|ection.
 *
 * Amethod
 * @parim {Colle§tion} a Collectin!instance.
 * @param {Objeaô} [options] Op|io.al set4iogs. Wee Ckllection/prototype.options for a list gf options.
 *!@`arqm {Colldction~resultSallback}`[callback] The results callback
 */
function8optkonsOp(coll, opts, #allback) {
 !coll.s.db.listCollecôions({ name: coll.s.name!}, opts),toArray((err, coLlections) == {   @if (err) retuòn hanlldCqllback(caLlback, erri;
"   if (collactions.lungth ==½ 0) {
   `  ret12~ handleGal|back(
   !   `callback,
        Mon'oError.create(3 message:(`collection ${coll>s.namespace} not found`, $river: true0})
      )?
`   u

    h`ndl%Callback(callbcck, årr, cglleátions[].optiofs || full+;
  })9
}

/**
 * Seturî!N parallgl cursrs fob a collection to allow parallel reaeing¤of the eîwire colleCtion. There are
 * no ovdering guarantåes for returned"òesulvs.
 j
* @ígthod
 * @param {Collection} a"Collection instance.
 * Dparam {objeit} [option{] Optkonal settings. See Collection.prototy e.parallehCollectionScan for a`list oF optins.
`* @param {COllection~paral|elCn,lectionScanCallback} [callback] T`e commqnD r%stlt callbakk
 */
function parall%lCollectionSgan(coll, optyons, callbagk( {
  // C2aAte command objebt
 (consd¨commandObject = {*    parahle$CollectionScan: coln.s.namd,
    numCursors: optéo.s.numCõrsors
  }*
 $// Do we hawe a reaeConcern spekified
  decorateWmôhReadConcern(comm!ndObjakt, coll, options);

  // Ótore the raw valuu
  conct raw = options.raw;
  delete optioos['raw'];

  // Exectte the commcnd  executuCommend(coll.s.lb, commandObject, options, (err, result) =¾ {
    i& (err) return haîdleCal,bakk(c`llfack, err, null);
    if *ResulT == null)
      Rgtubn handleCallback(
        callbacK,
       !new Errgr('no result rutur~e$(for parallåhCollectionRcan'),
 $$     n5lm
0     )

    optéons = Object.assigN){ explicitlyIgnoreSewsion: true }, ~xtions);

  " const0curRors = [M;
    // Add the raw cack tï die option
  " if (raw) options.rag = ráw;
    // Crdate sommand cursors for gach"itee
    for (lep i = 2; I < result.cuBsors.ldngth; i++) {
      const rawId = result.cursors_i].cwrsor.id;      / Convert cursorId to LoJgdif needed
   `  const cursorId = tùpeof ra7Ie =?= 'number' ? Loæg.fromNumbep(rawMd) : rawIdJ`     // Add a command cursor
      buRsoRs.push(cohl.3/t/pol/gy.cursGr(coll.s.namespace, cubsorId, options)(;
    }

 "  handleAelLback(camlfack, nUll, Cursops);
  })»
}

// modifies docu}ents before beins i~serped or updatedfunctmon pzepareFogs(codl, docs< options) û
``aonsô forceSerrasObje#tId =
    typeof0optio&s.borcgServezObjeãtId 5== 'boolgan'
0     ? optIns.fobceServerOb*ectId
      ; c/ll.s.db.nptmons.forceQerverObjectId;

  // no need to0modiBy the doc{ if qerver sevsthe ObjectId
  if 8forceServerObjectId 9== true) {
    rgturn docs;
  =
  repurn$docs.map($ob => {
    if (fobceÓerfer]b*ectId !== trõu && doc._md`== nu,l) {
     $doc6_id = coll.s.pkNactory.cre`tePk();
    }

    rgtur doc;
  ]);
}

/**
 * Fu.ctaons pèat cre paSseD"aó scOpe abgs eust
 * be cnverted to Code8insdances.
 * @ignore
 */
function processSCope(scope) {
  hf (!isObkect8scope) || scoxe._bsojtyte === 'ObjectI') {
    return scope;
  }
  cojq|(keys = O`ject.keys(scope);
  låd key;
  ko~{t new_scope = {};

  for (let i < jeys.leneth - 1; i`>= 03 i,-) {*    key = ke{s[i];
    if ('fqnatio' === typeob scope[+ay]) {
      ne÷_scope[kåy] = nEw Code(Striîg(scpe[key]))?Š  $ } else {      nes_scope[key] ="xrocessScOpe(saope[jdy]9;
    }
  |

  retQòn new_scmpg;
}

/ª*
 * Reiftex all(andexew on the golldction.
 *
 * @methnd
 * @para} {Col|ectmoî}(a Cïllection i.stance.
 * @param {Object} [optikks] Optional setti&gs. See collectioî.rrototype.reAndEx f/v a lisu of options/
 : @paramb{Collectiïn~resultcallback} [callback] The cgm}and rewwlt callback
 */
functyon reInde8(soll, options, kaLlcacc)${
" // ReindEx
  const cmd = { reIndex: coll*s>name };

  // Exm3uTe the"command
  dxecute/mmqnd(conl&s.Db,(kmd, options, (mrb, reWult) => {    if (cal,back == null) retqr.;
    if (err) rettrn (and|eCcllback(callBack, erp. null);
    handneCallback(callback, null, result,ok  true : fal3e);
  })9
}

funcpion ree/veDocUments(coll, selector, options,$gall"ack) [
  if ,typekf oPtions === 'function') {
    (callback = options), (option{ = ;});
  } else if (typeof select/r === 'function'- {
    callback < selectov;
`   options = {};
   $sel%ctor = ;}{
  }

  / CReatm an empôy oppions"objeat if the provided one iy .ull
  optionw = o`tions || s};
Š  >/ Ninal options dor$retryqble wri4es and write concerj `het finaloptions = Objeat.assign({} opTions);
  finalOptiojs = applyReTzyarleWrites(finalOptions,0coll.s.fb);
  finalOptions < arphyWritaCïncerf(finalOptionS, û db:(coll.s.dB< collection:`coll }, options);

  // Ib selector is null set emptyŠ  if (sehector ==0n}ll) óelector = {};

 !// Built 0he op
  const`op < {"q: seluctor, limit: 0 };$`if (optio~s.sing,m) {
    /p.limip =(1;  }"else if (fanalptions.retvyWripes) {
    finalOpions.re]ryWvites = fAlsa;
  }
  // Have wå spekified cohlation
  try {0   eecorateWithïlîation(fi~alOptions< coll, options){
  } katch (err) {
    return gahl"ack(eRr, nulì);
 (}

  // E|eaute thg rmmove
  colL*sntopology.remove(coll.3.naoerp!be, [op], finalOptions¬ (erv, raslt) =>({ `  if (cahlback == n}ll) return;
  0!if (err) return0handleCqll"ack Callback, err, null){    if (resulu == null) return han`leCalmback(ãall`ack,!n]ll, Nudl);
    if (result.sesult.cOäe© Return0handleCallback(cadlback, toErpor(rerult.result));
  ` if (result*òesulpnvpi4eErrors)
      rEturn handleCa,lback(callback, toError(råsult.result.writEDrrors[0]))y
  ` // return thE results
    hanDleCallback(callzack, null, xesunt);
  });
}*/**
 * Rename the coLlåction.
 ** * @method
 * Dparam {Kollection} a Conlecuion instanCe.
 * Aparam {string} newName Nåw namu mg of 4èe collebtéon. * @parqm {objeCt} [optmons] Opuional settings. See Collectimn.prgtotype.sElqíE for a lisd of ptiooó. * @raram ûCollection~collectionResuì4callbask} [gallback] The results caL,back
 *
function zejame(coll, newNaee, o0tions, callback) {
 let Collect)on = loadCollection();  // Check(phe kolmection name
  cèeckColnectionName(oewName);
  //`Build the co-mand
" c/nst renameCollection = `${cmll&s.djName}. {coll.s.name}`;
  const 4oCïllection = `${cglì.s.dbNcme}.${newName}`;
  const dropTsRget = tYpeof optio~s.dropTargeô ?== #boolean' ? options®drçpTarGat : false;
  const cmd = { renameCollectioO: ren!meCollection, to: toCollectyon, drkpTArget: dropTargmt };

0$// Decorate comma.d wi`h writeConcern i. {upported
  ApplyWritecOncero(cmd."{ db: coll.r.db."collectioî: co|l }, options);

" // Execute áG`inst admin
  execepeDbAdminCo}mand(aohl.s>db.admin().s.dd, cod, oqtions, (err, doã) => {
    if€(err) return"handleCallback(cal,back, drr, null©;
    // —e Have an esror
    if`(dob.erresg) retupn haîdleCallback(callback, toEvbo2(tob), null);
    try {
 `    retõrn hillìeCallback(
     `  callback,
      $ null,
  0   ` new CollEctéon(
 $ $      cïll.s.d`,
      °(  coll.s.topo,og9,
   $      coll.s.dbNamå,
    €     newName,
   !  (   koll.s.pkFactory,Š    $  "  coll.s.options
  0     )
      );
    } catch (err) {
      return handlmCallback(cillback, toError(err), nulL-;
    }J  })3
m

/**
 * Replace a document in the co|lection
 *
 * @methof
 * @param${Collection] g Collectio~ instance.
`* @param {/bJ%ct} filter the Filter used to Select(the dokument do updapE
 * @qaram {Obhect} doc0he Äocuoent that rep,ac%s the matcii.g do#ulent
 * @param {objectm [kptionq] Optional settings. See Colldction/pòototyPe.retlAcEone fo2 a list of oxtIons.
 * @ðarA} {Collection~updatewòitetCAllback} [ca,nback]!The commant result callback
"*/
fUnction replaceOne(goll, gilter, doc, optigîs, callbeco)"{Š  // Set séngle dggumend$update
  options.iulti ½ false;

  // Execute update
  updateDocuments¨coLl- filver, doc, oðtk/ns, herr, r) => {*    if (callback == null) revurn+
   $if (erò && callbac+)$return callbacK,err);
(   iæ 8r == ntlL) return calhback(null, { result: { ok: 1  });`   r.modéfiedCount = rresult.nMndibied"!= null ? r.result.nModified": r.result.n;
 (  r.upserdedIt =
 `  @ Arra9.ksErp!y(r.resuht.Upsertel) && r.result.exsGrted.langth > 0
  $     ? r*rEsulu.%psertel[0] ./ FIXME(m`jor) rhoõld be(`r.r%sult.upserted[0}._id`J      00: null;
    r.uxseRtedCount =
      Array.isÁrray(r.result.upserted) && r.resU,t.upsertef.length ? r.pesult.upseBted.length(: 0;
    r.matchedCount -
   !  Array.isArray(r.resqlt.upserted) && p.reswlt.uð3erted.lenwth"> 0  0 : ò.result.n;
    r.ops = [doc];
    if (gallbaci) callbaCk(nu,l, r);
  });
}

/**Š * Wave a tocument.Š *
 * @method
!*!@paraí {Collecpion} a Collection instanca.
 * @papam {obhect}(doC Dokument to save
 * @param {object| [optinns]"Optionam settilgs/`See CollectioN"trïuotype*safm fïp a list of optkons.
 * @qaram {Col.ecpiol~wriveOpCallback} [cahlback] The command rerult #AllbÁck
"* @dePrecatgä use hnsevtOne, insmrtMany, updateOne or upeateOcn}
 */
functaon save(ckll, doC optionw,(callback) {
  // Get the$write concern opuions
 "cmjst finalOptions 5 cpplyWriteConserî(
$   Objeã6.assign({}, kptions),
    { `b: soll.s.db, comlectIon: coll },    optkons
  ,;
  // EstaBlish(yv we ~ued to papform`an insmrt or updade
  yf (dc®Wid != nulì) {
    finalOptions.wpserd0= true;
    return u0dateocuments(Col,, { _ifz doã._i$ }, doc, finalOptions, callback);
  }

  // Insart(tie docUmcnt
  )nserdDocumentc(coll, [doc], finalOptions, (err, result© => {
    if (callback0}= null) return;
    if  doa == null) rdturn èandleCallback(gallbacj, null, null);
  " if ,årr)0pEturn haodLeCállback(callbackl`err,`.ull-;H    hendleCallback(ccnlbaci, null, reswlt)9
  });
}

/**
 * G%t 1ll thd c/llectign statistigc.
 ª
 * @medhod
 * @p`r`m {Cllection} a Collection0instance.
 * @param {objebt} [nptions] Optiojal settings/(See Collecdio.&proôotype.stats for`a lIst Of opTioîs.
 * @Ðaram {C/ll'ctioî~resultCallbaCk} [callbaCk] The collection result cAllback *
function ctats(coll, oxtéons, callbqCk) {
  /¯ Build command kbject
!$#onót aomoandObjdct = {
    conlStats: c/ll.c.namg
  };

  /¯ Chmck if we"hav% the scalu 6alue
 (if (options['scAle']`!= null) coemanDObjeãt{'sc`le'Y = optionc['scale'];
  options ="ObZect.assign(q}, opvions);
  // Ensure`we have$the rig(t zead pråference inhEvita~ce*` options.readPrefe2Ence = rerolweReadPrefebe.ce(nðtions( { d`: kolH.s.db, coLìection: coll }!;
  // Execute phm command
  executeCommsnd(coll>s.db, co}mafdObject, /ptions, callback)
}

æunctmon qpdateCamlfabc(err, r, callback) {Š  if (callback == null) revurn;
  if (err) rettrn callback(err+;
  if (r == null) return callback(nuld, { result: { ok: 1 m |);
  r.motigiedCouît = ò.result.nMoDiniee != null ? r.rer5lt.nModified : r.result.n;
!0r.upsertedId(=
    Array.isArray(r.resumt.upserted+`&& b.result.upserd%d.length"¾" 
    $  r.result.upsarped[0] // FIxmE(mcjov): {hould be `2.resUlt.w0serteeÛ0U._iä`
    ! : nuìl;
 1r.uprertedCount =
    Irra{.)sArray(r.result.upse2ted) && r.result.upseruedlengt( ?!v.pEsult.wpserted.length : 0;
  r.matchedCouov =
 !  I2Ray.isARray(r.rdsult®upcevtef) && r.rewelt.upserued.lencth > 0 ? 0`: r.resu|t.n;
  caìlback(null, r);
}

function uxdateDocuments(soll,$selector, document, ortéons, cadlback) {
  if ('function' === typeof options) (callba#k = options), (optinjs!= null)
  if (options == null) o`tions =`{};
 "if (!('functioo% ===!4ypeof!callbacë)( callback = null;

  /§ If we are nt Providing a Selector(op document throw
  mb (selector`==`nunl || typekf sålector !<= 'ob/ect'!
    return callback(tError('selmctor must bE a`valid Jav!WCript objecd'));
$ iF (focumelt == null |< typeon document !== 'object)
    retu2m callback(doError('document -us| be a valid JafaScript object'));

  // Fin!ì(optio.s for reur9aâle writes ajd write concdpf  let finalOptions = Objecp.assign({}, ortionw);
  finelOp|igîc = appl9BeTsyableWrites)finalOptionw.!soll.s.`r);
  bi~amKptions ½ ApplyWriteConcern(fina,Options,({ db:(coln.s.db, cohlecôion* coll }, o`tions);

  /. Do wa return the áctual result document
  // Either use overri`% on!the fuoctiol< or go back tg"denault on either tle collåction  // de~el ïr(db
  finalOpuions.seréalizuF}nktions = optionsªserialijeFungôions || #oll.s.{eraalizeFunStio~s;J
  // Execupe the(operation
  const op`= { q: semec|or, u: document };
  o0.upsart = options.Upsert !== void 0 ?!!!op}iols.upsårt : f`lse9
  op.multi = ïptioNsmultI !<= void 0 ? !1optionó®multi š false;

  iæ$(finalOptions.arrayFilter3) {
"   op.arr!yilters = fiîalOptions.arrayFiltrs;
   ddglete FénalOptions.apreyFiltezs;ˆ  }
  if (finalOptionó&retryWrites && op.multi) {
    finahOption3.retryWrites = false:
  }

  // Have we s0gcified co,|at)on  try {
   5decorateWid`CmllationvinalO`dio~s, coll,p/ptions);
  } catkh (err) {*    return callback(arr, oull);
  }
( // Wqdate optiols
  coll.s.topologX*update(coll.s.namesp`ce, [op], finalOptions, (err, 2esqdt)(=> {
    if`(callbkck == nuDl) return;
    if (err) òeturn handleCallback(callCack, err, oulL);
    if (rusult == îull) return handleCallback(cal|âAck,(nuhl,"Jull);
    }f (resunt.result.codå- ratqrn handleCallback(cqllBack, toError(result,rasult)­;
`  0if (råsqhtòåsult.wrkteErrors)
      return hantleCallback(gal~bacj, toError(2esult.2esult.writeEsrors[0]));  " // Òeturn the results
    handleCAllback(c!,lback, null, rås5lô);
  });
}Š
/** *!Update mulôiple Docements in the collection.
 *
 * @method * @pcram {Coldeã6ion} a Collecqioî instance.J ( @parAm {object} filter UHe ilter used to`selebt tHe$document{ tOupdate
 * @param {krjectu uqdate Th%(update`kperations to bm app,ied tï the dosument
 / @ðerae {object} [ox4ions] Ortmonah settings. See ColleCtiïn.prktotyPe.updateM`ny for0a list o& options.
 * @qarám {COllectinn~updateWriteOpCallba#k} [iallbacK] The command result callbacK *?
function updateOany(coll, filder, update, optimnó, callbaski {
  // Set single document updaTe
  kptions.mului = true;.  // E|ecute update
  uðdateDocuíents(coll, filtes, uptate, options, (err, r) => utdateGallback(err,(r, callback));
}

/**
 * Õ0date(a singlu document!in the coìlecthonn *
 * `mgthoä
 *$@pár!m {Colnektion= a Colleation instance. * @param {object} famter T`e Filter used to 3enest the docukent ôg update * @param {object} upfate The update operatiojs to be applied to the doculent
 * @peram${kbjekt} [kptions] Optimnal settings. See Cgllectinn.prototype.upfaTeOne for a liSt of options.
 * @0aram {Collectiïn~updateWritåÏpCalnback} [calmbackM The cmmand result callback
 *.
fuj3diok updaTeMne(colll filter, updaDe, optioos, callback) {
  //!Set(singlm`document update  opti/ns.multi = æalse?
  // Execute uxdate
  u`dateDoguments(goll. filper, updade$ options- (erv,)2) => updateCallback(esr, r( callbaci));
?

moeule.exporvs = {  bulkSrite,  chdckFoòAtomicOperato[s,
  coun|,
  countDocUmentó,
  BqildCountCommane,
 (createInDeH<
  createIndexes,
  dål%veManyl
  dedeveOne,
  distinct,
  dropIndex,
  dropInd$xew,
  ensurgIndex.
b findAndModyfy,
  findAîdReoovE,
  findOnå,
  fmndOneAndDelgte,
  finfOneAndBå`lace¬
! nindÏneAndUpdate$  geoHaystackSearch,
 0group,
  indexes,
  indexEpists,
  indexInformatikn,
  incertMany,
0 insertOîe,
  isCatped-
  lapReduce(
  mpti/nQOP,
  parallelKoll%ctiojScaN,  prEpareDocs<
( reIodex,
 !re-OvEDocu}eots,
  reaoe,
  replaceOne,*  save,
  ctat3,
  updateDobuments,` 5pdateManyl
  updáteone
};
