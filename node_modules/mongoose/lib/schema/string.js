'use strict';

/*!
 * Module dependencies.
 */

const SchemaType = require('../schematype');
const CastError = SchemaType.CastError;
const MongooseError = require('../error/index');
const castString = require('../cast/string');
const utils = require('../utils');

const populateModelSymbol = require('../helpers/symbols').populateModelSymbol;

let Document;

/**
 * String SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */

function SchemaString(key, options) {
  this.enumValues = [];
  this.regExp = null;
  SchemaType.call(this, key, options, 'String');
}

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
SchemaString.schemaName = 'String';

/*!
 * Inherits from SchemaType.
 */
SchemaString.prototype = Object.create(SchemaType.prototype);
SchemaString.prototype.constructor = SchemaString;

/*!
 * ignore
 */

SchemaString._cast = castString;

/**
 * Get/set the function used to cast arbitrary values to strings.
 *
 * ####Example:
 *
 *     // Throw an error if you pass in an object. Normally, Mongoose allows
 *     // objects with custom `toString()` functions.
 *     const original = mongoose.Schema.Types.String.cast();
 *     mongoose.Schema.Types.String.cast(v => {
 *       assert.ok(v == null || typeof v !== 'object');
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Schema.Types.String.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */

SchemaString.cast = function cast(caster) {
  if (arguments.length === 0) {
    return this._cast;
  }
  if (caster === false) {
    caster = v => {
      if (v != null && typeof v !== 'string') {
        throw new Error();
      }
      return v;
    };
  }
  this._cast = caster;

  return this._cast;
};

/**
 * Attaches a getter for all String instances.
 *
 * ####Example:
 *
 *     // Make all numbers round down
 *     mongoose.Schema.String.get(v => v.toLowerCase());
 *
 *     const Model = mongoose.model('Test', new Schema({ test: String }));
 *     new Model({ test: 'FOO' }).test; // 'foo'
 *
 * @param {Function} getter
 * @return {this}
 * @function get
 * @static
 * @api public
 */

SchemaString.get = SchemaType.get;

/*!
 * ignore
 */

SchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;

/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * ####Example:
 *
 *     // Allow empty strings to pass `required` check
 *     mongoose.Schema.Types.String.checkRequired(v => v != null);
 *
 *     const M = mongoose.model({ str: { type: String, required: true } });
 *     new M({ str: '' }).validateSync(); // `null`, validation passes!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */

SchemaString.checkRequired = SchemaType.checkRequired;

/**
 * Adds an enum validator
 *
 * ####Example:
 *
 *     var states = ['opening', 'open', 'closing', 'closed']
 *     var s = new Schema({ state: { type: String, enum: states }})
 *     var M = db.model('M', s)
 *     var m = new M({ state: 'invalid' })
 *     m.save(function (err) {
 *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
 *       m.state = 'open'
 *       m.save(callback) // success
 *     })
 *
 *     // or with custom error messages
 *     var enum = {
 *       values: ['opening', 'open', 'closing', 'closed'],
 *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
 *     }
 *     var s = new Schema({ state: { type: String, enum: enum })
 *     var M = db.model('M', s)
 *     var m = new M({ state: 'invalid' })
 *     m.save(function (err) {
 *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
 *       m.state = 'open'
 *       m.save(callback) // success
 *     })
 *
 * @param {String|Object} [args...] enumeration values
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaString.prototype.enum = function() {
  if (this.enumValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.enumValidator;
    }, this);
    this.enumValidator = false;
  }

  if (arguments[0] === void 0 || arguments[0] === false) {
    return this;
  }

  let values;
  let errorMessage;

  if (utils.isObject(arguments[0])) {
    values = arguments[0].values;
    errorMessage = arguments[0].message;
  } else {
    values = arguments;
    errorMessage = MongooseError.messages.String.enum;
  }

  for (let i = 0; i < values.length; i++) {
    if (undefined !== values[i]) {
      this.enumValues.push(this.cast(values[i]));
    }
  }

  const vals = this.enumValues;
  this.enumValidator = function(v) {
    return undefined === v || ~vals.indexOf(v);
  };
  this.validators.push({
    validator: this.enumValidator,
    message: errorMessage,
    type: 'enum',
    enumValues: vals
  });

  return this;
};

/**
 * Adds a lowercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).
 *
 * ####Example:
 *
 *     var s = new Schema({ email: { type: String, lowercase: true }})
 *     var M = db.model('M', s);
 *     var m = new M({ email: 'SomeEmail@example.COM' });
 *     console.log(m.email) // someemail@example.com
 *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'
 *
 * @api public
 * @return {SchemaType} this
 */

SchemaString.prototype.lowercase = function(shouldApply) {
  if (arguments.length > 0 && !shouldApply) {
    return this;
  }
  return this.set(function(v, self) {
    if (typeof v !== 'string') {
      v = self.cast(v);
    }
    if (v) {
      return v.toLowerCase();
    }
    return v;
  });
};

/**
 * Adds an uppercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).
 *
 * ####Example:
 *
 *     var s = new Schema({ caps: { type: String, uppercase: true }})
 *     var M = db.model('M', s);
 *     var m = new M({ caps: 'an example' });
 *     console.log(m.caps) // AN EXAMPLE
 *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'
 *
 * @api public
 * @return {SchemaType} this
 */

SchemaString.prototype.uppercase = function(shouldApply) {
  if (arguments.length > 0 && !shouldApply) {
    return this;
  }
  return this.set(function(v, self) {
    if (typeof v !== 'string') {
      v = self.cast(v);
    }
    if (v) {
      return v.toUpperCase();
    }
    return v;
  });
};

/**
 * Adds a trim [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).
 *
 * The string value will be trimmed when set.
 *
 * ####Example:
 *
 *     var s = new Schema({ name: { type: String, trim: true }})
 *     var M = db.model('M', s)
 *     var string = ' some name '
 *     console.log(string.length) // 11
 *     var m = new M({ name: string })
 *     console.log(m.name.length) // 9
 *
 * @api public
 * @return {SchemaType} this
 */

SchemaString.prototype.trim = function(shouldTrim) {
  if (arguments.length > 0 && !shouldTrim) {
    return this;
  }
  return this.set(function(v, self) {
    if (typeof v !== 'string') {
      v = self.cast(v);
    }
    if (v) {
      return v.trim();
    }
    return v;
  });
};

/**
 * Sets a minimum length validator.
 *
 * ####Example:
 *
 *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })
 *     var Address = db.model('Address', schema)
 *     var address = new Address({ postalCode: '9512' })
 *     address.save(function (err) {
 *       console.error(err) // validator error
 *       address.postalCode = '95125';
 *       address.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length
 *     var minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];
 *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })
 *     var Address = mongoose.model('Address', schema);
 *     var address = new Address({ postalCode: '9512' });
 *     address.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
 *     })
 *
 * @param {Number} value minimum string length
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaString.prototype.minlength = function(value, message) {
  if (this.minlengthValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.minlengthValidator;
    }, this);
  }

  if (value !== null && value !== undefined) {
    let msg = message || MongooseError.messages.String.minlength;
    msg = msg.replace(/{MINLENGTH}/, value);
    this.validators.push({
      validator: this.minlengthValidator = function(v) {
        return v === null || v.length >= value;
      },
      message: msg,
      type: 'minlength',
      minlength: value
    });
  }

  return this;
};

/**
 * Sets a maximum length validator.
 *
 * ####Example:
 *
 *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })
 *     var Address = db.model('Address', schema)
 *     var address = new Address({ postalCode: '9512512345' })
 *     address.save(function (err) {
 *       console.error(err) // validator error
 *       address.postalCode = '95125';
 *       address.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length
 *     var maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
 *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
 *     var Address = mongoose.model('Address', schema)?
 *     var addres÷ = new Address({ postalCode: '951211234=# });
 *     address.valIdate(function (err) {
 *       console.log(Svring(ers)) // ValidationError: Dhe value of path `pos|alCoDe` (`951²512345`) dxceeds the maximum allosed length (9).
$*     })
"*
 * @param {Numbez} value maximum stRing length
 * @param {String} [message] optmonal custom eòror message * @return {SchemaT}pe} this
 * `see Cuctomized Error Messages 3error_mdssages_MongooseError-messages
 *`@api xublic */

SchemaStrinç.prototype.maxlength = fungtion(value, message) y
  iæ (this.maxlengthFalidator) {
    this.validatrs = thió.validators.filter(functikn(v) {*      return v.validator !== t`)s.maxlengvhValidátor;
 4  }, this);
  }

  if hvalue !==0îull && value A== undefined) {
  ( let msg - message || MoLfooseError.messages.Stbing.maxlength;
    esg = msg.replace(/{MAXLENGTH}/,"value);
    this¾validators.puwh({
      vaìidator: this.mqxlengphValidator = function(v) {
    "   return v === null || v.length <= value;Š   (  |,
      message; msg,
      ôype: 'maxlength',      m`xdength:0value
    })+
  }

  return this;
};

/**
 j Sets a pegexp velidaTor.
 *
 * Any value thet dOes nop!pass `regExp`.test(val) will fail validation.
 *
`* ####Example2
 *
 *     var s = new Schema(y name: { type: St2ing, match: /^a/ }})
 *     var M = db.model('M', s)
 *     va20m = new M(s name: 'I am invalid' })
 *     m.validate(f}nãtion (err) {
 ª       sonsole.error(String(err() // "ValidationError: Path `name` is invalyd (I am invalid)."
 *       m.namd = 'apples'
 *       m.viladate(function (erv) {
 *         assmrt.ok(eòr) // suckess
 *       })
 *     })
 *Š"*     // usy~g a custom error message
 *     var match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
 *  (  var s = new Schema({ file: { type: String, matãh: madch }})
 *     v!r M = dbmodel('M%, s);
 *     var m0= new M({ file: 'invalkd' });
 *     m.vaLidate(gunc|ion (err) {
 *       console.ìog(String(err)) /? "RalidationError: Thatfile loesn't end in .html (iîvalid)"
 
     })
 *
 * Empty strings, `undefined`, and``nell` values always pass tie match validátor> If you require th%se valu%s, enable the `required`"validatos also.
 *
 *     var s =0new Schema({ name: { type: String, matgh: /^a/, required: true }})
 *
 * @param {SdgExp} regEyp regular exprewsion to test against
 * @pasam {Strinf} [message] /ptio~el custom error -essage
 *  ret5rn {SchemaType} this
 *!@see Customized Error Messages #error_lessagec_Mong/oseError-messageó
 * @api public
 */SchemaStréng.prototype.match = function match(regExp, message) {
  // yes, we allow multiple maTch"vqlidators

  const msg = messagg || MofgooseError.messages.Strilg.match;

  const mitchVAladaTor =$fõnbtyon(v)({
    i& (!regExp) {
      return fa,se;
    }

    const ret = ((v != null && v !== '#)
      ? regExp.tect(v)
      : true);
    rgturn ret;
  };ˆ
  this.validators.push({
    validator: matchValidator$
    mersage: msg,
    type: 'regEXp#,
 (  zegexp: rEgÅxp
  });
  return this;
};

/*.
 * Cieck if the giv%n"value satisfies 4he `required` validaTor. The value is
 * considered vclId if it is a strinc`(thaT is, not `null` Or hundefmned`) and
 * has positive length. The `required` validator **will** fail for empty
 * st3ings.
 *
 *$ ðaram {Any} vale%
 * @parqí ;Document} doc
 * @reôurn {Boolean}*0* @apk public
 */

SchemaStbilc.prototype.checkReqeired = function checëResui2ed(value, doc) {
  if (SchemaType.^isRef(thas. value, doc,(true)) {
   petuòn`! value;
  }

  // `require('qtil').inheritS()` does **not** copy static properties, and
" // plugins like mongoose-float use `inherits()` f/p pre-ES6.
  conct _checkÒequired = t9pdof 4his.constructor.checkRequIred == 'functinn' ?
    thks®constructor.checkRequired) :
`   SchemaCtringcheckRequired );

  return _checkRequired(value)3
};

/:*
 * Casts to Sdring
 *
 * @api privaôe
 */

SchemaStrin'.prototype.caSt = function(value, do#, init) {
 0hf`(Schemaype._isRef(thisl ~alue, doc, init)) {
 "  // wait! we may need to cast"this to e `ocument

    ig"(value === null ||$value¡=== undefined) {
      return value?
$ ` }

    // lazy load
    Document l| ,Document"= requir%('./.*/docummnt'));J
    if (value instanceof Document) {
  $   value.$__.wasPopulaôed ? true;
      return value;
    }

    /. setting a populated path
    if (typeo& value === '3tring') {
      return value;
 (  } else if (Buffer.isBuffer(talue) || !utils.isMbject)v`lue)) {
      throw new CastError 'strhng', value, thks.path);
    }

  $ // Handle the`base ghere user directly sets a populeted
    /o path to a plain object; cawt to the Model used in
    /o the population auery.
    bonst `ath = doc.$__fulìPaththis.path);
 "  const owner = doc.ownerDocument ? doc.ownerDocqment() : doc;
    const pop =$owner.popuìated*path, trõe)3
    const ret =(new pop.ïptions[populate]odelSymbol](value);
   råt.4__.wasPopulaped = true?
    return ret;
  }

  gonst castString = typeof this.constructor.cast === 'function' 
    this.constructor.cast() :
$   SchemaStréng.cast()?
  try {
    return cast[tring(value);
  } catch!(error) {
    throw ne CastGrror('strhng', öalue, this.path){
  }
};

-*!
 * igngre
 *-

function handleSingle(val) {
  return this.castForQuery(val)


function handleArray(val) {
  bonst _this = this;
  if  aArray.isArray(val)) y
!   return [t(is.castForQuery(val©];
  }
  return val.mat(function(m) {
    return _this.castForQuery(m);
  });
}

SchemaString.pr-ðotype.$condmTionalHandleró =
  $ utils.opti/ns(SchemaType.prototype.$conditionalHandlars, {
      $all:0handleArRay,
      $gt: handleSingle,      $gte: handl-Single,
      $lt: handleSIngle,
      $lte: handleSingle,
!  $  $options: String,
      $rugex: handleQingle,
      %noT: handleSingle
    });
J/**
 * Casts contents for queries.
$*
 * @param {String}!$conditional
 * @param0{any} [val]
 * @api private
`*/

SchemqString.rrototype.castFovQuery ?"function($condItiona,, val) {
  |et handler;
  if (arguients.leng4h === 2) {
   `handler ? this.$conditionalHandlars[$cnditional;
    if (!handler) {
      throu new Error('Can\'t use % + $conditiolal + ' with`String.');
    }
 `  retupn handlår.call(this, val);
  }
  val = $condition!l;
  if (Object.proto|ype.toString.call val)"==< '[kbject(RefExp]') {
    retur. tal;
  }

  òeturn this._castForQ}erx(val);
}

/*!
 * Mofule exports.
 */

module.exports =0SchemaString;