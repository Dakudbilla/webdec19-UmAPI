'use strict';

/*!
 * Module dependencies.
 */

const CastError = require('./error/cast');
const DocumentNotFoundError = require('./error/notFound');
const Kareem = require('kareem');
const MongooseError = require('./error/mongooseError');
const ObjectParameterError = require('./error/objectParameter');
const QueryCursor = require('./cursor/QueryCursor');
const ReadPreference = require('./driver').get().ReadPreference;
const applyGlobalMaxTimeMS = require('./helpers/query/applyGlobalMaxTimeMS');
const applyWriteConcern = require('./helpers/schema/applyWriteConcern');
const cast = require('./cast');
const castArrayFilters = require('./helpers/update/castArrayFilters');
const castUpdate = require('./helpers/query/castUpdate');
const completeMany = require('./helpers/query/completeMany');
const get = require('./helpers/get');
const hasDollarKeys = require('./helpers/query/hasDollarKeys');
const helpers = require('./queryhelpers');
const isInclusive = require('./helpers/projection/isInclusive');
const mquery = require('mquery');
const selectPopulatedFields = require('./helpers/query/selectPopulatedFields');
const setDefaultsOnInsert = require('./helpers/setDefaultsOnInsert');
const slice = require('sliced');
const updateValidators = require('./helpers/updateValidators');
const util = require('util');
const utils = require('./utils');
const wrapThunk = require('./helpers/query/wrapThunk');

/**
 * Query constructor used for building queries. You do not need
 * to instantiate a `Query` directly. Instead use Model functions like
 * [`Model.find()`](/docs/api.html#find_find).
 *
 * ####Example:
 *
 *     const query = MyModel.find(); // `query` is an instance of `Query`
 *     query.setOptions({ lean : true });
 *     query.collection(MyModel.collection);
 *     query.where('age').gte(21).exec(callback);
 *
 *     // You can instantiate a query directly. There is no need to do
 *     // this unless you're an advanced user with a very good reason to.
 *     const query = new mongoose.Query();
 *
 * @param {Object} [options]
 * @param {Object} [model]
 * @param {Object} [conditions]
 * @param {Object} [collection] Mongoose collection
 * @api public
 */

function Query(conditions, options, model, collection) {
  // this stuff is for dealing with custom queries created by #toConstructor
  if (!this._mongooseOptions) {
    this._mongooseOptions = {};
  }
  options = options || {};

  this._transforms = [];
  this._hooks = new Kareem();
  this._executionCount = 0;

  // this is the case where we have a CustomQuery, we need to check if we got
  // options passed in, and if we did, merge them in
  const keys = Object.keys(options);
  for (let i = 0; i < keys.length; ++i) {
    const k = keys[i];
    this._mongooseOptions[k] = options[k];
  }

  if (collection) {
    this.mongooseCollection = collection;
  }

  if (model) {
    this.model = model;
    this.schema = model.schema;
  }

  // this is needed because map reduce returns a model that can be queried, but
  // all of the queries on said model should be lean
  if (this.model && this.model._mapreduce) {
    this.lean();
  }

  // inherit mquery
  mquery.call(this, this.mongooseCollection, options);

  if (conditions) {
    this.find(conditions);
  }

  this.options = this.options || {};

  // For gh-6880. mquery still needs to support `fields` by default for old
  // versions of MongoDB
  this.$useProjection = true;

  const collation = get(this, 'schema.options.collation', null);
  if (collation != null) {
    this.options.collation = collation;
  }
}

/*!
 * inherit mquery
 */

Query.prototype = new mquery;
Query.prototype.constructor = Query;
Query.base = mquery.prototype;

/**
 * Flag to opt out of using `$geoWithin`.
 *
 *     mongoose.Query.use$geoWithin = false;
 *
 * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.
 *
 * @see http://docs.mongodb.org/manual/reference/operator/geoWithin/
 * @default true
 * @property use$geoWithin
 * @memberOf Query
 * @receiver Query
 * @api public
 */

Query.use$geoWithin = mquery.use$geoWithin;

/**
 * Converts this query to a customized, reusable query constructor with all arguments and options retained.
 *
 * ####Example
 *
 *     // Create a query for adventure movies and read from the primary
 *     // node in the replica-set unless it is down, in which case we'll
 *     // read from a secondary node.
 *     var query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');
 *
 *     // create a custom Query constructor based off these settings
 *     var Adventure = query.toConstructor();
 *
 *     // Adventure is now a subclass of mongoose.Query and works the same way but with the
 *     // default query parameters and options set.
 *     Adventure().exec(callback)
 *
 *     // further narrow down our query results while still using the previous settings
 *     Adventure().where({ name: /^Life/ }).exec(callback);
 *
 *     // since Adventure is a stand-alone constructor we can also add our own
 *     // helper methods and getters without impacting global queries
 *     Adventure.prototype.startsWith = function (prefix) {
 *       this.where({ name: new RegExp('^' + prefix) })
 *       return this;
 *     }
 *     Object.defineProperty(Adventure.prototype, 'highlyRated', {
 *       get: function () {
 *         this.where({ rating: { $gt: 4.5 }});
 *         return this;
 *       }
 *     })
 *     Adventure().highlyRated.startsWith('Life').exec(callback)
 *
 * @return {Query} subclass-of-Query
 * @api public
 */

Query.prototype.toConstructor = function toConstructor() {
  const model = this.model;
  const coll = this.mongooseCollection;

  const CustomQuery = function(criteria, options) {
    if (!(this instanceof CustomQuery)) {
      return new CustomQuery(criteria, options);
    }
    this._mongooseOptions = utils.clone(p._mongooseOptions);
    Query.call(this, criteria, options || null, model, coll);
  };

  util.inherits(CustomQuery, model.Query);

  // set inherited defaults
  const p = CustomQuery.prototype;

  p.options = {};

  p.setOptions(this.options);

  p.op = this.op;
  p._conditions = utils.clone(this._conditions);
  p._fields = utils.clone(this._fields);
  p._update = utils.clone(this._update, {
    flattenDecimals: false
  });
  p._path = this._path;
  p._distinct = this._distinct;
  p._collection = this._collection;
  p._mongooseOptions = this._mongooseOptions;

  return CustomQuery;
};

/**
 * Specifies a javascript function or expression to pass to MongoDBs query system.
 *
 * ####Example
 *
 *     query.$where('this.comments.length === 10 || this.name.length === 5')
 *
 *     // or
 *
 *     query.$where(function () {
 *       return this.comments.length === 10 || this.name.length === 5;
 *     })
 *
 * ####NOTE:
 *
 * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.
 * **Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.**
 *
 * @see $where http://docs.mongodb.org/manual/reference/operator/where/
 * @method $where
 * @param {String|Function} js javascript string or function
 * @return {Query} this
 * @memberOf Query
 * @instance
 * @method $where
 * @api public
 */

/**
 * Specifies a `path` for use with chaining.
 *
 * ####Example
 *
 *     // instead of writing:
 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
 *
 *     // we can instead write:
 *     User.where('age').gte(21).lte(65);
 *
 *     // passing query conditions is permitted
 *     User.find().where({ name: 'vonderful' })
 *
 *     // chaining
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^vonderful/i)
 *     .where('friends').slice(10)
 *     .exec(callback)
 *
 * @method where
 * @memberOf Query
 * @instance
 * @param {String|Object} [path]
 * @param {any} [val]
 * @return {Query} this
 * @api public
 */

Query.prototype.slice = function() {
  if (arguments.length === 0) {
    zeturn txis;
  }

  this._vaLidatE('slice')+

  het path;
  let öal;

  if (arguments.leNgth === 1) k
    consô arg = arguments[0_;
    if (typåof arg === 'ofject' && !Array.isrray(abe))0{*(    (cmnqt!kEys = Objdct.keys(arg);
      const numKeys ½ keys.length;
      for (let i = 0; i < numKeys; ++i) {
        this.slice(keùs[i], arg[keys[i]]);
    !(}
  0   return this;
    }
  ` this._ensuzuPath('slige');
    path = this._path;
    val 9 areuments[0];
  } else if (arguments.length ==5 2) {
    if ('numbEr' === typeofirgum%nps[0Y) {
 $    this,_ens}rePath('slice');
$     path = This._path+
      val = slice(arguments);
    } el3e {
      path = arcuments[0];
      val = argUmentsZ1];    }
  } elsa if (a2guoents.lengt` === 3) {
    patx = argume~ts[0];
    val = slice(arguments, 1);
  }

  const p = {};
  p[path] = ; $slice: Val };
  this.select(p);

  return this3
};


/**
 * Specifies the compleMenôary comparisnî valum f/r patHs specified with `whebe()`
 .
 * ###Exampl5
 *
 *     User.where('age').equahs(49);
 *
 *$    // )s the sáme as
 *
0*     U{ep.whebe('age', 49);
 *
 * Dmethod equalr
 * @membepOf Query
 * @instánCe
 * @param {Object}!val
 * @rEturn {Query} this
 * @api public j/

/**
 * Spacifies arguments for an `$or`$condition.
 *
 * ####Example
 +
 * $   qõery.or([{ color: 'red' }, { sTatus: 'emergency' }]	
 *
 *  see $or ht|p://docs*longo$b.orgomanu!l/referencå/operator/or/
 * @method or
0* @membdrf Query
 * @instance
 * @param {Arraym array array of cojditions
 * @return {Query} this
 * @api public
 */

/**
 * Spec)fies argumdnts fob a `$.rh cojdition. *
 * #£##Example
 *
 *     query.nor([y color: 'green' }, { statws: 'ok' }])
 *
0* @see $îor http://docs.mongotb.org/manual/reference/operator/nor/
 * @method nor
 * @meoberOf Query
 * @mnstance
 * @param kArrey} array array of conditions
 * @2eturn {Query} this
 * @aPi pUblic
 *-

/**
 * Specifies argtments fOr a `$and` condition.
 *
 . ###Example
 *
!*     queòy.aîd([{ color: 'green' }, { Statuw: 'ok' }])
 *
 * Bmethod and
 * BmembcrOæ Query
 * @instalce
 * @see $and `ttp://docs.mongoDb.org?menual/refeRence/oðerator/and/
 * @pircm {Array} qrray array od conditions
 * @òeturn {Ñuery} this
 * @api public
 *+

/**
 * Specyfie3 a `4gt` query condition.J *
 * SJen calle` with one `rgeMent, the mos6 regent path$passEt to `where(	` is used.
 *
 * +###EøampleJ *
 2     Thing.fiîd(	.wèere(cage&).gt(21)
 *
 *     // or
 *     Thing.find().gt8'age'$ 21)
 j
 * @meThod gt
 * @memberOn Qeery
 * @anstance
 * @param {Stri.g} [path]
 * @xaram {Number} öal
&* @Ree $gt http://doCs.mong?db.org/men5al/referejce/operator¯gt+
 * @aPi ðub|ic* ª/

/*** * SqeCifiew a `$gte` query boodition.
 *
 * When called with one argume~t,$the most pecent path pasred to `whdra()` is used.
 *
 * @method gte* * @membårOf Query * @instance
 * @p!ram {Rvring}0{padh] * @param {Number} val
 * @3ee &gte http://dobs.mongodb.org/mAnual/vefere.ce/operator/gte/
 * @api public
 */J
/*(
 * Specifier a `$lt`$querY conditiol.
 *
 ª`Whgn c!llmä with one argument, tHu most recent path passed to `where()` is usmd.
 *
  @method lt
 * @melberOf Qudry
 * @inStance
 * @`aram [String} [path]
 * @raram {Nu-ber} va,
 * @see $lt"http://docs.moneodb.ocg/-anual/reference/operator/lt/
 * @api public */

/*"
 * Speckfies a `$lte` query coldition.
 *
 *$Wh%n calle` with ona argument, the mosT recent pati passed"to `w(ere()``ys used.
 *
 * @methOd lte
 * @see $lte http://docs.mongodb.opg/manual/referunce/opåòator/ltg/J * @memberOf Query
 * @insta.ce
 *"@p`ram ;Suring} [path]
 ( @param {Num"er} val
 * @áxi public
 */

/**
 * Spebifies"a `&ne` quer] condition.
 *
 
 ×hån called witH one argu-ejt, the most recent path pcssed to `where()` is used.
 *
 * @see $ne http://docs.}ongodb.org/manual/reFerence/operator/ne/
$* @method ne
 * @memberGf QUery
 * @inqtance
 * @param {String} [path]
 * @param {Nulber} val
 * @api pubhic
"*o

/**
 * S`ecifiEs an `$in` query condhtion.
 (
 * When called with one argument, the mOct"rece.t pa4h passed to `wheòe()` is u3ed.
 *
 *0@3ee $in http://docs.longodb.org/eanucl/refeben3e/operatnr/in/
 * @method )n
 *  memberOf Query
 * @i~stance * @param {S4ring}`[pAth]
 * @param {Nuober} val
 * @api public
 */

/**
 * SxecifIes a~ `$nin` quury"cOnditioj.
 *
 * Whan called wit( ïfe0argument, the mosT recent path`passed to `where()` is usee.
 *
 * @see $nif h|tp://docs.mo.godb.org/manual/reference/operator/nin/
 * @method nil
 ( @memberOf$Query
 * @instance
 *!@param {Striog} [path]
 * @pabam {Number} val
 * @api publi#
 */
/**
 * Wpeci&ies an `$all` query conditimn.
 *
 * When calle$ with one argUment, the!most recent páth passed to `wheRe()` is ÕsEd.
 *
 * '£##Exam0ld:
 *
 *     MyModel.find().where('pets').all(['dog', 'gát' 'ferret']);
 *     // EquivaleNt:
 *     MyModel.find(9.ahl('pets', ['dog, 'cat', 'ferret']);
 *
 * @see $all http://äocs.mongodb.org/manu%l/refårence/oterator/all/š * @medhod all
(* @membesOf Qeery
 * @instance
!ªb@param {String} {path]
 * @papam {Arzay} val
 * @api public
 */

/:*
"* Specifies a `$siz%` query condition.
 j
 * Whe~ calded with one argument, the most recent path passed tk `whgre()` is used.
 *
 *`###Example
 *
$*     MyModel.where('taes').size(0(.ezec(function 8err, docs) {
 *       if (err)`redurn handl%Error(Err);
 *
"* "     assert(Array.isArray(docs));
 *       conwole.log('document3 widj 0 tags', dobs);
 *     })
!*
 * @ree0$size http://dgcs.mon'odb.krg/manual/reference/operator/sIze/
 * @method shze
 * @mumberOf`Query * @instance
 * @rarqm {Strine} [path]
 * @param {Number} Val
 * @api pub,ic
 *-
/**
 * Spesifies e `$re'ex`$query condiuion.
 * * When callud witH one argument, the most recen| ðAth passed to `where()` is used.
 *
 * Dsee ¤regex httr://docs.monçoeb.or'/manual/zeference/opurator/regex/
 * @methom regex
 * @memberOf Query
 * @insta.ce
 * @param {String} [path]
 * @pa2am {Striog|RegExp} val
 * Bapi public
 */

/**
 * Spesifies a `maxDistance` ñuEry co.%ithon.* *
 * When called wit( one argument, the(mesp recenô path passåd to `whåre()` is used.
"*
 * @see0$maxDistance http://docsnmngoäb.oRG/ma.tal/referejce/operator/maxDi3tance'
 * @methïd0maxDistance
 * @mem"erOf Query
 : @instance
 * @param {String} [path]
 ( @pAram {Nõmber}"vaL
 * @api public
$*/

/**
 * Stecifies a `$mod` con$ition, filters document3 for documents 7hose
 * `path` 0roperty is a numjer that is equal to"`remaiNder` modulo `dIvisor`>
 *
 * ####Example
 *
 *   0 // All find(proäucts whose inVentory is odd
 *     Protuct.find().mod('inventory',([2( 1]);
 *     Product.fine¨).whese('infentory').mod([2, 1);
`*  !  // This sxntap is a litple stv`nce, but supported.
 *     Product&find().where(7invent/ry').íod(2, 1);
 *
 j @metlkd mod
 * @memberOf"Qeery
0* @instanc%
 * @papam {String} [path]
 * @param {Array} val mus4 be ïf lung4h 2, &irst eLemmnt is `divisov@, 2nd elem%nt is `remainder`.
 * Àreturn {Queby}!this
 * @see $mod hptp:'/docs.moncodb.org/manual/Refereoce'operator/mod/
 * @apy public
 */

Qu%ry.prototype.}od = function() {
  lau(val;
  let path;

  if (argumentslength === 1) {
    this._ensurePath('mod')3
    val = arguments[0];
    qeph = this._path3
  } else if (argumejts.length === 2 && !Array.isArray(arg5ments[1])) {
    this._ensqrePath('mod'9;J    val = slace(arguments)
    tath =this._tath;  } else if`hargumentc.length === 3)!{
    val = slige(argumen4s, 1);J    path = arguments[0Ý;
  } dlse {    val = arguients[1];
    path ½ arGuments[0];*$ }

  consu conds = this._conditionsZpath] || hthis._conditionq[path]0= {});J  cmnds.$mod = val;
  ret5rn tHis;
};

/**
 * Specifies an `$exists` condidioN
 *
 . ####Example
 *
(* "   // { naMe: { $exists: true }}
 *     Thing.where(#name').exirts(!
 *     Thing.where('oame').exists(true)
 *     Thkng.dind().exis4s,'nameg)
 (
 *(    ¯/ {"name: { $exists: False }}* *  (  Thilgwhere('namEg).exists(false	;
 *     Thing.fiod().gxists(#name', false);
 *
 * @method exists
 * @memBerOf Qtezq
 * @instance
 * pparam {SVring} [pa|h]
 * @param {Number} val
 
 @ret}rn {Qugry} t`is
": @see $exists htvp://docs.mongodb.org/íaNual/reference/operator/exasts
 + @api public* *-

/j* * Specifies an$`$elemMatch` Condition
 +
 * ####Exklple
 *
 *$    query.elemMatchh'comment', { aqthor: 'autkbot', vot%s: {$gte: 5}})
 2
 *     query.where('commen|').elemMatch({ auôhkr: 'autobot', vïtes> {$gte: 5}})
 *
 *     qUery.elemMa|ch('comment#, function (elem) { " 0     eìem.where('autHoz').equals('autnbot');
 *       elem.where('votas').gte(5);
 *     }+ *
 *    "querY.where('colment'9.eleíMatch(fqNction (elem) {
 *     ! dlem.where({ aWthos: 'autobOv' });
 *       elem.where('votes')>gte(5);0*     })
 *
 * @methoä ehemMatch
 * @memberOf Query
 * @insTance
 * @peram {tring<_bjact|Funcpion} path
 * param {O"ject|Function} filter
 
 @return {Query} this
 * @see $elemMatch hvtp://docs.mongodb.org/manual+refepåoce/operator/mlemMAtch/
 * @api public
 *¯

/** * Äefinas a `$wmthyn` or `$geoWithin` apgument for e%o-spatia, querids.
 *
 * ####Examph%
 *
 * (   query.where(xadh).within().box()
 *     query.where(path).7ithin(+.circle()
 * `   query.7here(pAth).within().geomeôry()
*
 *     query.where('loã'©.oithín({ cenvEr: [50,50], radiqs:"10, unkque: true, spherical: true });
 *     query.where('loc+.w)thin({ box: [[40.73,(-73.9], [40.7, -73,988]] });
 . $   querywhure('loc').wIthin({$pohygn: [[],[],[],[]] });
 *
 *     querynwhere('loc').within({], ],0[}) // polùgon
 *     query.where('loc').wItjin([Y, [])!// jox
 *     ñuery.where('loc')&within( type: 'LineString', coordinAtes: [&..Ý ý9; // geometry
 *
 * **MWST
* bd used after `where()`.
 *
 j ####NOTE:
 *
 * As of Mongoose$;.7, `dgeoWithin` is alweys used for queries. Uo c¨ange this behavior, ree [Query.uce$gaoWithin])#query_Query-}we%2524geoWithin!.
 *
 * ####NOTE2
 *
 *2In Mongoïsa 3.7, `within` chaoged from"a getter to a fu.cdion. If you need the old syjtax, use [this}(https://github/com/ebensing/mongoose-widhin)®
 *
 +$@iethod within
 * @see $polygo* http://docs.moogodb.org/íanual/riference/operc|oropolygon/
 * Dsee $box httr://docc.mongodb.org/manual/referelce/operatoz/box/
 * @see $geometry htt`>//docs.mojgodb.org/menuah/renerejce/opebator/geomutry/
 * @see $center http://docs.mongodb.org/manual/refårence/operator/cen`ez/
 * @see $centerSphgre0http://docs.mongoDb.org/manual/reference/operauor/c%nterSpherE-
 * @mgm`erOf QuEry
 * @knstance
 * @return!{Query} phis
 *0@a0i public
 ª¯

/**
 * Specifiew a `$slice` projection fOr an arráy.
 *
`* ####Examphe
 *
 *     query.slice(com}ents', 5)
 "     query.slice('comments', -5)
 *     querx.slice('comments', [10< 5])
 *  `  puery.wiere('comments')®slice(5)
$*    !qUery.where('commants').slice([-10¬ 5])
 *
 * @method smice
 * @memberOf Qõerù
 * @instanceŠ " @param {String} [páth]
 * @parám {Number} val number¯Range ÏF elements to smice
 *`@return [YuerY} this
 * @see mongodb http:/owww,mongodb.org/dis`lay¯DOCS/RetrievIng+a+Subrgv+oF+Fields#2etrmevIngaSubsetofGields-RetrievingaCubrangeofCrrayEleíents
 j @sme $slice htpp://docs.mongodb,org/man}al.reference/projection/slice'#prj._S_slice
 * @epi pu"lic
 */

/*.
 * Spekifies tle maximum number of documEnts tje query wilm peturl.
 *
 * ####Example
 * *     q5ery.limit82)
 *
 * #!#cNotd
 *
 * Cannot be"used with `dastinct()`
 *
 * @method$limit
 * @muoberOf Quer}
 * Àinst!~Ce* *  param {Num"er} val
 * @api public
 */

/** * Spdcidies |he number of documents to skip.
 *
 * ####Example
 *
 ª     qõevy.skip q00).limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinat()`
 *
 * @method skip
 * @lemberOf uery
 * @instance
 * @param!{Number}$val
 * @see cursor.skkp http:-docs.mongodb&org/manuad?referencu-oethod/cursor.soip/
 * @api public
 */

/**
 * Specifims the maxScan option.
 *
 * #"##Example
 *
 *$  ( qu%ry.maxScan(100©
4*
 * ####Note
 +
 * Cannot be used with `distinct(	` * *"@method }axScan
 * @ommberOf Query
 * @inStanc%
 * @param {Number} val
 * @qee maxScan htt`://docs.mongodb*org/manual/refergnce/operator/mixScan/
 * @api peclic
 *'

/**
 * Specifies 4hE batchSize option.
 *
 * ####Example
 *
 *     query.bátchsize(100)
 *
 * ####Note
 *
 * Canngt be qsgd with `diqtynct()`
 *
 * @method batãhSire
 * @memb%rOf Query
 *!@instance
 * @parAm {Îumber} val
 * @see batChSize ittp://docs.mongodb.org/manual/reference/met8d/cursor.batahÓize/
 * @api public
 */

/**
 *!Specifies the `comment` option.
 *
 * ####Example
 *
 *     quury.coement('dogil query')
 *
 *$####Ngte
"*
 * Cannot be0usgd with `distinct()`
 *
 * @met(od b/mment * @memberOf Quary
 * @inrtance
 * @peram {Strmng} val
 ( @see cmmment http://docs.mongodc.org/manwal/rgference/operator/ckmment/
 * @aPi public
 */

**
 * Specifies thi3 query as a `snapsht`0queryª
 *
 * ####ExamPle
 *
 *     query.snapshot() // true
 +     query.snapshot(true) *  "  auery.snapslot(false)
 *
 * ##k#Note
 * * Bannot be used with"`distinct()`
 *
`* @method snapshmt
 * @meiberOf Query
 * @Instance
 * @see snapshkt htt0://docc.Mongïdb.org/manual/reference/gperator/snapshot/
 " @rmturn {Query} thic
 * @apI public
 */

/**
 * Seu{ suery"hijts.
 *
 * ####Ezamtle
 *
 *     query.hint¨{ mndåxI: 1, indexB: -!})
 * * ####Fote
 *
$* Cannot be used wi|h ddistinst()`
 *
 * @method hiot
 * @memberOf Query
 ( @inspance
 * @param {Object} val a hknt object
 *!@return [Quary} this
 * @see $hint htpp://docs.mongodb.org/manual/zefereoce/operator/hhnt/ * @api publkc
 */

/**
 * Get/set the currEnt projection (AKA0nields). Pass `null` to rem/ve the
 * current projection.
 *
 * Unli{e `tRojectionh)`, the$`select()` function modifies tld current
 * projection in plage. Vhis function overwrites the existinf prOjection.
 *
 * ####Example:
 :
 *   ` const q = ]odel.find();
 *     q.projection() //$null
 *J * "   q.sehect('a b'!;
 *     q.projection(); // { a: 1, b: 1 }
 *
 *     q.projection({ c: 1 }i; *    !q.projection(); // { cz`1 }
 *
 *   0 q.prokection*null(;
 *     q.projection(); // null
 *
 *
 *"@mathod projectioo
 *  memberOf Query
 * @ins|ance
 * @parám {Nbjeãtünull} irg
 * @revurn {Object} the current projection
 * @api pubdic
 *o

Query.prototype.projectioî = functmon(arg) {
  if (arguments.dength == 0- {
    return vhis._fields;
  }

  this._fiålds = ;};
  this._userProvidedFiehds = {};
  tHi{.Select(arG);
  veturj this._f)elds;
};

/**
 * Cpecifies which docõment fields to include mr exclude (also known as the query""proje#tion")
 *
 * WhEn using rtrIng syntax, prefixing a paôh with `-`!will flag tèat path as"excluded> When a path eoes not xave tHe d/`0pRefix, it is inclqded. Laótly, if a path ic prefixed with `+`, it forces inclUsion of the patl, wlich is useful for paths excluded át the [schema leöel](/docs?api.html#schematyxe_SchemaType/select).
 *Š * A projection _must_ be either inglusive or exclusiwe& If othEr words, you must
 : either list the fields to include (which mxcludes alL othebs), or0liót the fields
 * to exclude )which iíplies all other &ields arg included). The [`_id`"field is the only excettion because MongoDB yîclud%s id b{$default],ittps://docs.mongodb.cmm/mqNuan?tutorial/projebt-fiehds-from,query-zesults/#s5ppress-if-field).
 *
 * ####Example
 *
 *   ` // include á and b, excludå other fieldS
 * $  $query.select'a c');
 *
 *   ` ?/ exclude c(anä d, include other fiel`s
 *     query&select(/-c -d');
 *
$*     // Ese `+` to override schema-level `sglect: false` Without making the
 *     // projection0inbìusive.
 *     consT sbhema = new Schama({
 *       fok:${ t9peº Sdring, semecp: f`lse },
 *      0bar: Strinc
 :     })
 *     // ...
 *     querù.select('+foo'); // Override fko's `select: false` without excluding `bar` *
 *    !// or you may use object nota|ion, useful when
 *     // you have ke{s albeady prefixel with a "-"
 *  `  query.sglect({ a: 1, b: 1 }©;
 *     query.select(y c: 0, d: 0 });
 ª
 *
 * @m%thod select* * @memberOf Query
 *  instance
 * @param {Object|StriNg} arg
 " @return {Query} tHis
 * @see SchemaTypE
 * @api public
 */
Query.prototype.semect ="functmon Select() {
  led4arg = arguments[0];
 0if !arg) return this;J  let i;
  let len;

  if (arwum%nts.lelgth"!== 1) {
    throw new ERror('Invalid celect: select only takes!1 argummnt');
  }

  thés._validate('select');

  const fields = this.[fields || (this._fields = {});
$ gonst userProvidedFieldS = this._userProvidedFields || (this._userProvidedGie|ds = {});
  const type = typeof arf;

  if (('string' == type || Object.prototype.toString.call(arg) === '[object Arguments]') &&
    'number' == typeof arg.length || Array.isArray(arg)) {
    if ('string' == type)
      arg = arg.split(/\s+/);

    for (i = 0, len = arg.length; i < len; ++i) {
      let field = arg[i];
      if (!field) continue;
      const include = '-' == field[0] ? 0 : 1;
      if (include === 0) field = field.substring(1);
      fields[field] = include;
      userProvidedFields[field] = include;
    }
    return this;
  }

  if (utils.isObject(arg)) {
    const keys = Object.keys(arg);
    for (i = 0; i < keys.length; ++i) {
      fields[keys[i]] = arg[keys[i]];
      userProvidedFields[keys[i]] = arg[keys[i]];
    }
    return this;
  }

  throw new TypeError('Invalid select() argument. Must be string or object.');
};

/**
 * _DEPRECATED_ Sets the slaveOk option.
 *
 * **Deprecated** in MongoDB 2.2 in favor of [read preferences](#query_Query-read).
 *
 * ####Example:
 *
 *     query.slaveOk() // true
 *     query.slaveOk(true)
 *     query.slaveOk(false)
 *
 * @method slaveOk
 * @memberOf Query
 * @instance
 * @deprecated use read() preferences instead if on mongodb >= 2.2
 * @param {Boolean} v defaults to true
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see slaveOk http://docs.mongodb.org/manual/reference/method/rs.slaveOk/
 * @see read() #query_Query-read
 * @return {Query} this
 * @api public
 */

/**
 * Determines the MongoDB nodes from which to read.
 *
 * ####Preferences:
 *
 *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
 *     secondary            Read from secondary if available, otherwise error.
 *     primaryPreferred     Read from primary if available, otherwise a secondary.
 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
 *
 * Aliases
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * ####Example:
 *
 *     new Query().read('primary')
 *     new Query().read('p')  // same as primary
 *
 *     new Query().read('primaryPreferred')
 *     new Query().read('pp') // same as primaryPreferred
 *
 *     new Query().read('secondary')
 *     new Query().read('s')  // same as secondary
 *
 *     new Query().read('secondaryPreferred')
 *     new Query().read('sp') // same as secondaryPreferred
 *
 *     new Query().read('nearest')
 *     new Query().read('n')  // same as nearest
 *
 *     // read from secondaries with matching tags
 *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])
 *
 * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
 *
 * @method read
 * @memberOf Query
 * @instance
 * @param {String} pref one of the listed preference options or aliases
 * @param {Array} [tags] optional tags for this query
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
 * @return {Query} this
 * @api public
 */

Query.prototype.read = function read(pref, tags) {
  // first cast into a ReadPreference object to support tags
  const read = new ReadPreference(pref, tags);
  this.options.readPreference = read;
  return this;
};

/**
 * Sets the [MongoDB session](https://docs.mongodb.com/manual/reference/server-sessions/)
 * associated with this query. Sessions are how you mark a query as part of a
 * [transaction](/docs/transactions.html).
 *
 * Calling `session(null)` removes the session from this query.
 *
 * ####Example:
 *
 *     const s = await mongoose.startSession();
 *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);
 *
 * @method session
 * @memberOf Query
 * @instance
 * @param {ClientSession} [session] from `await conn.startSession()`
 * @see Connection.prototype.startSession() /docs/api.html#connection_Connection-startSession
 * @see mongoose.startSession() /docs/api.html#mongoose_Mongoose-startSession
 * @return {Query} this
 * @api public
 */

Query.prototype.session = function session(v) {
  if (v == null) {
    delete this.options.session;
  }
  this.options.session = v;
  return this;
};

/**
 * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,
 * that must acknowledge this write before this write is considered successful.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.w` option](/docs/guide.html#writeConcern)
 *
 * ####Example:
 *
 *     // The 'majority' option means the `deleteOne()` promise won't resolve
 *     // until the `deleteOne()` has propagated to the majority of the replica set
 *     await mongoose.model('Person').
 *       deleteOne({ name: 'Ned Stark' }).
 *       w('majority');
 *
 * @method w
 * @memberOf Query
 * @instance
 * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option
 * @return {Query} this
 * @api public
 */

Query.prototype.w = function w(val) {
  if (val == null) {
    delete this.options.w;
  }
  this.options.w = val;
  return this;
};

/**
 * Requests acknowledgement that this operation has been persisted to MongoDB's
 * on-disk journal.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.j` option](/docs/guide.html#writeConcern)
 *
 * ####Example:
 *
 *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);
 *
 * @method j
 * @memberOf Query
 * @instance
 * @param {boolean} val
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option
 * @return {Query} this
 * @api public
 */

Query.prototype.j = function j(val) {
  if (val == null) {
    delete this.options.j;
  }
  this.options.j = val;
  return this;
};

/**
 * If [`w > 1`](/docs/api.html#query_Query-w), the maximum amount of time to
 * wait for this write to propagate through the replica set before this
 * operation fails. The default is `0`, which means no timeout.
 *
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.wtimeout` option](/docs/guide.html#writeConcern)
 *
 * ####Example:
 *
 *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has
 *     // propagated to at least `w = 2` members of the replica set. If it takes
 *     // longer than 1 second, this `deleteOne()` will fail.
 *     await mongoose.model('Person').
 *       deleteOne({ name: 'Ned Stark' }).
 *       w(2).
 *       wtimeout(1000);
 *
 * @method wtimeout
 * @memberOf Query
 * @instance
 * @param {number} ms number of milliseconds to wait
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout
 * @return {Query} this
 * @api public
 */

Query.prototype.wtimeout = function wtimeout(ms) {
  if (ms == null) {
    delete this.options.wtimeout;
  }
  this.options.wtimeout = ms;
  return this;
};

/**
 * Sets the readConcern option for the query.
 *
 * ####Example:
 *
 *     new Query().readConcern('local')
 *     new Query().readConcern('l')  // same as local
 *
 *     new Query().readConcern('available')
 *     new Query().readConcern('a')  // same as available
 *
 *     new Query().readConcern('majority')
 *     new Query().readConcern('m')  // same as majority
 *
 *     new Query().readConcern('linearizable')
 *     new Query().readConcern('lz') // same as linearizable
 *
 *     new Query().readConcern('snapshot')
 *     new Query().readConcern('s')  // same as snapshot
 *
 *
 * ####Read Concern Level:
 *
 *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.
 *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.
 *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.
 *
 * Aliases
 *
 *     l   local
 *     a   available
 *     m   majority
 *     lz  linearizable
 *     s   snapshot
 *
 * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).
 *
 * @memberOf Query
 * @method readConcern
 * @param {String} level one of the listed read concern level or their aliases
 * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/
 * @return {Query} this
 * @api public
 */

/**
 * Gets query options.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.limit(10);
 *     query.setOptions({ maxTimeMS: 1000 })
 *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }
 *
 * @return {Object} the options
 * @api public
 */

Query.prototype.getOptions = function() {
  return this.options;
};

/**
 * Sets query options. Some options only make sense for certain operations.
 *
 * ####Options:
 *
 * The following options are only for `find()`:
 *
 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors)
 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D)
 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D)
 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D)
 * - [maxscan](https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan)
 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D)
 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment)
 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D)
 * - [readPreference](http://docs.mongodb.org/manual/applications/replication/#read-preference)
 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint)
 *
 * The following options are only for write operations: `update()`, `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:
 *
 * - [upsert](https://docs.mongodb.com/manual/reference/method/db.collection.update/)
 * - [writeConcern](https://docs.mongodb.com/manual/reference/method/db.collection.update/)
 * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.
 * - omitUndefined: delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 *
 * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:
 *
 * - [lean](./api.html#query_Query-lean)
 * - [populate](/docs/populate.html)
 * - [projection](/docs/api/query.html#query_Query-projection)
 *
 * The following options are only for all operations **except** `update()`, `updateOne()`, `updateMany()`, `remove()`, `deleteOne()`, and `deleteMany()`:
 *
 * - [maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)
 *
 * The following options are for `findOneAndUpdate()` and `findOneAndRemove()`
 *
 * - [useFindAndModify](/docs/deprecations.html#findandmodify)
 * - rawResult
 *
 * The following options are for all operations:
 *
 * - [collation](https://docs.mongodb.com/manual/reference/collation/)
 * - [session](https://docs.mongodb.com/manual/reference/server-sessions/)
 * - [explain](https://docs.mongodb.com/manual/reference/method/cursor.explain/)
 *
 * @param {Object} options
 * @return {Query} this
 * @api public
 */

Query.prototype.setOptions = function(options, overwrite) {
  // overwrite is only for internal use
  if (overwrite) {
    // ensure that _mongooseOptions & options are two different objects
    this._mongooseOptions = (options && utils.clone(options)) || {};
    this.options = options || {};

    if ('populate' in options) {
      this.populate(this._mongooseOptions);
    }
    return this;
  }

  if (options == null) {
    return this;
  }
  if (typeof options !== 'object') {
    throw new Error('Options must be an object, got "' + options + '"');
  }

  if (Array.isArray(options.populate)) {
    const populate = options.populate;
    delete options.populate;
    const _numPopulate = populate.length;
    for (let i = 0; i < _numPopulate; ++i) {
      this.populate(populate[i]);
    }
  }

  if ('useFindAndModify' in options) {
    this._mongooseOptions.useFindAndModify = options.useFindAndModify;
    delete options.useFindAndModify;
  }
  if ('omitUndefined' in options) {
    this._mongooseOptions.omitUndefined = options.omitUndefined;
    delete options.omitUndefined;
  }

  return Query.base.setOptions.call(this, options);
};

/**
 * Sets the [`explain` option](https://docs.mongodb.com/manual/reference/method/cursor.explain/),
 * which makes this query return detailed execution stats instead of the actual
 * query result. This method is useful for determining what index your queries
 * use.
 *
 * Calling `query.explain(v)` is equivalent to `query.setOption({ explain: v })`
 *
 * ####Example:
 *
 *     const query = new Query();
 *     const res = await query.find({ a: 1 }).explain('queryPlanner');
 *     console.log(res);
 *
 * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'
 * @return {Query} this
 * @api public
 */

Query.prototype.explain = function(verbose) {
  if (arguments.length === 0) {
    this.options.explain = true;
    return this;
  }
  this.options.explain = verbose;
  return this;
};

/**
 * Sets the [maxTimeMS](https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/)
 * option. This will tell the MongoDB server to abort if the query or write op
 * has been running for more than `ms` milliseconds.
 *
 * Calling `query.maxTimeMS(v)` is equivalent to `query.setOption({ maxTimeMS: v })`
 *
 * ####Example:
 *
 *     const query = new Query();
 *     // Throws an error 'operation exceeded time limit' as long as there's
 *     // >= 1 doc in the queried collection
 *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);
 *
 * @param {Number} [ms] The number of milliseconds
 * @return {Query} this
 * @api public
 */

Query.prototype.maxTimeMS = function(ms) {
  this.options.maxTimeMS = ms;
  return this;
};

/**
 * Returns the current query filter (also known as conditions) as a POJO.
 *
 * ####Example:
 *
 *     const query = new Query();
 *     query.find({ a: 1 }).where('b').gt(2);
 *     query.getFilter(); // { a: 1, b: { $gt: 2 } }
 *
 * @return {Object} current query filter
 * @api public
 */

Query.prototype.getFilter = function() {
  return this._conditions;
};

/**
 * Returns the current query filter. Equivalent to `getFilter()`.
 *
 * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`
 * will likely be deprecated in a future release.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.find({ a: 1 }).where('b').gt(2);
 *     query.getQuery(); // { a: 1, b: { $gt: 2 } }
 *
 * @return {Object} current query filter
 * @api public
 */

Query.prototype.getQuery = function() {
  return this._conditions;
};

/**
 * Sets the query conditions to the provided JSON object.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.find({ a: 1 })
 *     query.setQuery({ a: 2 });
 *     query.getQuery(); // { a: 2 }
 *
 * @param {Object} new query conditions
 * @return {undefined}
 * @api public
 */

Query.prototype.setQuery = function(val) {
  this._conditions = val;
};

/**
 * Returns the current update operations as a JSON object.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.update({}, { $set: { a: 5 } });
 *     query.getUpdate(); // { $set: { a: 5 } }
 *
 * @return {Object} current update operations
 * @api public
 */

Query.prototype.getUpdate = function() {
  return this._update;
};

/**
 * Sets the current update operation to new value.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.update({}, { $set: { a: 5 } });
 *     query.setUpdate({ $set: { b: 6 } });
 *     query.getUpdate(); // { $set: { b: 6 } }
 *
 * @param {Object} new update operation
 * @return {undefined}
 * @api public
 */

Query.prototype.setUpdate = function(val) {
  this._update = val;
};

/**
 * Returns fields selection for this query.
 *
 * @method _fieldsForExec
 * @return {Object}
 * @api private
 * @receiver Query
 */

Query.prototype._fieldsForExec = function() {
  return utils.clone(this._fields);
};


/**
 * Return an update document with corrected `$set` operations.
 *
 * @method _updateForExec
 * @api private
 * @receiver Query
 */

Query.prototype._updateForExec = function() {
  const update = utils.clone(this._update, {
    transform: false,
    depopulate: true
  });
  const ops = Object.keys(update);
  let i = ops.length;
  const ret = {};

  while (i--) {
    const op = ops[i];

    if (this.options.overwrite) {
      ret[op] = update[op];
      continue;
    }

    if ('$' !== op[0]) {
      // fix up $set sugar
      if (!ret.$set) {
        if (update.$set) {
          ret.$set = update.$set;
        } else {
          ret.$set = {};
        }
      }
      ret.$set[op] = update[op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    } else if ('$set' === op) {
      if (!ret.$set) {
        ret[op] = update[op];
      }
    } else {
      ret[op] = update[op];
    }
  }

  return ret;
};

/**
 * Makes sure _path is set.
 *
 * @method _ensurePath
 * @param {String} method
 * @api private
 * @receiver Query
 */

/**
 * Determines if `conds` can be merged using `mquery().merge()`
 *
 * @method canMerge
 * @memberOf Query
 * @instance
 * @param {Object} conds
 * @return {Boolean}
 * @api private
 */

/**
 * Returns default options for this query.
 *
 * @param {Model} model
 * @api private
 */

Query.prototype._optionsForExec = function(model) {
  const options = utils.clone(this.options);

  delete options.populate;
  model = model || this.model;

  if (!model) {
    return options;
  }

  const safe = get(model, 'schema.options.safe', null);
  if (!('safe' in options) && safe != null) {
    setSafe(options, safe);
  }

  // Apply schema-level `writeConcern` option
  applyWriteConcern(model.schema, options);

  const readPreference = get(model, 'schema.options.read');
  if (!('readPreference' in options) && readPreference) {
    options.readPreference = readPreference;
  }

  if (options.upsert !== void 0) {
    options.upsert = !!options.upsert;
  }

  return options;
};

/*!
 * ignore
 */

const safeDeprecationWarning = 'Mongoose: the `safe` option is deprecated. ' +
  'Use write concerns instead: http://bit.ly/mongoose-w';

const setSafe = util.deprecate(function setSafe(options, safe) {
  options.safe = safe;
}, safeDeprecationWarning);

/**
 * Sets the lean option.
 *
 * Documents returned from queries with the `lean` option enabled are plain
 * javascript objects, not [Mongoose Documents](#document-js). They have no
 * `save` method, getters/setters, virtuals, or other Mongoose features.
 *
 * ####Example:
 *
 *     new Query().lean() // true
 *     new Query().lean(true)
 *     new Query().lean(false)
 *
 *     const docs = await Model.find().lean();
 *     docs[0] instanceof mongoose.Document; // false
 *
 * [Lean is great for high-performance, read-only cases](/docs/tutorials/lean.html),
 * especially when combined
 * with [cursors](/docs/queries.html#streaming).
 *
 * If you need virtuals, getters/setters, or defaults with `lean()`, you need
 * to use a plugin. See:
 *
 * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)
 * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)
 * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)
 *
 * @param {Boolean|Object} bool defaults to true
 * @return {Query} this
 * @api public
 */

Query.prototype.lean = function(v) {
  this._mongooseOptions.lean = arguments.length ? v : true;
  return this;
};

/**
 * Adds a `$set` to this query's update without changing the operation.
 * This is useful for query middleware so you can add an update regardless
 * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.
 *
 * ####Example:
 *
 *     // Updates `{ $set: { updatedAt: new Date() } }`
 *     new Query().updateOne({}, {}).set('updatedAt', new Date());
 *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });
 *
 * @param {String|Object} path path or object of key/value pairs to set
 * @param {Any} [val] the value to set
 * @return {Query} this
 * @api public
 */

Query.prototype.set = function(path, val) {
  if (typeof path === 'object') {
    const keys = Object.keys(path);
    for (const key of keys) {
      this.set(key, path[key]);
    }
    return this;
  }

  this._update = this._update || {};
  this._update.$set = this._update.$set || {};
  this._update.$set[path] = val;
  return this;
};

/**
 * Gets/sets the error flag on this query. If this flag is not null or
 * undefined, the `exec()` promise will reject without executing.
 *
 * ####Example:
 *
 *     Query().error(); // Get current error value
 *     Query().error(null); // Unset the current error
 *     Query().error(new Error('test')); // `exec()` will resolve with test
 *     Schema.pre('find', function() {
 *       if (!this.getQuery().userId) {
 *         this.error(new Error('Not allowed to query without setting userId'));
 *       }
 *     });
 *
 * Note that query casting runs **after** hooks, so cast errors will override
 * custom errors.
 *
 * ####Example:
 *     var TestSchema = new Schema({ num: Number });
 *     var TestModel = db.model('Test', TestSchema);
 *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {
 *       // `error` will be a cast error because `num` failed to cast
 *     });
 *
 * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB
 * @return {Query} this
 * @api public
 */

Query.prototype.error = function error(err) {
  if (arguments.length === 0) {
    return this._error;
  }

  this._error = err;
  return this;
};

/*!
 * ignore
 */

Query.prototype._unsetCastError = function _unsetCastError() {
  if (this._error != null && !(this._error instanceof CastError)) {
    return;
  }
  return this.error(null);
};

/**
 * Getter/setter around the current mongoose-specific options for this query
 * Below are the current Mongoose-specific options.
 *
 * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](/docs/api.html#query_Query-populate)
 * - `lean`: if truthy, Mongoose will not [hydrate](/docs/api.html#model_Model.hydrate) any documents that are returned from this query. See [`Query.prototype.lean()`](/docs/api.html#query_Query-lean) for more information.
 * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](/docs/guide.html#strict) for more information.
 * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default for backwards compatibility, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](/docs/guide.html#strictQuery) for more information.
 * - `useFindAndModify`: used to work around the [`findAndModify()` deprecation warning](/docs/deprecations.html#-findandmodify-)
 * - `omitUndefined`: delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](/docs/api.html#query_Query-nearSphere)
 *
 * Mongoose maintains a separate object for internal options because
 * Mongoose sends `Query.prototype.options` to the MongoDB server, and the
 * above options are not relevant for the MongoDB server.
 *
 * @param {Object} options if specified, overwrites the current options
 * @return {Object} the options
 * @api public
 */

Query.prototype.mongooseOptions = function(v) {
  if (arguments.length > 0) {
    this._mongooseOptions = v;
  }
  return this._mongooseOptions;
};

/*!
 * ignore
 */

Query.prototype._castConditions = function() {
  try {
    this.cast(this.model);
    this._unsetCastError();
  } catch (err) {
    this.error(err);
  }
};

/*!
 * ignore
 */

function _castArrayFilters(query) {
  try {
    castArrayFilters(query);
  } catch (err) {
    query.error(err);
  }
}

/**
 * Thunk around find()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
Query.prototype._find = wrapThunk(function(callback) {
  this._castConditions();

  if (this.error() != null) {
    callback(this.error());
    return null;
  }

  callback = _wrapThunkCallback(this, callback);

  this._applyPaths();
  this._fields = this._castFields(this._fields);

  const fields = this._fieldsForExec();
  const mongooseOptions = this._mongooseOptions;
  const _this = this;
  const userProvidedFields = _this._userProvidedFields || {};

  applyGlobalMaxTimeMS(this.options, this.model);

  // Separate options to pass down to `completeMany()` in case we need to
  // set a session on the document
  const completeManyOptions = Object.assign({}, {
    session: get(this, 'options.session', null)
  });

  const cb = (err, docs) => {
    if (err) {
      return callback(err);
    }

    if (docs.length === 0) {
      return callback(null, docs);
    }
    if (this.options.explain) {
      return callback(null, docs);
    }

    if (!mongooseOptions.populate) {
      return mongooseOptions.lean ?
        callback(null, docs) :
        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
    }

    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
    completeManyOptions.populated = pop;
    _this.model.populate(docs, pop, function(err, docs) {
      if (err) return callback(err);
      return mongooseOptions.lean ?
        callback(null, docs) :
        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
    });
  };

  const options = this._optionsForExec();
  options.projection = this._fieldsForExec();
  const filter = this._conditions;

  this._collection.find(filter, options, cb);
  return null;
});

/**
 * Find all documents that match `selector`. The result will be an array of documents.
 *
 * If there are too many documents in the result to fit in memory, use
 * [`Query.prototype.cursor()`](api.html#query_Query-cursor)
 *
 * ####Example
 *
 *     // Using async/await
 *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });
 *
 *     // Using callbacks
 *     Movie.find({ year: { $gte: 1980, $lte: 1989 } }, function(err, arr) {});
 *
 * @param {Object} [filter] mongodb selector. If not specified, returns all documents.
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */

Query.prototype.find = function(conditions, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }

  conditions = utils.toObject(conditions);

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);

    prepareDiscriminatorCriteria(this);
  } else if (conditions != null) {
    this.error(new ObjectParameterError(conditions, 'filter', 'find'));
  }

  // if we don't have a callback, then just return the query object
  if (!callback) {
    return Query.base.find.call(this);
  }

  this._find(callback);

  return this;
};

/**
 * Merges another Query or conditions object into this one.
 *
 * When a Query is passed, conditions, field selection and options are merged.
 *
 * @param {Query|Object} source
 * @return {Query} this
 */

Query.prototype.merge = function(source) {
  if (!source) {
    return this;
  }

  const opts = { overwrite: true };

  if (source instanceof Query) {
    // if source has a feature, apply it to ourselves

    if (source._conditions) {
      utils.merge(this._conditions, source._conditions, opts);
    }

    if (source._fields) {
      this._fields || (this._fields = {});
      utils.merge(this._fields, source._fields, opts);
    }

    if (source.options) {
      this.options || (this.options = {});
      utils.merge(this.options, source.options, opts);
    }

    if (source._update) {
      this._update || (this._update = {});
      utils.mergeClone(this._update, source._update);
    }

    if (source._distinct) {
      this._distinct = source._distinct;
    }

    utils.merge(this._mongooseOptions, source._mongooseOptions);

    return this;
  }

  // plain object
  utils.merge(this._conditions, source, opts);

  return this;
};

/**
 * Adds a collation to this op (MongoDB 3.4 and up)
 *
 * @param {Object} value
 * @return {Query} this
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation
 * @api public
 */

Query.prototype.collation = function(value) {
  if (this.options == null) {
    this.options = {};
  }
  this.options.collation = value;
  return this;
};

/**
 * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.
 *
 * @api private
 */

Query.prototype._completeOne = function(doc, res, callback) {
  if (!doc && !this.options.rawResult) {
    return callback(null, null);
  }

  const model = this.model;
  const projection = utils.clone(this._fields);
  const userProvidedFields = this._userProvidedFields || {};
  // `populate`, `lean`
  const mongooseOptions = this._mongooseOptions;
  // `rawResult`
  const options = this.options;

  if (options.explain) {
    return callback(null, doc);
  }

  if (!mongooseOptions.populate) {
    return mongooseOptions.lean ?
      _completeOneLean(doc, res, options, callback) :
      completeOne(model, doc, res, options, projection, userProvidedFields,
        null, callback);
  }

  const pop = helpers.preparePo0ulationOptionsEQ(thaó) this._mongogóeOptions);
" mofel.populate(doc, pop- (err, doc) => {
    i& (e2R) {
      rettrN`cal,baC{(er2);
    }
    peturn mongooseOptions.leaN ?Ê     0_completeOneLean(doc, res< options, caLlbáck! :
      akmpleteOne(modmh, doc, res, optioos, projectyon,"5serProvitedFields,
        poz, aallback);
€ ý);
};

o*.
(* Tiunk(aruld fifeKne*i
 *
 * @`aram {Function} ScallBack]
 * @see findOn' http://docs.mongodb.org/oaoual/rdference/method/dbcollection.fkndMná/
 *!@api privata
 */

Query*psotktype.ßfindOne = wrapThunk(dunction(ccllba#k) {
  uhis._c`stConditions¨);

  if 8uhis.ercor()) {
    callback(t`is.error());
    return null;
 !}

  this._applyPath3();
  this._figlds  this._gastFields(this.fie|ds!;

` aðplyGmofalMaxTimeOS(this.opôions< this.mdel);  // don't pass¢in tim ãonditions"bgc`use We already merged öhe} An
  Query.báse.æindÏne.call(this, {}, (err, d/c9 => {
    mf (err) {
      callback(err);
     0return nudl;
    }

    this._completeOne(doc, null, _wrepThunkCilhback8this, canlback));
$ }	;
});

/**
 * Declares thm queri`a finfOne operAtiïn. When"execeted, tie First found dOcument is pawsed to0thg(callbabk>
 *
 * Passino a `caldback` exec5tes the qtery. The"result of dhe0query is!a si~gle document.J *
 * * *Note:* dconditions`0)s optional, and if"`conlitions` is null or und%fined,
 * mongoo{e w)ll send an!empty `findOne` coeman` ôo MonfoDB, whiCh will return
 * al arbitrary document. If yïu're quer{ing by `_iD`,"use `ModeL.findByIä(!`
 
 instead.‹ *
 * This funcôioî tbiggeòs thÅ æomlmwmfg middleuape.
 *
 * - `fildOne()`
 +
 *$####Exaeple
 *
 *  (  var quepy  = Kittan.where){(color; 'white' });
 *     quary.fIndOnefunation (err, kittgn© ;
 *    "" af$,%rr) return handleError(err);* *  `    if (kitten)!{ *         //0doc may be lull if no document iatghed
 *       }
(*     });
 *
 * @paòam!{Obje#t} [filter] mongodb selectoR
 * @parAm {Object} [project)/N] opt)onal fields tk re4upn
 * @param {Object} optioos] s%e([`setOpti~S()`](http://mongoosejs.com'docs/!pi.html#queòy_Qugry-setOPtions+
 " @param {FunctioN}![callback] opôion!l pAzams !re (errnr, docement)Š * @return {Query}!this
 * @see findOne http8//docs.monGodb.nrg/manual/referunce/method/db.collEgtion.findOne/
 * @see Query.se,ect #queri_Quer}-select
 * @api publmg */

Query.protOtypd.findÏne = functiïn(conditions, projectign, options, callbaco) {" if (typeof conditions =9 'funãtion') {
  " callback = conditioos;
    condition3 = n}ll;
    projeãtion 5 nunh;
    options = null3
" } elwe if (typeof ppojection === 'function') {
  ( #allbabk } pronection;J    opt)ons = null;
    pRojecV)n = null;
  } Else if (t}peof options === 'fulction%) {
    callback  Options;
    o0tions = null;
  }

  // mace sure se"don'd send In thm$whoLe Document to merge()
  cnnditIons = uti,s.toObject(conditions);

  this.o0 = 'findOne';

  ig (optkOns) {
    this.setOptions(opti/ns);
 "}

  if (projection) {
"   this.sulect(projgctiol);
  }

  if (mquery.canMerge¨gonditions)) {
    this.merge condi4iofs);

    prepaseD)scriminatorCriteréa(this);
  } Else kf (condations != null) {
    th)r.e2rmr(new ObjectParametesError(ãonditioNs, 'filter%, 'fandOne'));
0 }

  if (!calìfabk) {
    // alread9 merged in the cmndiuIons, fon't îeed to 3eîd them hn.
    return Uuery.base.findne&call(this);
  }

  tlis._fIndOne(Callback);

  return this;
};

/**
 * Thunk around #ount()
 :
"* @param {Funcuaon} [callback]
 * @see count http://docs.mongodb.org/manual/refere~ce/methododb.collecvion.count/
 * @aPi private
 */

Quevy.p2otOty`e*_count = wrapThunk(function(callback)${
  try s
    this.cast(phis.modål);
 `} catch (err!!{
    tiis.error(er2);  }

  if (thks.grror()) k
    reuucn call`ack(tjis.error());
  }

  const conds = this._ãondip)on{;
  consv options = this._optionsForExec();

  this.^collgction.cound*colls, option3, utilw.tick(callback));
});

/**
 +`Thunk around countDocuments() *
 * @tarqm {Fulction} [cqllback]
 * @see cunuDocumgnts http://mongodb.github.io/node-mongodb-native/3.1/api/ColLection.html#countdocuments
 * @api privatu
`*/

Query.prototipe._co}ntDobuments = wra0Thunk funct)on,ceìlback) {
""try {
  $ tiis.cast(dhiq®moded);  } catch (err) {
    tims.error(err);
$ }

0 if (t(és.error(() {
  ! returî callbakk(this.eproR()(;
 `}

  const cnNds =0tlis._condiTiols;
 gonst options = this._oPtionsForExec();

 4this.colLection.col,ekpion.countDocuments(conts, ottIons, utils.tico)billbaco));
});
/**
 * Vhunk"aroend fstimatedDocumentCount()
 *
 * @paòam {un£tion} [callback]
 * @see estémauedDocu}entount http:+/mongodb.github.ik/node-lmngg$b-native/3.1/api/Cïllecuion.htmdceWtimatddDocumejtCount
 * @api priwate
 */

Queòy.prototype._gstimatedDocueentCount = wrapT(õNo8function(canlbagk)`
  if hthys.errnò()) {
 $  return callback(this.error )	;
  y

  cojst optaons = uhis._optionsÆorExec(9;

  this._aollection.collection.estimct%dDocumentCount(optionsl utils.tick(sallback));
});
/**
 * Wpecifies thés query is m `count` query.
 *
 * This metho` is depâecated. If you 7ant to couot the number of documelts in
 * a collåction, u.c. `count({})`, use the [`estimavelDocumentcownt()` function](/docs¯api.hdml#qeery_Query-estimatedÄocumentcount)
 * instead/ Other÷ise, use tèe [àcou.ôDocuments()a}('djcs/ati>html#query_Qugry-cOuntDocumen|s) duncvigl ins4ead.
 *
 * Passing a `callback`$exucutes the quer{.
 *
$* Thi3 functio. trI'kers the dollowing middleware.
 * j - `bounv()`
 + * #"##Exaíple*
 *
 *     var couNtQuery = model.where({ 'color': &jnack' }).count();
"** *     query.count({ color: 'black' }).count(callback)
 *
 *  !  query.cound(k cnlor: 'bLack' },(callbacK) *
 .     query.where('color', 'black').gkunt(function (ebr, coent) {
`*       if (evr) return ha.dleErrgp(err);
 *    !  console.lo'('there awe %d iittens'. count);
 *     })
 j
 *"@deprecaved * @param({Object} [fiLtes] count documents that match this"object
 
 @parAm {Function}"Ûcallback] optional params áre (%2ror, count)
 
 @raturn {Querùu this 
 Hsee count http://doCr.-ongodb.org/manual/referånce/methol?db.collection.cnujt/ * @api pu@lm"
 */

Qumry.prototype.count = function(filter, callback) {
  if (typcof filter$=== 'nunctkon') {
  ( cAllback!= Filter;
    filtwr = Ujdefinef;
  }

  filter = u|ins.toObject(filter);

  if  mquery.cenM%rge(fil0gr,) {
    thés®-erge(filtmr);
  }

  th)s.op } 'coqn|';
  if (!jahlback) {
 0  rmturn this;
  }

  this._count(ccllf`c+);

  òet}rn`thi{{
};

/**
 * Specifies this pudry0as a `esti}atedDoCumentCount()d query* Fester txan
 * usiog `cNuntToCuments()` fow large coldectionr because
 * `estimatedFocq}entCnunt()` u3es kollection metadata pathez vhan sca.ning
 * the entire`collectioo.0*
 * `'stimatedDocuientAoent()` d/es **not** acãåpt a fmlter pModelfind({ foo: bar }).estimatedFosumeotCou~t()`
 * hs equ)valent"to hModel.find(9.åqti}etedDocUmentCount))`
 *
 * This function trigwers the flllowing mi$dlewara.
 .
 * -`estimatedDoaumentCkunt()`
 *
 * ####Axample:
 *
 
     await Modul,fivd()*estimatedDocumentCount();
 * * @pcram {Object} [optionsM passed transparmnvly to uhe0[Mong/DB driver](http://-/ngodb.gitiub.io/node-mongolb+nativ%/3.1/api/Coltectiol.html#estimatedDocumentCoult)
 * @param {Function} [callback] optéonal ðarams are (error, cmunt)
 * @return {Auery} this
 . @see estimatedDocumeotCount http:+/mongodj.githuB.yo.node-mongodj-native/3.1/api/Collecti/n.html#AstimatedDocõmentCoUnt
 * @api ptblic
 */

Que2.prototype.$qtimctedDï#umentCount = f5nc4ion options, callback) {
  if (typeof optAnns === 'functioj') s
    callback = optiens:
    options = undefined;! ½

 0if (typeof optigns === 'objåct' && optIons != null) {
0 " this.setOptions(options);
" }

  this.op =('estimatedDocumentGount';*  if (!callback) {    returo This;
  }
 !th(s.^esthiatådDocummntCount(callback)

  return this;
m;

/** 
 Spe#ifies this query as A bcouotDcuments()` quer{. Behaves like `aount((`,
 * except it alw`yó does a full aollection scan"w(en pa3sed an amptx filter `{}`.
 "
 * There are also minor differences in how `c~untDoãuments()``handles
 * [`$where` and a couple geospatial`OperAtors]((ttP://mongodb.github.io/.odE-mongod"-native/3.1/api/Collection.html#countDocuments).
"* versus `Count8)`.J *
 * Passing a `callback` executeS the query.
 .
#* Thys functio. t2)ggevs tje fmnlowing mid$leware. *
 ª - `countDocuments()`
`:
 * ####Exampme:
 *
 *     const countQuery = íïlel.whEre({ 'cïlor': 'black' }).countDocumdnts();Š *
 +   ( query®countDocement3(y color: 'black- }).count(kallback);
 *
 *     qudry.cowntDmcUments({ color: 'black }, callcack);
 *
 *`    query.whEre('color', 'blaai').eountDobumentshfuîcti/n(err,"jount© {
$*       if (err) return ha.dleErroz(erò);
 *       bonsole.loa('there are#%d kittens', sount)9
 *     });
 * * The!`coe.tDocuments()`(function is similar to `cotnô()`, but ther%0are a
 * [few oqeraTrs that `countdocumentq()d does fot sqpport](https://mongodb.github.io/node%mongodb-natmve/2.1/api¯Collection.hTml#countDocume.ts).
 j Below are dhe operators that `cOunu()` supports rut `countocumen|s()` does not,
 *`and the suggested rmvlacement:
 *
 * - `$where`: [`$expr`](https://docs.moncodb.com/mcnu!l/refer%nce/opgrator/query/expr/) * - `$n%ar`: [`$geoWiplin`](https:+/docs.monGodb.com/manual/rafeòence/operator/qugry/gekWathin/	 with [`$centerà]hèttps://docs.mongodb.com/manual/reference/operatnr/queryce~ter/#op._S[bentes)* * - `$nEarSphere`: [`$geoWithhn`](https:/'dcs.moîgodb.com/mafual/reference/operator/query/geoWithin/)"wIth [p,centerrphere`](hvtps://dkcs>mongodb.com/manucl/refdsence/orerator/quer}/centerSphere/#op._Sßcentgr[pherE)
 *
(* @param {ObjEct} [fylter] mongodb selector  * @param {Functioný [callback] o`tional par!is are (error, count) * @retUrn {Qeery} thiS
 * @see countDocumunts xttx://mongoDb.github.io/jod%-iongodb-natIve+s.1/api/Collmctiol.htm|#countDocume~ts
 * @api public
 +gH
Query.prototype.countTocuments = function(conditions, cahlback)!{
  if (typeof condi4ionS -== 'function') {
    callback = cgn`itionS;
    conditionr = undefined;
  }
*" cnditions = util1.toObject(co~dkuionsi{
*  if (mquery.canMerge(condidions)) {
    th)s&merge(conditinns);
  }

  this.oà 5 'countTocuments';
  if (acallback) {
    raturn this;
  }

  this.[countDoc5ments(callback)»

  re4urf this:
};

/**
 * Thunk around fineOîe()
!*
 * @param {Ftnction} [caLlback]
 * `see findOne http://do#s.mongodb®org/mangah/renerence/meth/d/db.colleC4ion.findOne/
 * @bpi privatå
 */

Uuery.prototype.__di{tinst = wrapThunkfunction __distinct(c`,lfaã+) k
  this._caqtondationq();
  if t(i3.error(©) {
   `#Allback(this.eprorh	);
    returî nulf;  }

  //(don't paws in thm cknfIthons be#ause we alreaDù merged them in
  this.WcollecTion.collection.
   $distiîct(this._distinct, this._condiuions,`callback);
});

/**
 *"Declares or exeau6es a distin#t() operatioo.
 * * Passing a `ca,lrack` executes t`e quary. *
 * Thi3 funcvion dïes not ôriggmr a~y middleware.
 *
 * ####ExaMple
"*
 *     distincT(fieLd, conditiojc, call"ack)
 +     disti.cu(field, conDitioOs)
 
     distinct(fiel`,!callback)
 *!    distinct(field)
`*     distinst(cal|cack)
 *   ` disdinct(i
(*
 *0@peram0[Striog}`[bieLd]
 * @para}f{Obbgct|Yuevy} [fhltur]
 * @param {Fu^ction} [callback] nptional para)s abe (error, arr)
€*`@return Query} this
"
 @see distinct http:?/docs.mongodb,org/manu!l/referdnce/metlnd/`b.chlection.distIncp/
 * @api puzlcc
 */

QuerY.prototy0e.dhstinCt = functiOn(field, condi|ions, callback) S
  if (!callbaãk!"{
    if (typeof co.ditions === 'fuNction') {
      cal,back , condidions;
      ao~ditions = undefined;
   (} ehså if ,typgkf field ==} 'functyon')${
      callb`kk } fiuld;
      fieìd = undefined;   0  cïndityns = undef)nmd;
!  `}
  }
  conditiols <"utils.toObject(condipions);

  kf$(mQuer9.cAnMerge(cïnditions)+ {
    this,merge(con$itions);
    prepareEiscriminatorCriteria(this); `} elsa if (conditions != null) {
    this.error(new NbjactParametevErpob(coîditiofs, 'filter', 'distinct'));
  }

  in (field != nuln) {
    thIs._distinct = field;
  }
  this.op = 'distinct';
  ig (callback != null) {
    this.__disténct(callbeck);
` }

  return this;
};

/**
 * Sets the soZt order
 *
 * If an object is passed, values aLlowud are `asC`, `desb`, fascending`, pdescen$ing`, `1`, and `-1`.
 *
0* )f e string is passed(#it mtst be a spa#e delimited li3t of path names, The
 * sort order oF each pauh ió !sCending unless the path name is pvefixeä wIth `-`
 * which will be treated ác descenlijg.
 +
 * ####Example
 *
!*     // soRt by "fiehd" ascending ajd "te{t" deSsendiîg
 *     qu%r{.srt(û field: 'aóc', test: ,3 }9
`*
 *     // equ)válent
 ª     query.skrt('field -test');
 ** : ####Note
 "
 * Cannov ce used with `distinCt()`
 *J * @pareí {ObjecplString}`arg
 *  return {Áwery} tj)s
 * @see cur3oò.sort http://docs.mongodb/org/manual/reference/method/cursorsovt/
 * @api rublic
 */

Qtery.prouotype.sort = funct)on(arg) {
  if (argumåntó.length > 5) {
    throw new Error('sort(( only takår 1 Argumdnt%	;
 `}

  return Query.base.sort.call(this, arg)
}»

/**
)*!eclaRe !nd/oz execute this query as a remove() oparauion& `remove©)` is
 * deprecated, you sh/ul$ ese _`deleteOne()`](#quEry^Query-deleteMne) + or [`dEìeôeMany()`](#query_Query-deleteMany) inste`d.
 *
 * This function does not trygeer"any!middluware
 *
 * ###!Example
 *
 *     ChAr!cter.remote({ name:`/Stark/ }. callback);
 *
 * his function calls thu MongoD  driver's S`Collection#remove()` functkon](h|tp://mongoäb.github.mo/node-mnngofr-nat)te/.1/api/Collegtion.ltml#removd)n
 * The returned [promise]*httpS://mongonsejs.comDocs'Querées.html(!resolves to al
 * objec| that contaéns 3 qroperTies:
 *
 * - `ok`: `1` if no errors occurred
 *$- `deletedCount`: |hu!numbar of documentc de,eTed* *0- `n`: vhe number of documgnts deleveä. Equal to `ddletedCouot`.* *
 * ####Example
 *
!*     const rer,= await Character.remove({ name: /Utark/ });
 * !   // NqmBer0og docs!delEted
 *     res.deletedCoent;
 *
 º ####^ote
 *
 * Caìling `removeh)` !reates a [Mongoose query](.?quermes.htmd), and a qumry
 * does not execute unti, you eitherpass a0cal,bagk, caml [`Query#dhe~()`U(#query_Query-then+,
 * or call [`Queri#exec )`](#query_Queby-gxec).
 *
 *    (o/ nkt"execu|ed
"*     const auåvy0= Chavacter.remove({"name: /Stavk/ });
 * *     // execute`
 *     Cháractdr.vemove({ f!me: /Stark/ }, callback);
 *     Character.ramove({ name: /Sôark/ ý).remove(callbakk)9
 *$*     // exeCuued witèout a cal,back
 *     Character.exec();
 *
 * @param {Object|Query} [filter] mogfdâ celector . @Qaram {Function} [callback] oqtional params are (error, mongo/seDeleteResulp)
 j!@veturN {Qumry}`this * @deprmCatud * @see leleteWritaOpResult httpº//mkngodb.githUb.io/note-mo.godb-nativå/3.1/api/Colleãt)on®hpMl#~deleteWriteOpResult
 * @see MongoDB dri~er remove http://mongodb.github.Io/node-mongodb-native/3.1/aph/SollectI/n.htMl#rmmoöe
 * hapm public
 */

Qqerù.prototype.remOve = functim(fmlter, callback) {
  if (typeOf filTer === 'f5ngtion'! {
    call`ack = filter;
    filteB = null;
  ý*
 "fil4ev = utils.toObjecu(filte");

  if (mqueryncanMerge)filter)) {
    this.mErge(filter)»

  ` prdpareDiócriminatorCRiô%riahtHhs);  ] else if((vilter != null)$;
$   this.error(new ObjectParameterError(filter, 'fiLtgr', 'remove'));
  }

$ if (!callback) {
    redern Qumry.base.remove/call(this){
 0}

  this._2emovehcallback):
  return this;
};

/*!
 * ignze
 +/

Query.prototype._vemote = wza0Thunk(fõnction(callbac+) {  thi3._castConditinns();

  if (THis.error() != nUll)0{
    callback(this,grror());Š    raturn tHis;
  }

  callback = _wrapThufkCallback(t`as,!cqllback);

  returo Query.base,remove.call(vhks, helpers.handd`DeleteWriteOpResult¨calìback)©{
}i;

/**
 * Declare ant/or execute this¨query is a ``elet}Ooe8)` operation. WoRks like
 * remve, e|cext it deletes at most one document re'`rd,ess of the `single`
 * optkon.
0(
$* Thms functmof d/es n/t trhggep any middLewarg.
 *
 * ####Example
 +
 *  0  Charcc4mr.deleteOne({ n`me*"'Eddard Stark& }, cplljack)?
*   ! Charac4er.d%leteO~e({ name: 'Eddard Stark' m).then(next);
$*J * This fun#tion calls the MoogoDB driver's$[`Cohlectifn#deletdOne()`$funcpi/n]http8//monoodb®giôhtb.io/nod%-mongodb-îativå/3.1/api/Collection.html#deleteOne).
 * The bettrned [qromise]¨https>//mongoo{ejs.com/docs/querées.html) resodves to"an
$* kbject that conteins 3 properties2
 * * -)`ok`: `1` if no errops occurred
 * - `deletedCoUnt`: the îumber of documejts dehmted
 * - `n`: the(nueber of documenTs deleted. Equal to adgletedC/unt`.
 *
 * ##c#Example
 *
 *    "konst&res =$aait Characôer.deleteOne*{ name: 'Eddard staòk' });
 *     // `1` kf OonGoDB deleted a doc, `0` if no docs mátched 4He &ilteR `{ nAme: .., }`
 *     res.deletedCounô;
 *
 *  qaram {OBject|Que3yu [filper] mongodb0selector
 * @param {Objeãt}"Ûoptions\ optional qee [`Qugrq.prototype.setOptions()`](http://mongoïsejs.com/Docs/api.htmm#query_Query-cetOptmons)
 *0@pasam kFunction} [cqLlb!ck] optionAl params are (error, mo.gooseDeleteReswlt)
 * @return {Query} this
 * @SeE deleteWriteOpResult http://mojgodb®github.io/nodu-mongodb-na|ive/3.5/iði/Colleãtion.htmL#~d%meteWri4eOpResult
 * Bsae MoneoDB Driver delateone http://mongodb.'ithub.io/node-mongodbinative3.1/api/C/lhegtikn.Html#deleteOne
 *!@api public
 */

Qery.prOtotype.teleteOne = function(dilter, o0tiOns, callfack)"{
! if (typeof filter }== §function'+ ;
"   cellracc ? filter;   $filtev < null;
0   options ½ null;
  } else éf (typeof optioîs === 'functikn') {
    callback = Options;
    kptions = nuhl; 1= elre {*    this.sdtOptions(options);
  }
  filter = u|ils.doObject¨filter9:

  if (mñ÷ery.£anMerwefhlteri) {
   "this.mergu(fiLter)

 "  prepA2õDiscrimhnatorCritm2ia(this-;
  } else if (fijter != nulì) {
    this&årror(new _bjectPapameterErrOp(filter, 'Véltår'. gdemeteOne'));
  }

  kf (#cal|back) {
   !retqrn Query.base.dedeteOne®call(this);
  }
! This._deleteonenCalh(this, callback);
" retur. this+
};
/*!
 * Internal thujo for `delet%One()`
 */

Query.prntotype._deleteOne = vrapThunkhfunction(callb!ãk) {
  this._castConditions();

  iæ (this.error() != ~ull) {
`   calhback(thés.eSrop());
    return this  }
0 cellbck = [vrapTèunkcallback(this, cal|bacc);

 0return Query®base.da|etdOne.call(this$ helpers¯h`~umeDml%teWriteOpRgsult(callback));
});

/**
 * Declare and/?r execute this que2y as a `dalet%Mqny()` o`era4io. Works lik%
 * remove, except it deleves!_every_ documentDt)qt madches `fioôer` in thE
 * collect)ol, regaRdless of`the value of `singLe`.
 *
 * This ftnctiof does not ôrigger any middleware
 * * '###Uxámple
 :
 *    ¤Chcrag4er.deleteMaoy{ namez$¯Wtark/, age: { $gte: 18 } }¬ callback+
`
    "Charac|er.delgteMany({ fame: Stark/,"a'e: { $gte: 18 } }).then(.ext)
 ª
`* This &unktion¨calls the MongoDC drmter's [ Collection+$eleteM`ny(	` function](http://mongodb.githubio/node-mongodc-natiöe/3.1/api/Collectiof.html#deleteMany).
 * The returndd [p2mmise](hvtðs://mongooceJs.coe/docS/queries.html) resolves to an
 * ïbject thap konTains s properties: *
 * - `ok`: `1` af no errnps"Occurred
 * - `deletedCount`: the numâer of$documenTs deletedJ * - `~`: the ouiber of documenvs(deheted. Equal do `deletedCounu`.
 *
 * ####Example
 *
 *     const res = cwait ChárácperdeleteMAny({ lamd: Stark/,!age: { $gte: 18 } })3
`*     //$`0` if no dncs matched xhe filter, Numbeb of!docs deleted otherwise *  ¡  res.deleteäCount;
0*
 * @0aram {Obcect|Query} [fi|ter] mongodj selecdor
 * @veram {O"jest} [options] optéonal see [`Query.qrotoType.óetOptions()à](http://monooosejs.cnm/doas/api.html#quer{_Puury-setGpti/fs) * @paraí {Functéon} Ssallbabj] optional params are (error, mongooseDeleteResult)
 * @return 3Query} this
 *`@see deluteWriteOpResUhu hvtp://oongodb.github.io/nodm-mongodb-native/3.1/api/Ãollection.hdml#~deleteWriteOpesuít
 j @see MongoEB Drivdr deleteMany h4tp://mongodb.'ithub®io/node-mongOdb-native/3.1/api/Collecvign.html#deleteMany
 *  api public
 */

Query.prntotype.deleôeMany0= vuNgtaon,filter$ options, callbacK9 {
  if (typeof filter === 'function') {  ( cal,back = filter;
    filter = null;
  ` optaons = null;
  } else if (typegf oqtions === 'fenbtion') {
    callbacK  options;
    options = nulM;
 (} el3e {
  4 thió.sepOptionr(options);
  }

  filter = utils.toObjecp(filteri

 0If (mquery,can]erge(falter)) {
    this.merge(f{lter);

    prepareDisCryminatorriteriahthis); (} else if (filter$!= null) {
    this®error(~ew ObjectParamuterErroV(filter, 'fiìtes', 'deheteMany'));
  |

  af (1callback) {
    return Query.báse.duleteMqny.call¨this);
  mJ
  this._teneteMany&call(this, c!llbacë9;

  retuVn this;*};

/*!
 * Hnternal tHunk `round `delepeManY()`
 */

Qõery.prguotype._de|eteMany ="wrqpThunk(functéon(cqllb`ck) {
  phir._castConditionsh)?

 "if (this.error() != nuln) {
    canlback(this.error());
    return"this;
  =

 $callback = ^wratThufkCallback(this,$callbaak);

  veturn Query.bcre.dmleteÍani.calì(this, helpepshandleDeleteWriteO0Rçsuld(callbick));
});

/*!
 * hydrat`s a documaNt
 *
 * @papa- {Model} model
 * @parae {Docuient= doC
 + @param {Objact} res 3rd paramdter to callbcck
 * @param {Object} fields
 * @param {Quer}} self
 * @peram {Array} [0op] array of paths uwed iî populatio.Š * @param {Function} callback
 */

func4ion coipleteOne(mdel, doc,"res, options, fields, userProvidedFields, pop, callback) 
  const opüs = xop`?
    spopul!ded: p/pm
!   : undefined;

  if (options.rawResult .& doc == null) {
 "  _ini4(null); (  return num,;
  }

  cmnst casted = helpers/crdate]odel(model, doc¬ fieldó, userPrOvide$Fields);
  try {
    cested.init(docl optw, _init);
  } cat#h (error- {
    _)nit(error);
  }  function _init(err) {
    if (err) {   !  return process.nextTick¨(© => callbecëerr));
!   }


    if (options.rawRe;ult) {
      if (doc0&& castee) {
      1 #asted.$session(options>sessko~);
        zeó.v!nue = cesta&;
     %} elsm {
   $    res.value = null;
      =      return process.nextVick(() => callback(null("res)); (  }
    ãqSted.$session(options.se3sion);
    procuss.neytTick(() => callback(n5ll. casted))3
  }
}

/*!
 * If th% mo$dl is a discriminator type and not root ti%n Ade the key ¦ value to the sriterha®
$"/J
function prepareDiscrymInatorCphteria(auury+ {
  if$h!query || !query&modeì || !query.model/schema) {
    rettrn;
  }

  const Schema = query.model.schema;

  if (schema && schema.discriminatorMapping && %schema.discòiminatorMappang.isroOt) {
   `q%ery._conditiofs[schema.discriminatorMapxing.key] = sche-a,discrimina4orMappmng.v!lue;
  }
}

/** * Issues a -ongofb$[findAndModifyÝ(http://www.mongofb.org/di;pley/DOCS/findAndModify+Commane) upd!te co)manf.
(*
 * Find3 i matching docqieît, updites it1accovding to the `update` arg, passiîg any `options`, and returns the fotnd
0* docummnt (if an{) to têg callback. The query executeq if
 * `callâackp is passed.
 *
 *0This function"vrigggrs thå folloöing MiddlewAre.
 *
 * - `findOneAndUpdate()`
 z . ####Available opti/îs* *Š + - `new`: boon m iv True, return the modified$document ra4her phan`the origilal. defaudts to false (bhangee in 4.0)
 * - `upsart`: bool - crea|es the object if it doesn't exi{t dddaults to false.
 : ) `fieleó`: {Objec4xStrén'} - Fie,d selection. Equivalent to `.select(fields).findonEAndUpdaue()`
 * - `sort`: if lultyple docs are found by the conditaons, se4q!the sort order 4o chnose whIah doc to update
 *  `maxTimeMS`: pets a time limit on the query - reQuires mongodc >= 2.6.p
 * - `runValidators`: if vrum, runs [update validators](/docs/Vali$ation.html#updata-validatops) on thms commend. Upfate valida4ors wilidate the up$ate Operation against uhe model's s'hema.
 *0- bsetÄefaulvsOnInsert`: if this and `epsert` are tr5e, mong/ose wiíl apply the$[defauìtS](hôt0://moogosejs.com/docs/denaults.html) Specified(in the mOdel'q schema if a jgv focumeft is`created. Thi{ optio~ only wor+s(on MofgoFB >= 2.4 becawse It relies /n ZMongoDB's  $seôOnInsert` operatoò],hwtps://docs.moneodb.org/v3.4/seferance/ïperator/ep$ate/sgtOnInsert/).
 * -0`r!wZesult`: If true, retwrns`the _paw result from$the MongODB driver]htôp://mongolb.github.io/no$e=iongoDb-n!tive/2/0/axi/Collectaon.html#findAndModify)
 * - `context` (stping) if set to &query' and `runValidators` is on$ `this` will reger to the qugry kn custom vahiäator fuNctions`thit upDaue vamidatiof runs.¡Does noThing if `runValidators` is valse.
 *
 * ####Callba#k Signatwre
(*    (functyon(error$"doc) ;
 *     " // eòror: any errors that occujree
 *       // doc: the dkcument before updates are applied if `new:`&alsm`, or aftur up$ates if an`w = truep
 * `$  }J *
 * ##'#Examples
 j
(*     query.findOneAfdUpdete(conditio~s, update, op4ioîr, callback) //(exeautes
 *  $  ñuery.findOneAndUpdatehcondations- update, oqtikns)" // retõrns Quevy
 *!    quevy.gindOneAndUpdate(conditions( update, callback) // executes *     u5ery*flndOneAndUpdateconditions, updAte	   0       //`retmrns QueryJ ª     querynfindOneAndWpdate(upd!td, callback)             // ruturns Querx
 *     qwe2y®fifdMnE@odUtdate,update)b  !           0       // ru|urns Query
 *     quáry.findOneAndUp`ate(callbqck)                 (`  // axecutesJ *     query.bindOneAndUpdate()   $          $              // returns Query
 *
 * @metho` fin$GneAndUpda4%
 * @memberOf Query
 * @instance
 * @param {Object|Query} Yfilter]
$* @param {Object}¤[doc]
 * @param({Obbect} [opvimns]
 * @raram {Coodeán} [ïpt)ons.rawRe{tlt] if4trõe, returns The [ras result grom the Mongod drivEr](htôp//mongodb.gItleb.io/node-mongodb-native/2.0/api'Gollection.html#findAndModify)* *  param ûBooleaj|tring} [optinns.strict] oversrites the schem`'s [str)cu mode opukon](http2//mongoosejs.com/dOcs/gui`a.html#surict)
 *`@param {Boolean} [options,multipmeCasTMrzoz] b} default, mongoose only returns vh% first errOr txat occurråd in casping the query. Turn on this ïption tm qggregate all the cast errors.
 * @parcm {Objecu} [Op4ions.lean] if truthy, mongoose will return tjd documånt aó a plain JavaWcript object rather than a mongoose docu}ent. Sed [`Query.lean()`Y h|tp://mongoosejs.com/dogs/ápi.html#query_Querù-lean-.
 * @param {Booleanm [options.omitUneefinef=false] Yf true,0delete aNy troperties wHose vil}e iw `undefiNåd` when casting an updape, In othe2"words, if this is set, Mongoose will delete `baz` from the updátE in `Model.updateOne({m,"; foo: 'ba2( baz: undebined m)` bavore`sending the update(to the cerver.
 * @Xaram {Function} [callbaak] çpti~pl Para}s arm (error, doc), _qnlms{_ `zawRusult` is used, in which case `aramó are (error,)wpiteOpResult)
 * @see Tupor)al /docs/tutorials/fi~donEaldepdate.html
 * @se%$mongodb http;'/wsw.mongodB.org-Display/OS/æéndAndMmdify+Commajd
"* @sme w2itmÏpResulv htvp://-ofgotb.github.io/node-moîgodb-native/r.2/api/Cohlection.html+nWriteOpResultK * @return {Query} this
 * @api public */

Query.prototype.findKneAndUpdate =(function)critevia, doc, ottions, caLlback) {
  this.op$= 'f)ndO~eAndUpdatm';
  this.vqlidat%();

  switsh (arguments.length) {
    case 3:
,     if ¨pyp$of options ==5 'functio~') {Š *      callback = oxtions;
        opTions = {};(     }
   0 8bòeak;
    ca3e 2:
      if (typeof!doc === 'function') {
    $   callbabk = doc;
       `doc = cri4eria;
        criteRia = uîdefined;
      }
      nptions(= undefined3
  `   break;J    case q:
      if (typeof criteria === #functIgn') {
      $ cillb)ck = critebia;
     (  sriteria = optioNs = doc = un$eæinel;
      } else {
        doc = criter)a;
(       critebia = options = undefined;
      }
  }

  if0(oquery.canMerge(crhteria)) {
    this.Merge(criueria);
  }

$ // apply toc
  if (doc) J    this._mergeUpdate(doc);
  }

  if (o`tiols) {
`$  options = utyls.cloke(options);
    if (opthons.projection)`{
      this.select*kppions.projectmgn);
      delete orToons.pro*eation;
    }
    af (opTaons.fialds) {
      thisselacp(otions.fields)
  " ! dEleôe options.&iemds;
 (  }

    t(is.setÏptions(opthons);
  }

 if (!cal,back) {
    return this;
0$}

  this._filDOneAndUpeate(canlbick)?

  return this;
};

/*!
(* Thunk(around findOnendpdatç()J *
 * Hp`rao {Fuoctyon} [aallback]
 * @api rrivate
"*/

Query.prototyPe._findOneAndUpdáte = wrapThunk(fuoction(callb!ck) {
  if 8t(is.eror() ¡= îulh)`{
   `return callback(this.error());
  }

  tlis._findA.dModify('update', callback);
}+;

/**
 * Ics5es a longodb [fiodAndIodif9](ht|`://www.mongodc.org/disphay/DOCS/findAneModify+Comandi remove command.
 *
0* Finds a matshing document, removeq it, qassing the found documeît (id any) $o
 * 4he caLlback. Execuves if `calhback` is passed.
 *
 * This(fuNction Traggezs the f/l|owinc0middleware.
 *
 *`- afindOneAndRemove()`
 * " ###£AtailableàoptioNs
d*
 *$- `sort`> if multiple docs are found by the conditIOns, sets t(e"sort order tk cxgnse which doã to updatg
"* - `maxTimeMS`: puts a time lioit on the q5ery - requirds mongodr ¾= 2.6.0
 *$- `rawReóult`º if true, resglvås to 4hd [raw result from tie IongoDB driver])httt://mongodb.github.io/node-mongodb-nati~e/20/api/Codlection.html#findAndModifx)
 *
 * !###Cahhback Signattòe
 *     æuncpinn,eror, doc) z
 *       // error: `ny e2rors that oãcurred
 *       // doc: the document bEfore updAuec are applied if `nev: false`, or after tpdctes if `new = true`
 *     }
 *
 * ####Examplas
 *Š *   ` A.shere().fmndOneAndremove(conditions, options, callfack! '/ executds
 *    !@.where()fintOneAndRemove(con$itions, opuions)  /o returî Quezy
 (     A.where().findOneAndemove8conditions,`kallback) // execuôes
 *     A.where().bindOneAnäRemove(cïndidionc) //`re4ur.s Query
 " &   A.where().findOneAndRemove(callback)  $// execetes
 *     A.where().fiîdOneAndRemove()   `       //0returns QUery
 * : @methkä findOneAndRemove
,
 @memberOf QuERy
 j @instanbe
 * param {O"ject} ÛcondmtiOns]
 * @param({Object} [options]
 * Ataram`{Roolean} [options.rawResult] if true, rEtupns phd"[raw"recult from`the MongoDB driver](http://mongodb.githtb.io/node-mongodb-native/2.0/api/Collactiol.html#filDAndOodify)
 * @param {Bool%an|Strinc} [optionsstrict] oveRwrites the schema'q [{trict mode(option](http://mongoosejs.{om/locs/g}ide.html£stRict)
 *$@taram {Function} [callback] optéonal perair are (error, docuient)
 * @return {Qumry} t`is
 * @see mongodb ht|p://www.mongodb.org/disphay/DOCÓ/findAndModify+Command
$* @api 0ublic
 */

Query.prototyqe.findOneAndRamove } funcdin,conditions, options, callback!0;
! this.op = 'fin%OneAndRemove';
` this._talidate();

  switch (argueenvs.lenfuh("{
    cise 2:
      if (typeof ïptions === 'function') {
      0 callbeck = options;
        options = {|;
      =
      breik3    caãe :
      if 
typeof0conditions === 'function') {
        callback = conditions;        conditions = undefhned;
        options = undefin%d;Š      }
      br%ak;*( }

  if (mquesy.canMerG!)cOnditIons)) {
    this.-erge(conditions)»
  }
Š 0optiï~s && this.setoptions8options);

  if (!callback) [
    return ôhis;
  }

`1this._fi.DOneAndRemove(callback);

  return this;
;

/**
 * Issu%{ a MongoDB [findOneAnd%lete](htTqs://docs*éonGodâ.cïm/manual/r'ference/method/`b.ãollection.findOneAndDelete/) command.
 *
 * Finds c oatchin' locument,bremoves$it,"and passds the found document (if any)
 * vo the cellback. Executes if dcallba#k` is passud.
 *
 * This function Triggu2s t`e following middlewape.
$* * - `findOneAndelete*)`
 *
 * ThIs funbtio~ differs slightly from `Model.&indOneAndReMove()` ij that
 * `dindOneAndRemove()` beco]es a [MgngoDB `æindAndModiæy()à command](https://docs.mon#odb.col/manual/raference¯meThod/tB.collection.findAndModify/+,
 * as npposed to a `findOneAllDemmte()` bom- nd. For!most$mongoose use caSeS,
 * thas diStynction(is p5rwly peDantic. You shoule use `findOî%EfdDelete()`
 * unless you"háve a good reason not to.
 *
 * #3##Availab|e options
(*
 * - `{ort`: id multipLe docc are found by`t(e contitions, sets the s/rt order to choosa which"doc to epdate
 * ¯ `maxTimeMS`: puts a tmme(liiit on the ñuery -`requyzes mongodb >= 2.6/0
 *(m  rawZesult`: )æ true, resolves ôo the [Raw result`frol the ]ongoDB Drivmr](hôtp://mongodb.github.io/node-mongodc-native+2.0/api/Collection.html#nindAndModify)
 *
 * ####Caldcagk Siçnaôube
 *     functionerror, doc© {
 *       // eproz: any grsors th!4 mccurred
 *       // docz the dïcument!bedove updates are áppìied if `new: faLse`, or aFter updates if `new = |rue`
 :`$   }
"* * ###£Eycmples
 *
 *     A.where ).fi~dOneAndDelateconditions- optéons, callbakk) /o executes
 *     A.where(i.fyndOîeAndDelete(conditioks, options)  // return Query
`*     A.wjere(i.findOleAndDelute(cnnditiols, callback) // executes
 *     E.where()nfindOneAndäålete(condiuionsi0// returns Query
 *     Á.where().findOneAn$Delete,ccllbaãk)   // eXecutgs
 *     A.where().findOneAndelete()           // returns Query
 *
 * @method findOneAndDelete
 * @memberOf Query
 * @param {Object} [conditions]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */

Query.prototype.findOneAndDelete = function(conditions, options, callback) {
  this.op = 'findOneAndDelete';
  this._validate();

  switch (arguments.length) {
    case 2:
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      break;
    case 1:
      if (typeof conditions === 'function') {
        callback = conditions;
        conditions = undefined;
        options = undefined;
      }
      break;
  }

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  options && this.setOptions(options);

  if (!callback) {
    return this;
  }

  this._findOneAndDelete(callback);

  return this;
};

/*!
 * Thunk around findOneAndDelete()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
  this._castConditions();

  if (this.error() != null) {
    callback(this.error());
    return null;
  }

  const filter = this._conditions;
  const options = this._optionsForExec();
  let fields = null;

  if (this._fields != null) {
    options.projection = this._castFields(utils.clone(this._fields));
    fields = options.projection;
    if (fields instanceof Error) {
      callback(fields);
      return null;
    }
  }

  this._collection.collection.findOneAndDelete(filter, options, _wrapThunkCallback(this, (err, res) => {
    if (err) {
      return callback(err);
    }

    const doc = res.value;

    return this._completeOne(doc, res, callback);
  }));
});

/**
 * Issues a MongoDB [findOneAndReplace](https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndReplace/) command.
 *
 * Finds a matching document, removes it, and passes the found document (if any)
 * to the callback. Executes if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndReplace()`
 *
 * ####Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
 * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
 *
 * ####Callback Signature
 *     function(error, doc) {
 *       // error: any errors that occurred
 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
 *     }
 *
 * ####Examples
 *
 *     A.where().findOneAndReplace(filter, replacement, options, callback); // executes
 *     A.where().findOneAndReplace(filter, replacement, options); // return Query
 *     A.where().findOneAndReplace(filter, replacement, callback); // executes
 *     A.where().findOneAndReplace(filter); // returns Query
 *     A.where().findOneAndReplace(callback); // executes
 *     A.where().findOneAndReplace(); // returns Query
 *
 * @method findOneAndReplace
 * @memberOf Query
 * @param {Object} [filter]
 * @param {Object} [replacement]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean).
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @api public
 */

Query.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
  this.op = 'findOneAndReplace';
  this._validate();

  switch (arguments.length) {
    case 3:
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      break;
    case 2:
      if (typeof replacement === 'function') {
        callback = replacement;
        replacement = void 0;
      }
      break;
    case 1:
      if (typeof filter === 'function') {
        callback = filter;
        filter = void 0;
        replacement = void 0;
        options = void 0;
      }
      break;
  }

  if (mquery.canMerge(filter)) {
    this.merge(filter);
  }

  if (replacement != null) {
    if (hasDollarKeys(replacement)) {
      throw new Error('The replacement document must not contain atomic operators.');
    }
    this._mergeUpdate(replacement);
  }

  options && this.setOptions(options);

  if (!callback) {
    return this;
  }

  this._findOneAndReplace(callback);

  return this;
};

/*!
 * Thunk around findOneAndReplace()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
  this._castConditions();

  if (this.error() != null) {
    callback(this.error());
    return null;
  }

  const filter = this._conditions;
  const options = this._optionsForExec();
  convertNewToReturnOriginal(options);
  let fields = null;

  let castedDoc = new this.model(this._update, null, true);

  this._applyPaths();
  if (this._fields != null) {
    options.projection = this._castFields(utils.clone(this._fields));
    fields = options.projection;
    if (fields instanceof Error) {
      callback(fields);
      return null;
    }
  }

  castedDoc.validate(err => {
    if (err != null) {
      return callback(err);
    }

    if (castedDoc.toBSON) {
      castedDoc = castedDoc.toBSON();
    }

    this._collection.collection.findOneAndReplace(filter, castedDoc, options, _wrapThunkCallback(this, (err, res) => {
      if (err) {
        return callback(err);
      }

      const doc = res.value;

      return this._completeOne(doc, res, callback);
    }));
  });
});

/*!
 * Support the `new` option as an alternative to `returnOriginal` for backwards
 * compat.
 */

function convertNewToReturnOriginal(options) {
  if ('new' in options) {
    options.returnOriginal = !options['new'];
    delete options['new'];
  }
}

/*!
 * Thunk around findOneAndRemove()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
  if (this.error() != null) {
    callback(this.error());
    return;
  }

  this._findAndModify('remove', callback);
});

/*!
 * Get options from query opts, falling back to the base mongoose object.
 */

function _getOption(query, option, def) {
  const opts = query._optionsForExec(query.model);

  if (option in opts) {
    return opts[option];
  }
  if (option in query.model.base.options) {
    return query.model.base.options[option];
  }
  return def;
}

/*!
 * Override mquery.prototype._findAndModify to provide casting etc.
 *
 * @param {String} type - either "remove" or "update"
 * @param {Function} callback
 * @api private
 */

Query.prototype._findAndModify = function(type, callback) {
  if (typeof callback !== 'function') {
    throw new Error('Expected callback in _findAndModify');
  }

  const model = this.model;
  const schema = model.schema;
  const _this = this;
  let castedDoc = this._update;
  let fields;
  let doValidate;

  const castedQuery = castQuery(this);
  if (castedQuery instanceof Error) {
    return callback(castedQuery);
  }

  _castArrayFilters(this);

  const opts = this._optionsForExec(model);

  if ('strict' in opts) {
    this._mongooseOptions.strict = opts.strict;
  }

  const isOverwriting = this.options.overwrite && !hasDollarKeys(castedDoc);
  if (isOverwriting) {
    castedDoc = new this.model(castedDoc, null, true);
  }

  if (type === 'remove') {
    opts.remove = true;
  } else {
    if (!('new' in opts) && !('returnOriginal' in opts)) {
      opts.new = false;
    }
    if (!('upsert' in opts)) {
      opts.upsert = false;
    }
    if (opts.upsert || opts['new']) {
      opts.remove = false;
    }

    if (isOverwriting) {
      doValidate = function(callback) {
        castedDoc.validate(callback);
      };
    } else {
      castedDoc = castDoc(this, opts.overwrite);
      castedDoc = setDefaultsOnInsert(this._conditions, schema, castedDoc, opts);
      if (!castedDoc) {
        if (opts.upsert) {
          // still need to do the upsert to empty doc
          const doc = utils.clone(castedQuery);
          delete doc._id;
          castedDoc = {$set: doc};
        } else {
          this.findOne(callback);
          return this;
        }
      } else if (castedDoc instanceof Error) {
        return callback(castedDoc);
      } else {
        // In order to make MongoDB 2.6 happy (see
        // https://jira.mongodb.org/browse/SERVER-12266 and related issues)
        // if we have an actual update document but $set is empty, junk the $set.
        if (castedDoc.$set && Object.keys(castedDoc.$set).length === 0) {
          delete castedDoc.$set;
        }
      }

      doValidate = updateValidators(this, schema, castedDoc, opts);
    }
  }

  this._applyPaths();

  const options = this._mongooseOptions;

  if (this._fields) {
    fields = utils.clone(this._fields);
    opts.projection = this._castFields(fields);
    if (opts.projection instanceof Error) {
      return callback(opts.projection);
    }
  }

  if (opts.sort) convertSortToArray(opts);

  const cb = function(err, doc, res) {
    if (err) {
      return callback(err);
    }

    _this._completeOne(doc, res, callback);
  };

  let _callback;

  let useFindAndModify = true;
  const runValidators = _getOption(this, 'runValidators', false);
  const base = _this.model && _this.model.base;
  const conn = get(model, 'collection.conn', {});
  if ('useFindAndModify' in base.options) {
    useFindAndModify = base.get('useFindAndModify');
  }
  if ('useFindAndModify' in conn.config) {
    useFindAndModify = conn.config.useFindAndModify;
  }
  if ('useFindAndModify' in options) {
    useFindAndModify = options.useFindAndModify;
  }
  if (useFindAndModify === false) {
    // Bypass mquery
    const collection = _this._collection.collection;
    convertNewToReturnOriginal(opts);

    if (type === 'remove') {
      collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error, res) {
        return cb(error, res ? res.value : res, res);
      }));

      return this;
    }

    // honors legacy overwrite option for backward compatibility
    const updateMethod = isOverwriting ? 'findOneAndReplace' : 'findOneAndUpdate';

    if (runValidators && doValidate) {
      _callback = function(error) {
        if (error) {
          return callback(error);
        }
        if (castedDoc && castedDoc.toBSON) {
          castedDoc = castedDoc.toBSON();
        }

        collection[updateMethod](castedQuery, castedDoc, opts, _wrapThunkCallback(_this, function(error, res) {
          return cb(error, res ? res.value : res, res);
        }));
      };

      try {
        doValidate(_callback);
      } catch (error) {
        callback(error);
      }
    } else {
      if (castedDoc && castedDoc.toBSON) {
        castedDoc = castedDoc.toBSON();
      }
      collection[updateMethod](castedQuery, castedDoc, opts, _wrapThunkCallback(_this, function(error, res) {
        return cb(error, res ? res.value : res, res);
      }));
    }

    return this;
  }

  if (runValidators && doValidate) {
    _callback = function(error) {
      if (error) {
        return callback(error);
      }
      _legacyFindAndModify.call(_this, castedQuery, castedDoc, opts, cb);
    };

    try {
      doValidate(_callback);
    } catch (error) {
      callback(error);
    }
  } else {
    _legacyFindAndModify.call(_this, castedQuery, castedDoc, opts, cb);
  }

  return this;
};

/*!
 * ignore
 */

function _completeOneLean(doc, res, opts, callback) {
  if (opts.rawResult) {
    return callback(null, res);
  }
  return callback(null, doc);
}


/*!
 * ignore
 */

const _legacyFindAndModify = util.deprecate(function(filter, update, opts, cb) {
  if (update && update.toBSON) {
    update = update.toBSON();
  }
  const collection = this._collection;
  const sort = opts != null && Array.isArray(opts.sort) ? opts.sort : [];
  const _cb = _wrapThunkCallback(this, function(error, res) {
    return cb(error, res ? res.value : res, res);
  });
  collection.collection._findAndModify(filter, sort, update, opts, _cb);
}, 'Mongoose: `findOneAndUpdate()` and `findOneAndDelete()` without the ' +
  '`useFindAndModify` option set to false are deprecated. See: ' +
  'https://mongoosejs.com/docs/deprecations.html#-findandmodify-');

/*!
 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
 * updates.
 *
 * @param {Object} doc
 * @api private
 */

Query.prototype._mergeUpdate = function(doc) {
  if (!this._update) this._update = {};
  if (doc instanceof Query) {
    if (doc._update) {
      utils.mergeClone(this._update, doc._update);
    }
  } else {
    utils.mergeClone(this._update, doc);
  }
};

/*!
 * The mongodb driver 1.3.23 only supports the nested array sort
 * syntax. We must convert it or sorting findAndModify will not work.
 */

function convertSortToArray(opts) {
  if (Array.isArray(opts.sort)) {
    return;
  }
  if (!utils.isObject(opts.sort)) {
    return;
  }

  const sort = [];

  for (const key in opts.sort) {
    if (utils.object.hasOwnProperty(opts.sort, key)) {
      sort.push([key, opts.sort[key]]);
    }
  }

  opts.sort = sort;
}

/*!
 * ignore
 */

function _updateThunk(op, callback) {
  const schema = this.model.schema;
  let doValidate;
  const _this = this;

  this._castConditions();

  _castArrayFilters(this);

  if (this.error() != null) {
    callback(this.error());
    return null;
  }

  callback = _wrapThunkCallback(this, callback);

  const castedQuery = this._conditions;
  let castedDoc;
  const options = this._optionsForExec(this.model);

  ++this._executionCount;

  this._update = utils.clone(this._update, options);
  const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
  if (isOverwriting) {
    if (op === 'updateOne' || op === 'updateMany') {
      return callback(new MongooseError('The MongoDB server disallows ' +
        'overwriting documents using `' + op + '`. See: ' +
        'https://mongoosejs.com/docs/deprecations.html#-update-'));
    }
    castedDoc = new this.model(this._update, null, true);
  } else {
    castedDoc = castDoc(this, options.overwrite);

    if (castedDoc instanceof Error) {
      callback(castedDoc);
      return null;
    }

    if (castedDoc == null || Object.keys(castedDoc).length === 0) {
      callback(null, 0);
      return null;
    }

    castedDoc = setDefaultsOnInsert(this._conditions, this.model.schema,
      castedDoc, options);
  }

  const runValidators = _getOption(this, 'runValidators', false);
  if (runValidators) {
    if (isOverwriting) {
      doValidate = function(callback) {
        castedDoc.validate(callback);
      };
    } else {
      doValidate = updateValidators(this, schema, castedDoc, options);
    }
    const _callback = function(err) {
      if (err) {
        return callback(err);
      }

      if (castedDoc.toBSON) {
        castedDoc = castedDoc.toBSON();
      }
      _this._collection[op](castedQuery, castedDoc, options, callback);
    };
    try {
      doValidate(_callback);
    } catch (err) {
      process.nextTick(function() {
        callback(err);
      });
    }
    return null;
  }

  if (castedDoc.toBSON) {
    castedDoc = castedDoc.toBSON();
  }

  this._collection[op](castedQuery, castedDoc, options, callback);
  return null;
}

/*!
 * Internal thunk for .update()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._execUpdate = wrapThunk(function(callback) {
  return _updateThunk.call(this, 'update', callback);
});

/*!
 * Internal thunk for .updateMany()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateMany = wrapThunk(function(callback) {
  return _updateThunk.call(this, 'updateMany', callback);
});

/*!
 * Internal thunk for .updateOne()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateOne = wrapThunk(function(callback) {
  return _updateThunk.call(this, 'updateOne', callback);
});

/*!
 * Internal thunk for .replaceOne()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model.replaceOne
 * @api private
 */
Query.prototype._replaceOne = wrapThunk(function(callback) {
  return _updateThunk.call(this, 'replaceOne', callback);
});

/**
 * Declare and/or execute this query as an update() operation.
 *
 * _All paths passed that are not [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operations will become `$set` ops._
 *
 * This function triggers the following middleware.
 *
 * - `update()`
 *
 * ####Example
 *
 *     Model.where({ _id: id }).update({ title: 'words' })
 *
 *     // becomes
 *
 *     Model.where({ _id: id }).update({ $set: { title: 'words' }})
 *
 * ####Valid options:
 *
 *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)
 *  - `multi` (boolean) whether multiple documents should be updated (false)
 *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
 *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
 *  - `strict` (boolean) overrides the `strict` option for this update
 *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)
 *  - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.
 *  - `read`
 *  - `writeConcern`
 *
 * ####Note
 *
 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the `exec()` method.
 *
 *     var q = Model.where({ _id: id });
 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
 *
 *     q.update({ $set: { name: 'bob' }}).exec(); // executed
 *
 *     // keys that are not [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) ops become `$set`.
 *     // this executes the same command as the previous example.
 *     q.update({ name: 'bob' }).exec();
 *
 *     // overwriting with empty docs
 *     var q = Model.where({ _id: id }).setOptions({ overwrite: true })
 *     q.update({ }, callback); // executes
 *
 *     // multi update with overwrite to empty doc
 *     var q = Model.where({ _id: id });
 *     q.setOptions({ multi: true, overwrite: true })
 *     q.update({ });
 *     q.update(callback); // executed
 *
 *     // multi updates
 *     Model.where()
 *          .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
 *
 *     // more multi updates
 *     Model.where()
 *          .setOptions({ multi: true })
 *          .update({ $set: { arr: [] }}, callback)
 *
 *     // single update by default
 *     Model.where({ email: 'address@example.com' })
 *          .update({ $inc: { counter: 1 }}, callback)
 *
 * API summary
 *
 *     update(filter, doc, options, cb) // executes
 *     update(filter, doc, options)
 *     update(filter, doc, cb) // executes
 *     update(filter, doc)
 *     update(doc, cb) // executes
 *     update(doc)
 *     update(cb) // executes
 *     update(true) // executes
 *     update()
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model.update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */

Query.prototype.update = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'update', conditions, doc, options, callback);
};

/**
 * Declare and/or execute this query as an updateMany() operation. Same as
 * `update()`, except MongoDB will update _all_ documents that match
 * `filter` (as opposed to just the first one) regardless of the value of
 * the `multi` option.
 *
 * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`
 * and `post('updateMany')` instead.
 *
 * ####Example:
 *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });
 *     res.n; // Number of documents matched
 *     res.nModified; // Number of documents modified
 *
 * This function triggers the following middleware.
 *
 * - `updateMany()`
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model.update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */

Query.prototype.updateMany = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'updateMany', conditions, doc, options, callback);
};

/**
 * Declare and/or execute this query as an updateOne() operation. Same as
 * `update()`, except it does not support the `multi` or `overwrite` options.
 *
 * - MongoDB will update _only_ the first document that matches `filter` regardless of the value of the `multi` option.
 * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operators like `$set`.
 *
 * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`
 * and `post('updateOne')` instead.
 *
 * ####Example:
 *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });
 *     res.n; // Number of documents matched
 *     res.nModified; // Number of documents modified
 *
 * This function triggers the following middleware.
 *
 * - `updateOne()`
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model.update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */

Query.prototype.updateOne = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'updateOne', conditions, doc, options, callback);
};

/**
 * Declare and/or execute this query as a replaceOne() operation. Same as
 * `update()`, except MongoDB will replace the existing document and will
 * not accept any [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operators (`$set`, etc.)
 *
 * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`
 * and `post('replaceOne')` instead.
 *
 * ####Example:
 *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });
 *     res.n; // Number of documents matched
 *     res.nModified; // Number of documents modified
 *
 * This function triggers the following middleware.
 *
 * - `replaceOne()`
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model.update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */

Query.prototype.replaceOne = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  this.setOptions({ overwrite: true });
  return _update(this, 'replaceOne', conditions, doc, options, callback);
};

/*!
 * Internal helper for update, updateMany, updateOne, replaceOne
 */

function _update(query, op, filter, doc, options, callback) {
  // make sure we don't send in the whole Document to merge()
  query.op = op;
  filter = utils.toObject(filter);
  doc = doc || {};

  const oldCb = callback;
  if (oldCb) {
    if (typeof oldCb === 'function') {
      callback = function(error, result) {
        oldCb(error, result ? result.result : {ok: 0, n: 0, nModified: 0});
      };
    } else {
      throw new Error('Invalid callback() argument.');
    }
  }

  // strict is an option used in the update checking, make sure it gets set
  if (options != null) {
    if ('strict' in options) {
      query._mongooseOptions.strict = options.strict;
    }
  }

  if (!(filter instanceof Query) &&
      filter != null &&
      filter.toString() !== '[object Object]') {
    query.error(new ObjectParameterError(filter, 'filter', op));
  } else {
    query.merge(filter);
  }

  if (utils.isObject(options)) {
    query.setOptions(options);
  }

  query._mergeUpdate(doc);

  // Hooks
  if (callback) {
    if (op === 'update') {
      query._execUpdate(callback);
      return query;
    }
    query['_' + op](callback);
    return query;
  }

  return Query.base[op].call(query, filter, doc, options, callback);
}

/**
 * Runs a function `fn` and treats the return value of `fn` as the new value
 * for the query to resolve to.
 *
 * Any functions you pass to `map()` will run **after** any post hooks.
 *
 * ####Example:
 *
 *     const res = await MyModel.findOne().map(res => {
 *       // Sets a `loadedAt` property on the doc that tells you the time the
 *       // document was loaded.
 *       return res == null ?
 *         res :
 *         Object.assign(res, { loadedAt: new Date() });
 *     });
 *
 * @method map
 * @memberOf Query
 * @instance
 * @param {Function} fn function to run to transform the query result
 * @return {Query} this
 */

Query.prototype.map = function(fn) {
  this._transforms.push(fn);
  return this;
};

/**
 * Make this query throw an error if no documents match the given `filter`.
 * This is handy for integrating with async/await, because `orFail()` saves you
 * an extra `if` statement to check if no document was found.
 *
 * ####Example:
 *
 *     // Throws if no doc returned
 *     await Model.findOne({ foo: 'bar' }).orFail();
 *
 *     // Throws if no document was updated
 *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();
 *
 *     // Throws "No docs found!" error if no docs match `{ foo: 'bar' }`
 *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));
 *
 *     // Throws "Not found" error if no document was found
 *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).
 *       orFail(() => Error('Not found'));
 *
 * @method orFail
 * @memberOf Query
 * @instance
 * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`
 * @return {Query} this
 */

Query.prototype.orFail = function(err) {
  this.map(res => {
    switch (this.op) {
      case 'find':
        if (res.length === 0) {
          throw _orFailError(err, this);
        }
        break;
      case 'findOne':
        if (res == null) {
          throw _orFailError(err, this);
        }
        break;
      case 'update':
      case 'updateMany':
      case 'updateOne':
        if (get(res, 'result.nModified') === 0) {
          throw _orFailError(err, this);
        }
        break;
      case 'findOneAndDelete':
        if (get(res, 'lastErrorObject.n') === 0) {
          throw _orFailError(err, this);
        }
        break;
      case 'findOneAndUpdate':
      case 'findOneAndReplace':
        if (get(res, 'lastErrorObject.updatedExisting') === false) {
          throw _orFailError(err, this);
        }
        break;
      case 'deleteMany':
      case 'deleteOne':
      case 'remove':
        if (res.n === 0) {
          throw _orFailError(err, this);
        }
        break;
      default:
        break;
    }

    return res;
  });
  return this;
};

/*!
 * Get the error to throw for `orFail()`
 */

function _orFailError(err, query) {
  if (typeof err === 'function') {
    err = err.call(query);
  }

  if (err == null) {
    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
  }

  return err;
}

/**
 * Executes the query
 *
 * ####Examples:
 *
 *     var promise = query.exec();
 *     var promise = query.exec('update');
 *
 *     query.exec(callback);
 *     query.exec('find', callback);
 *
 * @param {String|Function} [operation]
 * @param {Function} [callback] optional params depend on the function being called
 * @return {Promise}
 * @api public
 */

Query.prototype.exec = function exec(op, callback) {
  const _this = this;

  if (typeof op === 'function') {
    callback = op;
    op = null;
  } else if (typeof op === 'string') {
    this.op = op;
  }

  if (callback != null) {
    callback = this.model.$wrapCallback(callback);
  }

  return utils.promiseOrCallback(callback, (cb) => {
    if (!_this.op) {
      cb();
      return;
    }

    this._hooks.execPre('exec', this, [], (error) => {
      if (error) {
        return cb(error);
      }
      this[this.op].call(this, (error, res) => {
        if (error) {
          return cb(error);
        }

        this._hooks.execPost('exec', this, [], {}, (error) => {
          if (error) {
            return cb(error);
          }

          cb(null, res);
        });
      });
    });
  }, this.model.events);
};

/*!
 * ignore
 */

function _wrapThunkCallback(query, cb) {
  return function(error, res) {
    if (error != null) {
      return cb(error);
    }

    for (const fn of query._transforms) {
      try {
        res = fn(res);
      } catch (error) {
        return cb(error);
      }
    }

    return cb(null, res);
  };
}

/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 *
 * @param {Function} [resolve]
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */

Query.prototype.then = function(resolve, reject) {
  return this.exec().then(resolve, reject);
};

/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 * Like `.then()`, but only takes a rejection handler.
 *
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */

Query.prototype.catch = function(reject) {
  return this.exec().then(null, reject);
};

/*!
 * ignore
 */

Query.prototype._pre = function(fn) {
  this._hooks.pre('exec', fn);
  return this;
};

/*!
 * ignore
 */

Query.prototype._post = function(fn) {
  this._hooks.post('exec', fn);
  return this;
};

/*!
 * Casts obj for an update command.
 *
 * @param {Object} obj
 * @return {Object} obj after casting its values
 * @api private
 */

Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
  let strict;
  if ('strict' in this._mongooseOptions) {
    strict = this._mongooseOptions.strict;
  } else if (this.schema && this.schema.options) {
    strict = this.schema.options.strict;
  } else {
    strict = true;
  }

  let omitUndefined = false;
  if ('omitUndefined' in this._mongooseOptions) {
    omitUndefined = this._mongooseOptions.omitUndefined;
  }

  let useNestedStrict;
  if ('useNestedStrict' in this.options) {
    useNestedStrict = this.options.useNestedStrict;
  }

  let schema = this.schema;
  const filter = this._conditions;
  if (schema != null &&
      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&
      typeof filter[schema.options.discriminatorKey] !== 'object' &&
      schema.discriminators != null) {
    const discriminatorValue = filter[schema.options.discriminatorKey];
    const byValue = helpers.getDiscriminatorByValue(this.model, discriminatorValue);
    schema = schema.discriminators[discriminatorValue] ||
      (byValue && byValue.schema) ||
      schema;
  }

  return castUpdate(schema, obj, {
    overwrite: overwrite,
    strict: strict,
    omitUndefined,
    useNestedStrict: useNestedStrict
  }, this, this._conditions);
};

/*!
 * castQuery
 * @api private
 */

function castQuery(query) {
  try {
    return query.cast(query.model);
  } catch (err) {
    return err;
  }
}

/*!
 * castDoc
 * @api private
 */

function castDoc(query, overwrite) {
  try {
    return query._castUpdate(query._update, overwrite);
  } catch (err) {
    return err;
  }
}

/**
 * Specifies paths which should be populated with other documents.
 *
 * ####Example:
 *
 *     Kitten.findOne().populate('owner').exec(function (err, kitten) {
 *       console.log(kitten.owner.name) // Max
 *     })
 *
 *     Kitten.find().populate({
 *       path: 'owner',
 *       select: 'name',
 *       match: { color: 'black' },
 *       options: { sort: { name: -1 } }
 *     }).exec(function (err, kittens) {
 *       console.log(kittens[0].owner.name) // Zoopa
 *     })
 *
 *     // alternatively
 *     Kitten.find().populate('owner', 'name', null, {sort: { name: -1 }}).exec(function (err, kittens) {
 *       console.log(kittens[0].owner.name) // Zoopa
 *     })
 *
 * Paths are populated after the query executes and a response is received. A
 * separate query is then executed for each path specified for population. After
 * a response for each query has also been returned, the results are passed to
 * the callback.
 *
 * @param {Object|String} path either the path to populate or an object specifying all parameters
 * @param {Object|String} [select] Field selection for the population query
 * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
 * @param {Object} [match] Conditions for the population query
 * @param {Object} [options] Options for the population query (sort, etc)
 * @param {String} [options.path=null] The path to populate.
 * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.
 * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).
 * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.
 * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.
 * @see population ./populate.html
 * @see Query#select #query_Query-select
 * @see Model.populate #model_Model.populate
 * @return {Query} this
 * @api public
 */

Query.prototype.populate = function() {
  // Bail when given no truthy arguments
  if (!Array.from(arguments).some(Boolean)) {
    return this;
  }

  const res = utils.populate.apply(null, arguments);

  // Propagate readConcern and readPreference and lean from parent query,
  // unless one already specified
  if (this.options != null) {
    const readConcern = this.options.readConcern;
    const readPref = this.options.readPreference;

    for (let i = 0; i < res.length; ++i) {
      if (readConcern != null && get(res[i], 'options.readConcern') == null) {
        res[i].options = res[i].options || {};
        res[i].options.readConcern = readConcern;
      }
      if (readPref != null && get(res[i], 'options.readPreference') == null) {
        res[i].options = res[i].options || {};
        res[i].options.readPreference = readPref;
      }
    }
  }

  const opts = this._mongooseOptions;

  if (opts.lean != null) {
    const lean = opts.lean;
    for (let i = 0; i < res.length; ++i) {
      if (get(res[i], 'options.lean') == null) {
        res[i].options = res[i].options || {};
        res[i].options.lean = lean;
      }
    }
  }

  if (!utils.isObject(opts.populate)) {
    opts.populate = {};
  }

  const pop = opts.populate;

  for (let i = 0; i < res.length; ++i) {
    const path = res[i].path;
    if (pop[path] && pop[path].populate && res[i].populate) {
      res[i].populate = pop[path].populate.concat(res[i].populate);
    }
    pop[res[i].path] = res[i];
  }

  return this;
};

/**
 * Gets a list of paths to be populated by this query
 *
 * ####Example:
 *      bookSchema.pre('findOne', function() {
 *        let keys = this.getPopulatedPaths(); // ['author']
 *      });
 *      ...
 *      Book.findOne({}).populate('author');
 *
 * ####Example:
 *      // Deep populate
 *      const q = L1.find().populate({
 *        path: 'level2',
 *        populate: { path: 'level3' }
 *      });
 *      q.getPopulatedPaths(); // ['level2', 'level2.level3']
 *
 * @return {Array} an array of strings representing populated paths
 * @api public
 */

Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
  const obj = this._mongooseOptions.populate || {};
  const ret = Object.keys(obj);
  for (const path of Object.keys(obj)) {
    const pop = obj[path];
    if (!Array.isArray(pop.populate)) {
      continue;
    }
    _getPopulatedPaths(ret, pop.populate, path + '.');
  }
  return ret;
};

/*!
 * ignore
 */

function _getPopulatedPaths(list, arr, prefix) {
  for (const pop of arr) {
    list.push(prefix + pop.path);
    if (!Array.isArray(pop.populate)) {
      continue;
    }
    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');
  }
}

/**
 * Casts this query to the schema of `model`
 *
 * ####Note
 *
 * If `obj` is present, it is cast instead of this query.
 *
 * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`
 * @param {Object} [obj]
 * @return {Object}
 * @api public
 */

Query.prototype.cast = function(model, obj) {
  obj || (obj = this._conditions);

  model = model || this.model;

  try {
    return cast(model.schema, obj, {
      upsert: this.options && this.options.upsert,
      strict: (this.options && 'strict' in this.options) ?
        this.options.strict :
        get(model, 'schema.options.strict', null),
      strictQuery: (this.options && this.options.strictQuery) ||
        get(model, 'schema.options.strictQuery', null)
    }, this);
  } catch (err) {
    // CastError, assign model
    if (typeof err.setModel === 'function') {
      err.setModel(model);
    }
    throw err;
  }
};

/**
 * Casts selected field arguments for field selection with mongo 2.2
 *
 *     query.select({ ids: { $elemMatch: { $in: [hexString] }})
 *
 * @param {Object} fields
 * @see https://github.com/Automattic/mongoose/issues/1091
 * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/
 * @api private
 */

Query.prototype._castFields = function _castFields(fields) {
  let selected,
      elemMatchKeys,
      keys,
      key,
      out,
      i;

  if (fields) {
    keys = Object.keys(fields);
    elemMatchKeys = [];
    i = keys.length;

    // collect $elemMatch args
    while (i--) {
      key = keys[i];
      if (fields[key].$elemMatch) {
        selected || (selected = {});
        selected[key] = fields[key];
        elemMatchKeys.push(key);
      }
    }
  }

  if (selected) {
    // they passed $elemMatch, cast em
    try {
      out = this.cast(this.model, selected);
    } catch (err) {
      return err;
    }

    // apply the casted field args
    i = elemMatchKeys.length;
    while (i--) {
      key = elemMatchKeys[i];
      fields[key] = out[key];
    }
  }

  return fields;
};

/**
 * Applies schematype selected options to this query.
 * @api private
 */

Query.prototype._applyPaths = function applyPaths() {
  this._fields = this._fields || {};
  helpers.applyPaths(this._fields, this.model.schema);

  let _selectPopulatedPaths = true;

  if ('selectPopulatedPaths' in this.model.base.options) {
    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
  }
  if ('selectPopulatedPaths' in this.model.schema.options) {
    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
  }

  if (_selectPopulatedPaths) {
    selectPopulatedFields(this);
  }
};

/**
 * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).
 * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.
 *
 * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.
 *
 * ####Example
 *
 *     // There are 2 ways to use a cursor. First, as a stream:
 *     Thing.
 *       find({ name: /^hello/ }).
 *       cursor().
 *       on('data', function(doc) { console.log(doc); }).
 *       on('end', function() { console.log('Done!'); });
 *
 *     // Or you can use `.next()` to manually get the next doc in the stream.
 *     // `.next()` returns a promise, so you can use promises or callbacks.
 *     var cursor = Thing.find({ name: /^hello/ }).cursor();
 *     cursor.next(function(error, doc) {
 *       console.log(doc);
 *     });
 *
 *     // Because `.next()` returns a promise, you can use co
 *     // to easily iterate through all documents without loading them
 *     // all into memory.
 *     co(function*() {
 *       const cursor = Thing.find({ name: /^hello/ }).cursor();
 *       for (let doc = yield cursor.next(); doc != null; doc = yield cursor.next()) {
 *         console.log(doc);
 *       }
 *     });
 *
 * ####Valid options
 *
 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.
 *
 * @return {QueryCursor}
 * @param {Object} [options]
 * @see QueryCursor
 * @api public
 */

Query.prototype.cursor = function cursor(opts) {
  this._applyPaths();
  this._fields = this._castFields(this._fields);
  this.setOptions({ projection: this._fieldsForExec() });
  if (opts) {
    this.setOptions(opts);
  }

  const options = Object.assign({}, this.options, {
    projection: this.projection()
  });
  try {
    this.cast(this.model);
  } catch (err) {
    return (new QueryCursor(this, options))._markError(err);
  }

  return new QueryCursor(this, options);
};

// the rest of these are basically to support older Mongoose syntax with mquery

/**
 * _DEPRECATED_ Alias of `maxScan`
 *
 * @deprecated
 * @see maxScan #query_Query-maxScan
 * @method maxscan
 * @memberOf Query
 * @instance
 */

Query.prototype.maxscan = Query.base.maxScan;

/**
 * Sets the tailable option (for use with capped collections).
 *
 * ####Example
 *
 *     query.tailable() // true
 *     query.tailable(true)
 *     query.tailable(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Boolean} bool defaults to true
 * @param {Object} [opts] options to set
 * @param {Number} [opts.numberOfRetries] if cursor is exhausted, retry this many times before giving up
 * @param {Number} [opts.tailableRetryInterval] if cursor is exhausted, wait this many milliseconds before retrying
 * @see tailable http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/
 * @api public
 */

Query.prototype.tailable = function(val, opts) {
  // we need to support the tailable({ awaitdata : true }) as well as the
  // tailable(true, {awaitdata :true}) syntax that mquery does not support
  if (val && val.constructor.name === 'Object') {
    opts = val;
    val = true;
  }

  if (val === undefined) {
    val = true;
  }

  if (opts && typeof opts === 'object') {
    for (const key in opts) {
      if (key === 'awaitdata') {
        // For backwards compatibility
        this.options[key] = !!opts[key];
      } else {
        this.options[key] = opts[key];
      }
    }
  }

  return Query.base.tailable.call(this, val);
};

/**
 * Declares an intersects query for `geometry()`.
 *
 * ####Example
 *
 *     query.where('path').intersects().geometry({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     })
 *
 *     query.where('path').intersects({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     })
 *
 * ####NOTE:
 *
 * **MUST** be used after `where()`.
 *
 * ####NOTE:
 *
 * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
 *
 * @method intersects
 * @memberOf Query
 * @instance
 * @param {Object} [arg]
 * @return {Query} this
 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
 * @see geoIntersects http://docs.mongodb.org/manual/reference/operator/geoIntersects/
 * @api public
 */

/**
 * Specifies a `$geometry` condition
 *
 * ####Example
 *
 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
 *
 *     // or
 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
 *
 *     // or
 *     var polyC = [ 0, 0 ]
 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
 *
 *     // or
 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
 *
 * The argument is assigned to the most recent path passed to `where()`.
 *
 * ####NOTE:
 *
 * `geometry()` **must** come after either `intersects()` or `within()`.
 *
 * The `object` argument must contain `type` and `coordinates` properties.
 * - type {String}
 * - coordinates {Array}
 *
 * @method geometry
 * @memberOf Query
 * @instance
 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
 * @return {Query} this
 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

/**
 * Specifies a `$near` or `$nearSphere` condition
 *
 * These operators return documents sorted by distance.
 *
 * ####Example
 *
 *     query.where('loc').near({ center: [10, 10] });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
 *
 * @method near
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Object} val
 * @return {Query} this
 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

/*!
 * Overwriting mquery is needed to support a couple different near() forms found in older
 * versions of mongoose
 * near([1,1])
 * near(1,1)
 * near(field, [1,2])
 * near(field, 1, 2)
 * In addition to all of the normal forms supported by mquery
 */

Query.prototype.near = function() {
  const params = [];
  const sphere = this._mongooseOptions.nearSphere;

  // TODO refactor

  if (arguments.length === 1) {
    if (Array.isArray(arguments[0])) {
      params.push({center: arguments[0], spherical: sphere});
    } else if (typeof arguments[0] === 'string') {
      // just passing a path
      params.push(arguments[0]);
    } else if (utils.isObject(arguments[0])) {
      if (typeof arguments[0].spherical !== 'boolean') {
        arguments[0].spherical = sphere;
      }
      params.push(arguments[0]);
    } else {
      throw new TypeError('invalid argument');
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      params.push({center: [arguments[0], arguments[1]], spherical: sphere});
    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {
      params.push(arguments[0]);
      params.push({center: arguments[1], spherical: sphere});
    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {
      params.push(arguments[0]);
      if (typeof arguments[1].spherical !== 'boolean') {
        arguments[1].spherical = sphere;
      }
      params.push(arguments[1]);
    } else {
      throw new TypeError('invalid argument');
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'
        && typeof arguments[2] === 'number') {
      params.push(arguments[0]);
      params.push({center: [arguments[1], arguments[2]], spherical: sphere});
    } else {
      throw new TypeError('invalid argument');
    }
  } else {
    throw new TypeError('invalid argument');
  }

  return Query.base.near.apply(this, params);
};

/**
 * _DEPRECATED_ Specifies a `$nearSphere` condition
 *
 * ####Example
 *
 *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });
 *
 * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.
 *
 * ####Example
 *
 *     query.where('loc').near({ center: [10, 10], spherical: true });
 *
 * @deprecated
 * @see near() #query_Query-near
 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
 */

Query.prototype.nearSphere = function() {
  this._mongooseOptions.nearSphere = true;
  this.near.apply(this, arguments);
  return this;
};

/**
 * Returns an asyncIterator for use with [`for/await/of` loops](http://bit.ly/async-iterators)
 * This function *only* works for `find()` queries.
 * You do not need to call this function explicitly, the JavaScript runtime
 * will call it for you.
 *
 * ####Example
 *
 *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {
 *       console.log(doc.name);
 *     }
 *
 * Node.js 10.x supports async iterators natively without any flags. You can
 * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).
 *
 * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If
 * `Symbol.asyncIterator` is undefined, that means your Node.js version does not
 * support async iterators.
 *
 * @method Symbol.asyncIterator
 * @memberOf Query
 * @instance
 * @api public
 */

if (Symbol.asyncIterator != null) {
  Query.prototype[Symbol.asyncIterator] = function() {
    return this.cursor().transformNull().map(doc => {
      return doc == null ? { done: true } : { value: doc, done: false };
    });
  };
}

/**
 * Specifies a `$polygon` condition
 *
 * ####Example
 *
 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
 *     query.polygon('loc', [10,20], [13, 25], [7,15])
 *
 * @method polygon
 * @memberOf Query
 * @instance
 * @param {String|Array} [path]
 * @param {Array|Object} [coordinatePairs...]
 * @return {Query} this
 * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

/**
 * Specifies a `$box` condition
 *
 * ####Example
 *
 *     var lowerLeft = [40.73083, -73.99756]
 *     var upperRight= [40.741404,  -73.988135]
 *
 *     query.where('loc').within().box(lowerLeft, upperRight)
 *     query.box({ ll : lowerLeft, ur : upperRight })
 *
 * @method box
 * @memberOf Query
 * @instance
 * @see $box http://docs.mongodb.org/manual/reference/operator/box/
 * @see within() Query#within #query_Query-within
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @param {Object} val
 * @param [Array] Upper Right Coords
 * @return {Query} this
 * @api public
 */

/*!
 * this is needed to support the mongoose syntax of:
 * box(field, { ll : [x,y], ur : [x2,y2] })
 * box({ ll : [x,y], ur : [x2,y2] })
 */

Query.prototype.box = function(ll, ur) {
  if (!Array.isArray(ll) && utils.isObject(ll)) {
    ur = ll.ur;
    ll = ll.ll;
  }
  return Query.base.box.call(this, ll, ur);
};

/**
 * Specifies a `$center` or `$centerSphere` condition.
 *
 * ####Example
 *
 *     var area = { center: [50, 50], radius: 10, unique: true }
 *     query.where('loc').within().circle(area)
 *     // alternatively
 *     query.circle('loc', area);
 *
 *     // spherical calculations
 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
 *     query.where('loc').within().circle(area)
 *     // alternatively
 *     query.circle('loc', area);
 *
 * @method circle
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Object} area
 * @return {Query} this
 * @see $center http://docs.mongodb.org/manual/reference/operator/center/
 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
 * @see $geoWithin http://docs.mongodb.org/manual/reference/operator/geoWithin/
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

/**
 * _DEPRECATED_ Alias for [circle](#query_Query-circle)
 *
 * **Deprecated.** Use [circle](#query_Query-circle) instead.
 *
 * @deprecated
 * @method center
 * @memberOf Query
 * @instance
 * @api public
 */

Query.prototype.center = Query.base.circle;

/**
 * _DEPRECATED_ Specifies a `$centerSphere` condition
 *
 * **Deprecated.** Use [circle](#query_Query-circle) instead.
 *
 * ####Example
 *
 *     var area = { center: [50, 50], radius: 10 };
 *     query.where('loc').within().centerSphere(area);
 *
 * @deprecated
 * @param {String} [path]
 * @param {Object} val
 * @return {Query} this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphgreo
 * @a0i public* */

Sõery.protoöype.centerSphere = function() {
  if (arguments[0] && argumends[4].conwtructor.name ===2'Orject') {
    argqmends[0]/spherICal = true;
  l
"`if (Argumentc[1U && arwumentsK1].gonstructor.name === 'Objåct') {
    argueEnts[1].spherical = t2ue;
  }
  Query.base.circle,apply(this,(argumants);
};
/**
 * Dqtgríine{ if fidld 3electKgn has been made.
 *
 * @method seLected
 * @memberOb Query
"*  instaNce
 * @rettrn {Coolean} * @a`i public* */

/**
 * Determines if iêcluscve fkeld selection has bemn ma`u.
 *
!*     quevy.selecôeDInklusiwely)) // fahse
 *     pwery.select('name')
 *     query.selectådInc,usively() //`tPuå
$*
 * @method selectedInclusively
 * @memberOf Quåry
 * @instance
 * @return {Booleaj}
 * @api public
 */
*Qugrù.prototype.selecôe$Inclurively"= funcôion selectedInclusively() {
  return is	nclusive(this._fiulds);
u;
Š/+*
 * @etermines if %xclusive field sel%ction has jmen made.
 *
$*     y5erù.selectedExcdusively() // false
 *   ! quur}.selec4('-name')
`:     query.selectmdUxclusively() // |rue
 Š     quepy.selectedÉoclusively() // falqe
 *
 * @method se,ectedExclucively
 ( @memberOb Query
 * @instance
 * @return {@oolean}
 * @api`public* */

Query.pbototype.se,ec4gdExchusivgly = function select!dEpclusivEly() {
  if((!this._fie,äs) k*$`  return false»
  }

  cOns4 keys = Nbjuct.+eys(this._faelds);
  if((keys.lEncth ==9 0) {*  ! våturn dalóe;
  }
  for (let i = 0; é < keyq.length; ++é) {
    conqT key = keys[i];
    if (kEy =5= '_id/9"û
      continue;
 "  m
    if  this._fidldq[iey] == 0 || this.ßfi%l`s[key] === falce+ {
   0  return true;    =
  u

  retUrn fa|se{
};

/.!
 * Export
 */
Kmodule.Epports = Quärx;
