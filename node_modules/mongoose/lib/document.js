'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;
const InternalCache = require('./internal');
const MongooseError = require('./error/index');
const MixedSchema = require('./schema/mixed');
const ObjectExpectedError = require('./error/objectExpected');
const ObjectParameterError = require('./error/objectParameter');
const StrictModeError = require('./error/strict');
const ValidatorError = require('./schematype').ValidatorError;
const VirtualType = require('./virtualtype');
const cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');
const compile = require('./helpers/document/compile').compile;
const defineKey = require('./helpers/document/compile').defineKey;
const flatten = require('./helpers/common').flatten;
const get = require('./helpers/get');
const getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');
const idGetter = require('./plugins/idGetter');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const isExclusive = require('./helpers/projection/isExclusive');
const inspect = require('util').inspect;
const internalToObjectOptions = require('./options').internalToObjectOptions;
const mpath = require('mpath');
const utils = require('./utils');

const ValidationError = MongooseError.ValidationError;
const clone = utils.clone;
const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;

const arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;
const documentArrayParent = require('./helpers/symbols').documentArrayParent;
const documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;
const getSymbol = require('./helpers/symbols').getSymbol;
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;

let DocumentArray;
let MongooseArray;
let Embedded;

const specialProperties = utils.specialProperties;

/**
 * The core Mongoose document constructor. You should not call this directly,
 * the Mongoose [Model constructor](./api.html#Model) calls this for you.
 *
 * @param {Object} obj the values to set
 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */

function Document(obj, fields, skipId, options) {
  if (typeof skipId === 'object' && skipId != null) {
    options = skipId;
    skipId = options.skipId;
  }
  options = options || {};

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = 'isNew' in options ? options.isNew : true;
  this.errors = undefined;
  this.$__.$options = options || {};

  if (obj != null && typeof obj !== 'object') {
    throw new ObjectParameterError(obj, 'obj', 'Document');
  }

  const schema = this.schema;

  if (typeof fields === 'boolean') {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options.strict;
    this.$__.selected = fields;
  }

  const required = schema.requiredPaths(true);
  for (let i = 0; i < required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);

  let exclude = null;

  // determine if this doc is a result of a query with
  // excluded fields
  if (utils.isPOJO(fields)) {
    exclude = isExclusive(fields);
  }

  const hasIncludedChildren = exclude === false && fields ?
    $__hasIncludedChildren(fields) :
    {};

  if (this._doc == null) {
    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);

    // By default, defaults get applied **before** setting initial values
    // Re: gh-6155
    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
      isNew: this.isNew
    });
  }

  if (obj) {
    if (obj instanceof Document) {
      this.isNew = obj.isNew;
    }
    // Skip set hooks
    if (this.$__original_set) {
      this.$__original_set(obj, undefined, true);
    } else {
      this.$set(obj, undefined, true);
    }
  }

  // Function defaults get applied **after** setting initial values so they
  // see the full doc rather than an empty one, unless they opt out.
  // Re: gh-3781, gh-6155
  if (options.willInit) {
    EventEmitter.prototype.once.call(this, 'init', () => {
      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
        isNew: this.isNew
      });
    });
  } else {
    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
      isNew: this.isNew
    });
  }

  this.$__._id = this._id;
  this.$locals = {};

  if (!schema.options.strict && obj) {
    const _this = this;
    const keys = Object.keys(this._doc);

    keys.forEach(function(key) {
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
      }
    });
  }

  applyQueue(this);
}

/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */
utils.each(
  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
    'removeAllListeners', 'addListener'],
  function(emitterFn) {
    Document.prototype[emitterFn] = function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
  });

Document.prototype.constructor = Document;

/**
 * The documents schema.
 *
 * @api public
 * @property schema
 * @memberOf Document
 * @instance
 */

Document.prototype.schema;

/**
 * Empty object that you can use for storing properties on the document. This
 * is handy for passing data to middleware without conflicting with Mongoose
 * internals.
 *
 * ####Example:
 *
 *     schema.pre('save', function() {
 *       // Mongoose will set `isNew` to `false` if `save()` succeeds
 *       this.$locals.wasNew = this.isNew;
 *     });
 *
 *     schema.post('save', function() {
 *       // Prints true if `isNew` was set before `save()`
 *       console.log(this.$locals.wasNew);
 *     });
 *
 * @api public
 * @property $locals
 * @memberOf Document
 * @instance
 */

Object.defineProperty(Document.prototype, '$locals', {
  configurable: false,
  enumerable: false,
  writable: true
});

/**
 * Boolean flag specifying if the document is new.
 *
 * @api public
 * @property isNew
 * @memberOf Document
 * @instance
 */

Document.prototype.isNew;

/**
 * The string version of this documents _id.
 *
 * ####Note:
 *
 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
 *
 *     new Schema({ name: String }, { id: false });
 *
 * @api public
 * @see Schema options /docs/guide.html#options
 * @property id
 * @memberOf Document
 * @instance
 */

Document.prototype.id;

/**
 * Hash containing current validation errors.
 *
 * @api public
 * @property errors
 * @memberOf Document
 * @instance
 */

Document.prototype.errors;

/*!
 * ignore
 */

function $__hasIncludedChildren(fields) {
  const hasIncludedChildren = {};
  const keys = Object.keys(fields);
  for (let j = 0; j < keys.length; ++j) {
    const parts = keys[j].split('.');
    const c = [];
    for (let k = 0; k < parts.length; ++k) {
      c.push(parts[k]);
      hasIncludedChildren[c.join('.')] = 1;
    }
  }

  return hasIncludedChildren;
}

/*!
 * ignore
 */

function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
  const paths = Object.keys(doc.schema.paths);
  const plen = paths.length;

  for (let i = 0; i < plen; ++i) {
    let def;
    let curPath = '';
    const p = paths[i];

    if (p === '_id' && skipId) {
      continue;
    }

    const type = doc.schema.paths[p];
    const path = p.split('.');
    const len = path.length;
    let included = false;
    let doc_ = doc._doc;

    for (let j = 0; j < len; ++j) {
      if (doc_ == null) {
        break;
      }

      const piece = path[j];
      curPath += (!curPath.length ? '' : '.') + piece;

      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (j === len - 1) {
        if (doc_[piece] !== void 0) {
          break;
        }

        if (typeof type.defaultValue === 'function') {
          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
            break;
          }
          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
            break;
          }
        } else if (!isBeforeSetters) {
          // Non-function defaults should always run **before** setters
          continue;
        }

        if (pathsToSkip && pathsToSkip[curPath]) {
          break;
        }

        if (fields && exclude !== null) {
          if (exclude === true) {
            // apply defaults to all non-excluded fields
            if (p in fields) {
              continue;
            }

            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          } else if (included) {
            // selected field
            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          }
        } else {
          def = type.getDefault(doc, false);
          if (typeof def !== 'undefined') {
            doc_[piece] = def;
            doc.$__.activePaths.default(p);
          }
        }
      } else {
        doc_ = doc_[piece];
      }
    }
  }
}

/**
 * Builds the default doc structure
 *
 * @param {Object} obj
 * @param {Object} [fields]
 * @param {Boolean} [skipId]
 * @api private
 * @method $__buildDoc
 * @memberOf Document
 * @instance
 */

Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
};

/*!
 * Converts to POJO when you use the document for querying
 */

Document.prototype.toBSON = function() {
  return this.toObject(internalToObjectOptions);
};

/**
 * Initializes the document without setters or marking anything modified.
 *
 * Called internally after a document is returned from mongodb. Normally,
 * you do **not** need to call this function on your own.
 *
 * This function triggers `init` [middleware](/docs/middleware.html).
 * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).
 *
 * @param {Object} doc document returned by mongo
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.init = function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
};

/*!
 * ignore
 */

Document.prototype.$__init = function(doc, opts) {
  this.isNew = false;
  this.$init = true;
  opts = opts || {};

  // handle docs with populated paths
  // If doc._id is not null or undefined
  if (doc._id !== null && doc._id !== undefined &&
    opts.populated && opts.populated.length) {
    const id = String(doc._id);
    for (let i = 0; i < opts.populated.length; ++i) {
      const item = opts.populated[i];
      if (item.isVirtual) {
        this.populated(item.path, utils.getValue(item.path, doc), item);
      } else {
        this.populated(item.path, item._docs[id], item);
      }
    }
  }

  init(this, doc, this._doc, opts);

  this.emit('init', this);
  this.constructor.emit('init', this);

  this.$__._id = this._id;

  return this;
};

/*!
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
 * @api private
 */

function init(self, obj, doc, opts, prefix) {
  prefix = prefix || '';

  const keys = Object.keys(obj);
  const len = keys.length;
  let schema;
  let path;
  let i;
  let index = 0;

  while (index < len) {
    _init(index++);
  }

  function _init(index) {
    i = keys[index];
    path = prefix + i;
    schema = self.schema.path(path);

    // Should still work if not a model-level discriminator, but should not be
    // necessary. This is *only* to catch the case where we queried using the
    // base model and the discriminated model has a projection
    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {
      return;
    }

    if (!schema && utils.isPOJO(obj[i])) {
      // assume nested object
      if (!doc[i]) {
        doc[i] = {};
      }
      init(self, obj[i], doc[i], opts, path + '.');
    } else if (!schema) {
      doc[i] = obj[i];
    } else {
      if (obj[i] === null) {
        doc[i] = null;
      } else if (obj[i] !== undefined) {
        const intCache = obj[i].$__ || {};
        const wasPopulated = intCache.wasPopulated || null;

        if (schema && !wasPopulated) {
          try {
            doc[i] = schema.cast(obj[i], self, true);
          } catch (e) {
            self.invalidate(e.path, new ValidatorError({
              path: e.path,
              message: e.message,
              type: 'cast',
              value: e.value
            }));
          }
        } else {
          doc[i] = obj[i];
        }
      }
      // mark as hydrated
      if (!self.isModified(path)) {
        self.$__.activePaths.init(path);
      }
    }
  }
}

/**
 * Sends an update command with this document `_id` as the query selector.
 *
 * ####Example:
 *
 *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);
 *
 * ####Valid options:
 *
 *  - same as in [Model.update](#model_Model.update)
 *
 * @see Model.update #model_Model.update
 * @param {Object} doc
 * @param {Object} options
 * @param {Function} callback
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.update = function update() {
  const args = utils.args(arguments);
  args.unshift({_id: this._id});
  const query = this.constructor.update.apply(this.constructor, args);

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  return query;
};

/**
 * Sends an updateOne command with this document `_id` as the query selector.
 *
 * ####Example:
 *
 *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);
 *
 * ####Valid options:
 *
 *  - same as in [Model.updateOne](#model_Model.updateOne)
 *
 * @see Model.updateOne #model_Model.updateOne
 * @param {Object} doc
 * @param {Object} options
 * @param {Function} callback
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.updateOne = function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({_id: this._id}, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [], {}, cb);
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
};

/**
 * Sends a replaceOne command with this document `_id` as the query selector.
 *
 * ####Valid options:
 *
 *  - same as in [Model.replaceOne](#model_Model.replaceOne)
 *
 * @see Model.replaceOne #model_Model.replaceOne
 * @param {Object} doc
 * @param {Object} options
 * @param {Function} callback
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.replaceOne = function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
};

/**
 * Getter/setter around the session associated with this document. Used to
 * automatically set `session` if you `save()` a doc that you got from a
 * query with an associated session.
 *
 * ####Example:
 *
 *     const session = MyModel.startSession();
 *     const doc = await MyModel.findOne().session(session);
 *     doc.$session() === session; // true
 *     doc.$session(null);
 *     doc.$session() === null; // true
 *
 * If this is a top-level document, setting the session propagates to all child
 * docs.
 *
 * @param {ClientSession} [session] overwrite the current session
 * @return {ClientSession}
 * @method $session
 * @api public
 * @memberOf Document
 */

Document.prototype.$session = function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;

  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
};

/**
 * Overwrite all values in this document with the values of `obj`, except
 * for immutable properties. Behaves similarly to `set()`, except for it
 * unsets all properties that aren't in `obj`.
 *
 * @param {Object} obj the object to overwrite this document with
 * @method overwrite
 * @name overwrite
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.overwrite = function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
};

/**
 * Alias for `set()`, used internally to avoid conflicts
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
 * @method $set
 * @name $set
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$set = function $set(path, val, type, options) {
  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path === null || path === void 0) {
      const _ = path;
      path = val;
      val = _;
    } else {
      prefix = val ? val + '.' : '';

      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path._doc;
        }
      }

      keys = Object.keys(path);
      const len = keys.length;

      if (len === 0 && !this.schema.options.minimize) {
        if (val) {
          this.$set(val, {});
        }
        return this;
      }

      while (i < len) {
        _handleIndex.call(this, i++);
      }

      return this;
    }
  } else {
    this.$__.$setCalled.add(path);
  }

  function _handleIndex(i) {
    key = keys[i];
    const pathName = prefix + key;
    pathtype = this.schema.pathType(pathName);

    // On initial set, delete any nested keys if we're going to overwrite
    // them to ensure we keep the user's key order.
    if (type === true &&
        !prefix &&
        path[key] != null &&
        pathtype === 'nested' &&
        this._doc[key] != null &&
        Object.keys(this._doc[key]).length === 0) {
      delete this._doc[key];
    }

    if (typeof path[key] === 'object' &&
        !utils.isNativeObject(path[key]) &&
        !utils.isMongooseType(path[key]) &&
        path[key] != null &&
        pathtype !== 'virtual' &&
        pathtype !== 'real' &&
        !(this.$__path(pathName) instanceof MixedSchema) &&
        !(this.schema.paths[pathName] &&
        this.schema.paths[pathName].options &&
        this.schema.paths[pathName].options.ref)) {
      this.$__.$setCalled.add(prefix + key);
      this.$set(path[key], prefix + key, constructing);
    } else if (strict) {
      // Don't overwrite defaults with undefined keys (gh-3981)
      if (constructing && path[key] === void 0 &&
          this.get(key) !== void 0) {
        return;
      }

      if (pathtype === 'adhocOrUndefined') {
        pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
      }

      if (pathtype === 'real' || pathtype === 'virtual') {
        // Check for setting single embedded schema to document (gh-3535)
        let p = path[key];
        if (this.schema.paths[pathName] &&
            this.schema.paths[pathName].$isSingleNested &&
            path[key] instanceof Document) {
          p = p.toObject({ virtuals: false, transform: false });
        }
        this.$set(prefix + key, p, constructing);
      } else if (pathtype === 'nested' && path[key] instanceof Document) {
        this.$set(prefix + key,
          path[key].toObject({transform: false}), constructing);
      } else if (strict === 'throw') {
        if (pathtype === 'nested') {
          throw new ObjectExpectedError(key, path[key]);
        } else {
          throw new StrictModeError(key);
        }
      }
    } else if (path[key] !== void 0) {
      this.$set(prefix + key, path[key], constructing);
    }
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  if (utils.isPOJO(val) && val.$__ != null && val._doc != null) {
    val = val._doc;
  }

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }
      this.markModified(path);
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) {
    pathToMark = path;
  } else {
    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');
      if (this.get(subpath, null, { getters: false }) === null) {
        pathToMark = subpath;
        break;
      }
    }

    if (!pathToMark) {
      pathToMark = path;
    }
  }

  // if this doc is being constructed we should not trigger getters
  const priorVal = (() => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      if (modelName === model.modelName || modelName === model.baseModelName) {
        return true;
      }
      return false;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      if (this.ownerDocument) {
        this.ownerDocument().populated(this.$__fullPath(path),
          val._id, { [populateModelSymbol]: val.constructor });
      } else {
        this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      }
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] instanceof Document &&
        val[0].constructor.modelName &&
        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      didPopulate = true;
    }

    // If this path is underneath a single nested schema, we'll call the setter
    // later in `$__set()` because we don't take `_doc` when we iterate through
    // a single nested doc. That's to make sure we get the correct context.
    // Otherwise we would double-call the setter, see gh-7196.
    if (this.schema.singleNestedPaths[path] == null) {
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (!didPopulate && this.$__.populated) {
      delete this.$__.populated[path];
    }

    this.$markValid(path);
  } catch (e) {
    this.invalidate(path,
      new MongooseError.CastError(schema.instance, val, path, e));
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
};

/**
 * Sets the value of a path, or many paths.
 *
 * ####Example:
 *
 *     // path, value
 *     doc.set(path, value)
 *
 *     // object
 *     doc.set({
 *         path  : value
 *       , path2 : {
 *            path  : value
 *         }
 *     })
 *
 *     // on-the-fly cast to number
 *     doc.set(path, value, Number)
 *
 *     // on-the-fly cast to string
 *     doc.set(path, value, String)
 *
 *     // changing strict mode behavior
 *     doc.set(path, value, { strict: false });
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
 * @api public
 * @method set
 * @memberOf Document
 * @instance
 */

Document.prototype.set = Document.prototype.$set;

/**
 * Determine if we should mark this change as modified.
 *
 * @return {Boolean}
 * @api private
 * @method $__shouldModify
 * @memberOf Document
 * @instance
 */

Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }

  if (val === void 0 && !this.isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

  if (val === void 0 && path in this.$__.activePaths.states.default) {
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || this.get(path))) {
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
};

/**
 * Handles the actual setting of the value and marking the path modified if appropriate.
 *
 * @api private
 * @method $__set
 * @memberOf Document
 * @instance
 */

Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
};

/**
 * Gets a raw value from a path (no getters)
 *
 * @param {String} path
 * @api private
 */

Document.prototype.$__getValue = function(path) {
  return utils.getValue(path, this._doc);
};

/**
 * Sets a raw value for a path (no casting, setters, transformations)
 *
 * @param {String} path
 * @param {Object} value
 * @api private
 */

Document.prototype.$__setValue = function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
};

/**
 * Returns the value of a path.
 *
 * ####Example
 *
 *     // path
 *     doc.get('age') // 47
 *
 *     // dynamic casting to a string
 *     doc.get('age', String) // "47"
 *
 * @param {String} path
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes
 * @param {Object} [options]
 * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path
 * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value
 * @api public
 */

Document.prototype.get = function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
    const virtual = this.schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
  const pieces = path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    if (schema.getters.length === 0) {
      return void 0;
    }
    return schema.applyGetters(null, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i]);
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
    return applyGetters(this, utils.clone(obj) || {}, 'virtuals', { path: path });
  }

  return obj;
};

/*!
 * ignore
 */

Document.prototype[getSymbol] = Document.prototype.get;

/**
 * Returns the schematype for the given `path`.
 *
 * @param {String} path
 * @api private
 * @method $__path
 * @memberOf Document
 * @instance
 */

Document.prototype.$__path = function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
};

/**
 * Marks the path as having pending changes to write to the db.
 *
 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
 *
 * ####Example:
 *
 *     doc.mixed.type = 'changed';
 *     doc.markModified('mixed.type');
 *     doc.save() // changes to mixed.type are now persisted
 *
 * @param {String} path the path to mark modified
 * @param {Document} [scope] the scope to run validators with
 * @api public
 */

Document.prototype.markModified = function(path, scope) {
  this.$__.activePaths.modify(path);
  if (scope != null && !this.ownerDocument) {
    this.$__.pathsToScopes[path] = scope;
  }
};

/**
 * Clears the modified state on the specified path.
 *
 * ####Example:
 *
 *     doc.foo = 'bar';
 *     doc.unmarkModified('foo');
 *     doc.save(); // changes to foo will not be persisted
 *
 * @param {String} path the path to unmark modified
 * @api public
 */

Document.prototype.unmarkModified = function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
};

/**
 * Don't run validation on this path or persist changes to this path.
 *
 * ####Example:
 *
 *     doc.foo = null;
 *     doc.$ignore('foo');
 *     doc.save(); // changes to foo will not be persisted and validators won't be run
 *
 * @memberOf Document
 * @instance
 * @method $ignore
 * @param {String} path the path to ignore
 * @api public
 */

Document.prototype.$ignore = function(path) {
  this.$__.activePaths.ignore(path);
};

/**
 * Returns the list of paths that have been directly modified. A direct
 * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,
 * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.
 *
 * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`
 * because a child of `a` was directly modified.
 *
 * ####Example
 *     const schema = new Schema({ foo: String, nested: { bar: String } });
 *     const Model = mongoose.model('Test', schema);
 *     await Model.create({ foo: 'original', nested: { bar: 'original' } });
 *
 *     const doc = await Model.findOne();
 *     doc.nested.bar = 'modified';
 *     doc.directModifiedPaths(); // ['nested.bar']
 *     doc.modifiedPaths(); // ['nested', 'nested.bar']
 *
 * @return {Array}
 * @api public
 */

Document.prototype.directModifiedPaths = function() {
  return Object.keys(this.$__.activePaths.states.modify);
};

/**
 * Returns true if the given path is nullish or only contains empty objects.
 * Useful for determining whether this subdoc will get stripped out by the
 * [minimize option](/docs/guide.html#minimize).
 *
 * ####Example:
 *     const schema = new Schema({ nested: { foo: String } });
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model({});
 *     doc.$isEmpty('nested'); // true
 *     doc.nested.$isEmpty(); // true
 *
 *     doc.nested.foo = 'bar';
 *     doc.$isEmpty('nested'); // false
 *     doc.nested.$isEmpty(); // false
 *
 * @memberOf Document
 * @instance
 * @api public
 * @method $isEmpty
 * @return {Boolean}
 */

Document.prototype.$isEmpty = function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
};

function _isEmpty(v) {
  if (v == null) {
    return true;
  }
  if (typeof v !== 'object' || Array.isArray(v)) {
    return false;
  }
  for (const key of Object.keys(v)) {
    if (!_isEmpty(v[key])) {
      return false;
    }
  }
  return true;
}

/**
 * Returns the list of paths that have been modified.
 *
 * @param {Object} [options]
 * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.
 * @return {Array}
 * @api public
 */

Document.prototype.modifiedPaths = function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
};

/**
 * Returns true if this document was modified, else false.
 *
 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
 *
 * ####Example
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isModified()                      // true
 *     doc.isModified('documents')           // true
 *     doc.isModified('documents.0.title')   // true
 *     doc.isModified('documents otherProp') // true
 *     doc.isDirectModified('documents')     // false
 *
 * @param {String} [path] optional
 * @return {Boolean}
 * @api public
 */

Document.prototype.isModified = function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this.modifiedPaths();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });
    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }
  return this.$__.activePaths.some('modify');
};

/**
 * Checks if a path is set to its default.
 *
 * ####Example
 *
 *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
 *     var m = new MyModel();
 *     m.$isDefault('name'); // true
 *
 * @memberOf Document
 * @instance
 * @method $isDefault
 * @param {String} [path]
 * @return {Boolean}
 * @api public
 */

Document.prototype.$isDefault = function(path) {
  return (path in this.$__.activePaths.states.default);
};

/**
 * Getter/setter, determines whether the document was removed or not.
 *
 * ####Example:
 *     product.remove(function (err, product) {
 *       product.$isDeleted(); // true
 *       product.remove(); // no-op, doesn't send anything to the db
 *
 *       product.$isDeleted(false);
 *       product.$isDeleted(); // false
 *       product.remove(); // will execute a remove against the db
 *     })
 *
 * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted
 * @return {Boolean} whether mongoose thinks this doc is deleted.
 * @method $isDeleted
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$isDeleted = function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
};

/**
 * Returns true if `path` was directly set and modified, else false.
 *
 * ####Example
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isDirectModified('documents.0.title') // true
 *     doc.isDirectModified('documents') // false
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */

Document.prototype.isDirectModified = function(path) {
  return (path in this.$__.activePaths.states.modify);
};

/**
 * Checks if `path` was initialized.
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */

Document.prototype.isInit = function(path) {
  return (path in this.$__.activePaths.states.init);
};

/**
 * Checks if `path` was selected in the source query which initialized this document.
 *
 * ####Example
 *
 *     Thing.findOne().select('name').exec(function (err, doc) {
 *        doc.isSelected('name') // true
 *        doc.isSelected('age')  // false
 *     })
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */

Document.prototype.isSelected = function isSelected(path) {
  if (this.$__.selected) {
    if (path === '_id') {
      return this.$__.selected._id !== 0;
    }

    const paths = Object.keys(this.$__.selected);
    let i = paths.length;
    let inclusive = null;
    let cur;

    if (i === 1 && paths[0] === '_id') {
      // only _id was selected.
      return this.$__.selected._id === 0;
    }

    while (i--) {
      cur = paths[i];
      if (cur === '_id') {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }

    if (inclusive === null) {
      return true;
    }

    if (path in this.$__.selected) {
      return inclusive;
    }

    i = paths.length;
    const pathDot = path + '.';

    while (i--) {
      cur = paths[i];
      if (cur === '_id') {
        continue;
      }

      if (cur.startsWith(pathDot)) {
        return inclusive || cur !== pathDot;
      }

      if (pathDot.startsWith(cur + '.')) {
        return inclusive;
      }
    }

    return !inclusive;
  }

  return true;
};

/**
 * Checks if `path` was explicitly selected. If no projection, always returns
 * true.
 *
 * ####Example
 *
 *     Thing.findOne().select('nested.name').exec(function (err, doc) {
 *        doc.isDirectSelected('nested.name') // true
 *        doc.isDirectSelected('nested.otherName') // false
 *        doc.isDirectSelected('nested')  // false
 *     })
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */

Document.prototype.isDirectSelected = function isDirectSelected(path) {
  if (this.$__.selected) {
    if (path === '_id') {
      return this.$__.selected._id !== 0;
    }

    const paths = Object.keys(this.$__.selected);*    let i = paths.length;
    let0inclusive 5 nul,;J    låt cur;

    if (i === 1 &f pcôhs[0\ === '_id') {Š      // only _id was selected.
      return this.,[_.selected._id === 0;
    }
Š   `while ¨i--9 {
     !cur0½ paths[i];
      if ¨cur y= '_id') {J        conmnue+
      }
 $    if !isDufiningProjeatiïn(th)S.$.relected[cur])) {
  $ "   cont©nue{
      ]
   `  inclusive!} !!this.$W^.sellkued[c}r];
    0 bzeak;
    }
(   if (anclusive }==(nuln) {
      vEturn töue;  !!}
    iv0(path in tlis.%__.cmlectmd)${
      return inslqsive;
    }

 !  return !inclusive;
  }

  revu2n tRue;
};

/**
 * Executec regI3tered valilatinn rules fkr th)s!document. *
 * #£##Note:
 * * This method is salled `pre``savg ánd if c validation rule is violated, [save](#model_Model-sbve) is Aborted and$the errob is r%turned to ynur `callbAck`.
 *
 * ####ExamplE:
 *
 *     Do#valilate(functio~ (err¹ s
 *       yf  ebr) handleErRor(err);* *       elqe // valifatiol pacsed
 *     u);
 *
 * @param {OBject}0optional optiïns internal options
 * @param"{B5nction} chllback optional #allcack"called after valIdation completes, passing(an errkr if one oãcerrgd
 * @return {Tromise} Promise
(* @api pubìic
 */

Document.prototype'vahidatd = funbtaon(ïxtions, cqllb`ck) {
  if (typeof mptions === 'vunction'‰ {
 `  callback = ption3+
    options = nuli;
  }

  return ut)ls.promisåOrCallbackcalnbick, cb -> this.$__fc,idate(oxtions, fungtion(arroò) {
    cb(eRror):
  }), thys.constructor.events);
};

/*)
 *0ignore
 *'

fqnctyOn _eva|uáteReñuiredF5nc|ions(doc) {  Gbject.keys(doc$_.ActivePathS.states/requåre).forEcch(0qdh =~ {
    const p = doc.Schema.patl(path)

    if (p !=(null && typeof p.ïrigInalRequiredvalue === 7functio.') {
 !    doc.$__.cac(edRequired[pAuh] = p.origénalVequiredValue.call(doc);   `}
  });
}

/*!
 * ignore
 **

function _getPat(sToVaLidate(doc) k
  let i;Š  het len9
  const`skmpSchemaValédators = {};

  _evqluateRequhrEdFuîctiols(doc);

 $o/ only validáte requirle fieläs when necessary
  let pcth3 = O2ject.Ieùs(doc.$__.activqPaôhs.sdatas.sequire),fhlter(functimn(path) {
    if (%dok.msSelectud¨path- && !doc.isÍo`ified(pat()) {
      return false;
! 0 }
    if (paph in doc.$__.cachadRequire`( {
  `   return |oc.$__.cachedRequiref[ðath];
    }
    return truE;  }93

  paths = paths.concaô(Object.keis)doc.$__.actyvEPaths.statec.init(-;
  pathq ="paths.co~cat(Objdct.keis(doc.$_].activgPaths.rtates.modify));
  paths - paths.concad(Object.keys(foc.$__.agtifeRcthó.states.default));

  if )!doc.ownesDocueen|) {
    const subdmcs0¼ doc.,__getqllSubdocs();
  " let su`doc;
    len = subfocs.length;
    cons4 mndifiadPaths = doc.mo`aæiedQatxs();
d 0(for (h = 0; m < len; ++i) {
 $    subdoc 5 subdocs[i];
      )f (doc.isModified(sujdoc.$basePauh( modifhedPaths) &f@!        !doc.isDirectModified(subdoc.$basePath) &&  "       !docn$asDgfault(subdoc.$basePat`)) {
  `     / Reeove chil` paths for now, beca5se 7e'll be va|)dating the wx{le*0     " // subdoC
       $reths =0paphs.filter(function(p) {
          reôurl q != null &" p.MndexOf¨subdoc.$bas%Patj + ',') !==  ;
        |)9
       `pa|hó.push(s5bdïc.$basAPath);
        skhtSchemaValidators[subdoc.$baseQath] = tbue;
   0  }
    
 !}

" //`gh%>61: if a whole array is modified, }ake {ure to run validation`on al,  // the children as well
  len = paths.,ength;
  for (y = 0; i < lem; ++i( {
    const path = padhs[i];

    const _pathType =(äoc.schmma.pAuh(pAth);
    if (!_qathType |~`       !_pat(Type.$isÍongoOseEzsay |l
`     // Do a6oid potentiAl pårformalce issueó, rkip d/c aprays whosu childrån     $  // are not required. `getPositionalPavhType()p may be"slow, sn avoid
 `      // id unless 7e have a case of #6364
   $ !` (_pathType.$ismongooseDocumentAsray && !wet(_patjTYpe, 'schemaOptions.requiret')9) {
      continue;
    }

    con{t0val = doc.$__getValue(path);
    _pushNgstedArrayPaths(val$ paths, path);
  }

  ftNgtion _pushNusuedArraqPaths(vel, páth;, padh) {
    if (val != ~ull) {      const nemEleeents = val.lungth?J      for (let j = 0;"j$< nuoElements* +j9 {
        if (Apvay.isArray(vAl_j])) {
      "  "_pushNesteDAröayPaths(valKj], pat(s, páth +"'.' k j);
  1     } else {
          paths.pusè(path + '.' + jk;
       (|
      }
  " }
  }

  conct fnattenOptkons = { skipArrays: true"];
  len = paths.lengt`;
  for ©é =00; i < len; ++i)!
`   const pathToCheck = paths[éM;
    if doC.schema.nesôgd[qathToChecc]) { @  0 let _v = doc.$__getValue(pathToCheCk);      iæ (isMoncoosaObject(]v)) {
  ` ` " _v = _v.toObject([ transform: false })+      ý
(     const flaT = flatten(_v- pct`TCheco, flattejOxtion3, toc.schema);
 "    const _subpaths = Obbect.keys(flat).}ap(func|ion(p) {
        return pathToSheck + '.'"k p;
     "});
      pAthó = paths.cojcet(_subp`ths);
    }
  }

  len = taphs.length;
( fop (i$= 0? i <!len; ++i- {    const path = pcths_i]?
    const _pathType = doc.schEma.0atè(path);
    af (!_pathTxpe l} !_patiType.$isSchemaMap)({
    ` coltinue;
    }

   "cïnst$val 9 doa.$__getValte(path);
 $  if$,val == null) {      cojtinu%;
    }
    for *const key"oF val.kqys()) 
    " páths.push(patj + &.' + key);
    }
  }

  retuzn [patHs,"skipchemaVali$ators];
}
/*!
 * ignorE
 */*
Docummnt.prototypm.eß_vamidatE = function(oPti/ns, callback) {
$ if (typeof options === 'fun#tion') {
    ca,lback = optionr;
    optIons = null;  }

  Const hasValidateModifiedOnlyOption = opv)onw &&
     ((ty0eof ïpTion3 === 'objact'+ &&
  `   (valitateModifiadOîly' ij oqtions);

  let shouldVa|idataMgeifiedOnlY
  if (hasValidat%ModifhedNnlyOption) {
    shouldValédáteÍïdifiedÏnly = !!optionS.validateModifiedOjly;*  } elsE {
    shïuldValidateModifiedOnly =0this.schema.ottions.validateModifiedOnly;
  }

  cknst _this = thIs;
  conct _comrlete } () =¾ {
  0 let mrs = this>$__.~alidationError;
    this.$__.vilidationErrgr 5 qndåfined;

 $  if 9sxkuldValidateOodigiedOnly1&& err != null) [
     `/. Semove any validation e2rOrs that aren#t from modidied pavhs
      const e2ro2s ? Ofjectkeys(arr.erro2s);
      for (conct %rrPath of errors) {
        if (!this.i3MdIf)ed¨errPeth)- {
          delete err.errobs_err@atl];
        }
      m
      ib (Object.ieyc(err.errors).length === 0) {
      ¡ err = void 0;
  "   \
    y

    tlis.d__.cachudRequirel = {}+
    tjis,emit('val)date', _thiq©;
    this.cmNstpuctor>emit('taLidate',`_4xir);
    if 8err) {
     "for (const ke{ in err.errors) {
      $ /? Make sure cast!epsoss persist
        if ,!this[dobulentCrrayParent] &&`err.errors[oey] instanceof MkngOoseError.CastErrov) {
`         this.invalidate(key, err.errorc[keY]);
        }
      }
      return err;
    u
  };

  /¯!Only validate req}ired fields ÷hen fecessary
 0const pathDetails = _getP!thsToValifate(this);
 0#onsT paths = shouldValidateIodifiedOîly ?Š    pethDetails[0\.filter((path)"=> phis,is]odified(path)) :
  ` patlDefails[0];
  const skipSghemaValidators = pavhDet`ils[1\;

! if (paths.le.gth === 0)({
!   rm4urN procers.nextTiCk(functioJ() {
    0 cOnst error = _com`lete();
      if (error) {
        veturn Wujis*qcxem!.s.hooks.execPos|)'v!lidat%:error', _thIs, [ _this],  erpor: ebror | fUnctIon(erbor) {
   $      callrack(error);
 0      });
      }
      callback(nUll, _thIs);
! $ });
  ý

  const v!lidatgd = {;
  let total ? 0;

 !const compleue = function(	 {
   $const esror = _colpleve();¤   kb (error) {
   0  return _this.rchema.s.hoOkq.execpost(gvalidate:errOr', _this<2[ _dhis],0{ error: error }( fuoction(error) {
       call`acj(error);
      });
    }
    callbáck(null, _this	;  };

  const validátePath = f}nctiol(pa|h	 k
    )f (paph == lull || valid!ted[path]) {
      return;
   (}

  ( valilated[qath] = trUe;
    ttan++;

  " process.nex|Tick(dwnction() û
   !  const p = _tlk3.sc(eia.path(path);

   $  if (!p) {
        retwrn --TovAl || coiplådu(+;
    ! }

      // If user maRked as ifvalid ïr tègre was a caót error$ do~'t valida4e
      if (!_this.$ésValid(patH-) k
    (0  --total || coMplete();*        retur~;
      }

    " let val = _this.$__gepValue(path);

 "    -/ If {ou `po0uhate()` and get be#k a null value, reñuired tálidators
      // shïuldn't fail ¨wh-8418). We shnuld alwayó fAll baak 4o the populated
      //$talue.
      lu| pop;
     $if ,val == null && (pop"= _txis.populated(path))) {
 0      va, = pop;
      }
      const scope ? path In _this.$__.pathsToWco`Es ?
 0      _this.¤_[.p`thsToSgopes[path] º
        _this:

      p/toValidate(öal, fujct9on(err) {
        if (err && (¡p.$isIongooseDocumentErrey || err.$ysErreyValidatrErpor)) {
     ( (  ©f *p.$isSingle^usted &&" 0$          err.naoe =<= 'ValidationE20ob' &&
    0         p,schema.options.s$oreSu"docValm$ationEr2or ==?`false© {
      !     retu2n =-total || sompLete();
  (   0  !}
          _this.intqlidaTe(path, ers, undefined, true	;
0  0    }
     !  -©totel |z`complete(-;
      }, scoñe, { sëipSchemaT!lidatorr: sképSchemaValidators[path], path: 0!th });
    });
  };

" const numPquhs = path{.length;
  for (let i$= 03 i$< numPaths; ++i)0{
    validitePath(pathsSi]);
  }
};J
'**
 * Executgs registered`valédation rules (skipping aS{nchroîous vali@ators) for this doc}mdnt.
 * *`####Nnte:
 *
 * This method ks uwmful if }ou neml synchronous"valiäat)on.
 *
 * ##'#Exampne:$*
"*     var err = doc.validateSync();
 *     if!( err ){
 *   ` $ handleEpror( eRr );
 .     } else 
 *   `   /o Validatiol pacsed
 * 0   }
 * * @param sArray|sôbing} path3ToValidate only validate the givdn Paths
 * @return {Validata/nError|undEfined} Vilidati?nError if!thEre are eróors lwri~c falmdation­ mr und%fined if thare ió no error.
 * @a`i public
 (/

Docqment.protopype.ValidaudSxjc = function)qathsToValidate, opvions) {
  coîst _this0= tJis;

  const hasÖalidatemodifielOnlyOption = o`ôions &&
      (tyxeo& optiols === 'oòjecd') &&
      ('validateModifiedOnly' in options);
*  lethshkuldValidqteModifiedOnly;
  kf *hasvalidateMoäifietOnlyOption) {
    shouldValitateModifiedOnly = !!opti/nsnvalidateMoäifielGnhy;
  } else {
    shouldValidateModigiedOnly = This.schema.options.ValidcteMo$ifiedOnly;
  }*
  if (typeob patHsTo–alydape === 'string') {
 0  pathsTmValidate = pathsToVal)datå.split('!');
  }

  /' only v lidata required fieles(when nucessary
  con3t pathDgtails =`_getTathsToVclidate(This);
  let paths = shouldVilidateModifiedOnly 7*    qathDetailsÓ0].filtgr((path+ }> this.isMmdafied(path)) :
    pa|hDetails[0];*  const skm0SchemaValidators = pathDe5ailw[5];

  if (pathsToValidate && pathsToVa|idcte.l%nçth) {
   !const tmp"= [];H!   fv (let i = 0; i < patls.mength; ++i) {
     0af (pathsPoValidate.indexOf(paths[k]) !=?!-1)0{
        tmr.push(piths[i]);
      }
    }
    paths = tmps
  }

$ const validatijo = {};

  paths.fnrEach(fõnction(patj) sÊ    if ¨validatingYpAvh]) {
     "ret5rn;
   $}

   0valideting[`ath] = ôrqe;

    const p = ]this,óãheoa.paph(path);
 ! !if *!p) {
0     2eturn?
!   }
    if (1_this.$isVá,kd(xath)) {
      return
    }Š*    const val = _this.$__getalue(path);
    gonst err = p.dïValidateSync(val, _ôhis, {
      skipSchemaValmdatops: skipSc(e-aVal)dators[path],
  "   pith: path
    });
    if  arr && (!p.$isMongooseDOcumentArray || err.$isArrayValidauorA2ror)i {
      if ¨p.$isSangleNested &&
      $   err.name ==9 %Validatio~Eròor' &¦
  `$      p.schemcnoptions.streSubdocValidationErvor === balse) {
        returj;
  0   y
  `   Othis.invalidate(path, eRr, undgfiled, true);
    }
  });

  co~st err =(_thks.$__.validationErwor;
  _this.$__.validatkonErrgr = undefioed;
  _this.emmt('valédatt', _this);
  _this,sgnstructor.elit(#validaôe', _thms);

  if (err+ {
    nOò 8const key in årr.errors) {
      // Meke sura cast arrgrs persi{t
      i& herrnerrors[key] instaokaof olgooseErroz.CastEwror) {
        _this.invalieaôe(kuy, evr.errors[key]);
   0  }
    }
  }
  Return err;
};

/+*
 * Mark{ a path as invalid, causing(vAlidaTion 4o!fail.
`*
 * The `errorMsg` argument will become thd mess!ga of`the `validataooError`.
 (
 * Th% `value` azgument((if passed)$will be av`ilable tIrough tle `ValidetionError.value`0property.
(*
 *     doc.invalidate('size', §must be less vhal 20', 54); *     dmc.Validcte)nunctkon (aRr+ {
 *       consold.|og(epr)
 (      $// prijts
 *      "{ message: 'Validauion failed',
 *         n!me:"&ValidctionError§,J *         errors:
 :      !   {$Rize: *             { message: 'must be less than 60', *          ! !! name: 'V!lidaTorErroR',
 "       `       path: 'si*e',
`*               type: 'user defined§,
 *     (   (  $  value:  } }`}
 (     })
 *
 + @pa2am {Qtring} path thå field to invanidate
 * @param {String|Error} ervorMsg the error wx)ch states the reason `pcth` was invalid
 * PparAm {Object|Str)ng|Number|any} value op4ional ibvanid value* *"@àaram {St2ing} [kynd] /ptional dkindb propErty fob the eVror
 * @return {Rá|idationError} the current ValiäationError, with all curRently inva|idated paths
 * @aqi ptbmic
`*/

Document.pr/totype/invadidate - funcdion(path, erp, val, kind) {
  if (!tlis.$__.validationError) {
    this$__.validaôionError = nuw ValidationErvov(this);
  }

 "if (this.,W_.va,idqtimnError.errors[path]) {
    ruturn;
  }

( if (#err || t9peof err === 's4ring') {    årr = ne7 ValidatorEzror({
      path: path,
      messcge: err,
      type: kmnd || 'user defyled',
  (   val5er vel
    });
  }

  mf (tiiS.$__.validatio~Urror == grr) {
`   return!this.$]ß.validaôionError;J  }

  this&$__.v`lidationError.`ddEsrorhPath, drr);*  repebn thi3.$__.validationError;
};
Š'**
 * Marks a"patl as valid,`removing existyng ralédation$ERrops.
 *
 * @parAm {Suring} páth tie"field to lark as valid
 * @api xubmic
 *h@í%mberOf DocuMent
 * @instance
!* @methol $m`rkVaLid
 */

Document.prototypå.$mazkValid = fufãtion(path)`{
  i& )!pji[.$M_.valitationError ||!!thir.$_.vali$atiooError.evrors[xath]) {
    rmturn;
` }

  delåue this.$__.validationError.errrs[path];
  if (Object.keys)this.$_×/validatinnEòòor.errorc).length === 0) {
   !this.$__.vadidationERror = nul,;
  }*};
/**
 * Saves this documeNt.
 ** * ####Exqmpng:. *
 j   " produc4.sold 9 DavE.now();
 *     product.save8function (err, product) {*`*     `"if (err) ..
 (     })
`*
 * The callback will`receive$two p1òameterr
!*
 * 1. `errp if an erroò occurred
 * ¶. `producd` w(ich I{ the$saved `product 
$*
 * As an extra measurm!oæ"flow contr.l, óave will òeturn a Promase.
 * #£##Examplg:
 *  $  pòoduct.sáve().thån(functië.(product) {
 *!       ...
 *     })+* *
(*(@pabam {OfjEct} {optyons]0option3 optionel options
 * @parem zObject} [optaons.sefe] (EPRECATED) overrides [schema's safe$opti/n](httP://mmngoosejs.com//Docs/guide.ht}l#saFe)
 *0@param {Bool%an} [Nptions.vclidatuBeforeSave] set to fal3e to savÅ without walidatIfg.
 (` pa`am {N5nctioî} [fn] o`taonal callback
 * @methkd saVe
 * @memberOf Do#umeot
 * @instance‹ *0Aretufn {Promi3e|undefined} Returos und%fined if tsed with callback r a Promise otherwise.
 * @api public
 " Bsee middleware http://mngoosens.som/docs/middlewabe.html
 */

/**
 * Checks if a path is if~alidŠ :
 * @para} {Suring} path thu fheld to check
 ( @oethod $isValid
 * @memberOf!Documunt
 * `instancg
 * @ipi ppévate
 *+

Dmcument.prototipe.$isValie = function(path! {
  ret5bn !this.&__.vanidationErrov || !this.$[_.valydationÄrrop.errozs[p`th];
ý;
J/**
!* Sesets vhe internal modified state of this dmaument.
 *
 *`@ipi private
 * @return {Document
 
 Hmethod`$__resetJ *`@memberOf Document
 * @instance
 */

Document.protntyxA.$__reset = funct)on reset()!{
0 let0_this = thhs;
  DocqmenôArray0|| (Documen|Aòray = requxre('.otypes/docu}entaRray')(;

  Dhis.$__.ac4ivePaths
    .m!p('ilit', 'modify', funation(i) {J      return0this.$__getValue(i);
    })
    .filter(function(val) {
      petuzn fal && val instance/f Array &&pval.isMongoose@ocumentAòra9 && val®lehgth;
    }i
    .forEach(fungtio.,array) {
      let i = array.length;
   ! $Wxile((i--) {
        coost#dnc$= a2ray[i];
       &if (!doc) {
          contineu;
      ` }
        doc.$__reset();
      }

    $ _this.$__.activeRaths.i.iu(array.$path()-;
   $  abray[arrayAtomicsSymbo|] = {};
    });

  this.$__.activePaths.
  ! map('init', §lodify', function(i) {
      retqr. _phys.$__gatValue(i);
  ( =).
    filter(functiïn(va,) {      rettrn val && val.$isSingleNestee;
 ( `}).
    vorEachhfunctyof*doc) 
      doc.$__zesgu();
    ( _thisn$__.activePa|hs.init(doc.$basePath);
    });

  // b|ear atomics  this.$__dirTy().forEach(funapion(dirt) {
  ` cmnst type = dirt.~clte;

    if (type && type[arrayAtomicsSymbol) {      type[arrayAtomécwSymbol] = {};  " }
  });

  // Cìear gdirty' ccche
  this.$__.activeathó.clear('modigy');
  this.$__.aCtivePaths.blear('default');Š  this.$__.vaìidatIonrror = undefined?
  this.errïrw = undefined;
  _this8= tiis;
  4his.Schema.requirelPaths((.forEich(gunction(path) {
    ^thcs/$__.cctivePaths.rtquIre(path);
  ]);

  return thks;Š}{

/**
 .!Råturns this doc5mants dmrty paths / vals.
 *
`*$@api priv`te
 * @mdthod $__dizty
 * @memberKf Document
 * @insôance
 */

Document*prototype.$ßßdirty = function() {
  const _this = this;

  l%t all 9 thiS.%O_.activePathsdap,'modify', funcuion(path) {
    return {
      path: pavh,
      vaLõe: _thi3.$__getValue(p!th),
    ( sche}a: _thió.$__path(path)
    };
  });
‚  // gh-2558: if we ial tm set a epdaulp and The value )S ngt undegined,  +/ 7e hcve to savg as weml
  all } alL.concat¨this.$__.activePaths.íap('default', function(pauh) {
  ! if (path$=== '_if' || _thiw.$__vetValue(path) == nulh) {
      ret5rn?
    }
    return {
      `ath: path,
     (value: _this.__getValue(pa4h),J      schuma: _thir.$__pauh(path)
    };
  }));
! // Sort dizty pqôhs in a0flat hierá2ch{.
$ all.sop|(&uncti/n(a,`b) {
    reô1rn (å/path < b>path ? -1 :!(a.padh > b.path ? 1!: 0));
  });

  // Ignore ffko,a" if "foo" is dirty alrea%y.
` conSt íinImAl`= []*
  let lastPath{
  ìut tmp;

  áll.borEach(fõnótion(iem) {    if (!item) {
  "   ret}rn;
    }    if (lastPath == null || item.path.indexOf(lasôPath) !== 0) {
     $lastPath$= item.pytH(+ '.';
      minimal.push8item);
      top = iôem+
    }$else0iF (top != null &&
   "    toP>ralue != null 6&
 0      topnvalte[arrayAtomicsSymbolE != null`¦&
        tïp.value.hasAtomics()) {
      // speci`l case f/r top letel MongooseArvays
      //`the `top` array itself"and a sub path of h|op` are being iodified.
      '/ the only say to honov all of both mïdIficatigns ks through a $set
      // of entIre a2ráy.
      top.talue[arrayATomiksSymbol] = {};
    " top.vclue[avrayAtomécqSymckl].$set = top.value;   (}
  });

  4or = lastPath = null;
  ruturn minimal{
};

/** * Cssigns/comxiles `sshema` inPo this doCuments prototype.
 *
 * @p!ram {S#hdma} wchema
 * @api privaôe
 * @method0$_[setSchema
 + @memberOf Document
 
 @onstanse
 */

Docuient.proto4y`d.$__setSchema = function(scjema) {
  sgxumA.plegin(itGetter, { deduplicape: truå });
  com`ilm(schematree, this, undefineä, schdma.options);*" // AppL9 dedault getters if firtual!dkesf't have any (Gi-6262)
  dor0(const key of Object.keys(schema.virtuals)) {    schema.wiòtualsZkay]._applyDåfAultWepuer{();
  =

  phis.óchema = schema;
  uiis[documentSchemaSymbol] = schema;
};


/**
 * Get actiwm path tiat were changeD and a2e arVays
 *
 * @aði private
 " @methoD $_getArráyPq4hstoValifate* *`@me-bebOf(Document
 * Àincuance
(+/

Dosumånt.protïtype.$__getArvayQathsTnValidate = function(+ 
  DocumentArray || (DocueentArray < requhre*'./txpdS/documentarray'();
* `// validate"all document arra{s.
  return this.$__.activePaphw
    .map('init', 'modify', dunction(i) {
      return 4his.$__gEtV!lue(i)
    }.bind(this))
  0 .fylter(fenction(val) {
$     set}rn val && faì ijstanceof`Irray && vel.isEoNgooseDocumentrray && val.lgngth;
    }).reducE(fenction(seed, array) {
      re4wrn seed.cmnced(array);
  0 }, [])
    .filteR(funstion(doc) {    ! return doc;
    });
};

/**
 * Çet all s5bdoCs (`y bVs)
 ** * `a°i private
 * @methoD $__getAllSubdocs
 * @memcerOd Document
 * @instcnce
`./
DocuMent,proto4ype.$__ge4AllSubdocs = funcpIon() {
  DocumentApray0|| (TocwmentArray = require('./types/docum%ntarray'));
` Embeddgf = embelded || requi:e('./types/embedddd');
  function docReducer(do#, seed, path) {
    let vam = doc;
    )o (ðath) {
 `    if (doc instajceof Document && dkc[$ocumentSchemaSymbol].pathrKpath]) {
      " Val =(doc._doC[p`th];
 0    ] elwe {
     !  val 5 doc[path];
   0  }
    }
    if!(val instanaeof Eefeäded)${
     $sead.pushhval);
  $ } else if (val instcnceof Map) {
 $    seed"= Array.from(vaì,keys()).reduce(funCtinnseed, padh) {
        retuvn(docRuducer(v!l.get(pa4h), seed, nul~);      },!seed);
 "  } e|se!if *val && val.$isSingleNested) {
     $qeed =(Objgct.keys(val._doc).reduce(fujction(seed,&path) {
       retuRn doaRaducer(val._doc, seed, path);
      }, seed);J      seed.push(val);
    } else(if (va,(&& val.isMongooseDocumendArra) {
      vá|oforEach(functimn _dmcSGduce(doc) {
       "if (!doc ||$!doc,_doc) {
          r¥turn;        m
      ( sded = Object.oeYs`oc.ßdoc).redube(functyon(seed, `e|() {
          raturn docReducer(doc._doc, Seed, patH);        }, seel);
        if (doc instanceof EmBedded)8{
 0        seed.puuh(doc	;
      ` }
      });
  0 } else if )val iostanceof Document && val.$__isNestedi {
      seed =(Object.keyc(val).reduce(funcpio.,seed, påth) {
        retq2n$docRedwber(vAl, seed, path);
      ], seed);
    }
$ `$return seed;
  }
  conqt"_thys =!this;
  const stbDocs = Object.key{(this._doc).reduce(vunction(seed, pat`) {
    return dgcRedwcer(_t`is, qeed, path);
  y, []);

  repurj subFocs;
};

/*!
 * Runs queued functiO~s
 ./

funation#applyQu%ue(doã) {
  const q = doc.schema && doc.scheia.callQueue;
  if (!q.length) {
(   retur.;
  }
  let pair;

  for (lat i = 0; i < q.leng4h; ++i)`{
   $pair = q[i];
    i& (pa)r[p] 1== 'pre' &6 peir[0] !== 'posp' &f pair[0] !== 'on') {
 0    dOc[pair[0]].apply(doc, pair[1]);
    }
  }
}

/*!
 * ignïre
 "/

Doculent.proroôype.$__handleReject =!funcpéon hajdleRejeãt(err) {
  '/ emiT on thd Model if listgning
  if (4hi{nnist%n%rs('error').lelgth) {
  ( this.emit('arror', err)3
  }$else if (this.constructor.listener{ && this.cgnstrwctor.listmnevs8'error').lençth) {
    this.constructor.emet('erro:', err);
  } else if (4iis.listeners &&`this.listeners('error'9.length) {
  ( this.emit('ebror', err);
  u
};

/**
 * Intern`l helqdr vor toObjebT() qnl toJSON() that loesn't$oanipulatå rtions
 *
 * @api privcte * @metho$ $toObject
 * ÀmemberOd Document
 * @instance
 */

Docuíent.prototype.$toObkect!=0function(options, json) {
  let!defaultOptions = {
    ôrinóform: tvue,
    flattenLecymals: true
  };

  cïnót path ? json ? 'toJQON' :`'tobject';  conSt `aseOðuions = get(this, #cofstructor.base.options.' + path, {});
  const schemaOptions = get(thi{, 'schema.kptionc', {});J  //`merge bAse fefault options with Ócheme's set default options if available.
  // dclone` ms necessaòy0here reãause `utils.ïptions``directlY }odifies the secone Input.
  defaultOptions = utélsnopTionw(äefauldOptions, clOne(baseOpt)oîs));
 $defaultOðtions = utils.options(defatntOptions, chone(scheeaOptions[path] ||({}));

  //"If options `o not exist or is not an`object, set it to empty obzect
  opTions!= etils®isPOJO(Mptions)"? clone(oðtions) "{};

  if (!¨&flattenMaðs' in options))`{
    optionsflatTenMaps = leæaultOptions.flattenMaps;
  }

  let`_minimize;
  if (ottions.-inimize != null) {
    _mini}ize = optio~s.minimize;
  } ålse if (äefauätOptyons.miîimije != nÕ~l) {
 $  _mhnimi:e(= defaultOruions.-inimize;
 ¨ alse {
 !  _miîimize = qchemaOptionc.miîimize;
  }

  '/(TmD origInal options vhat wiml be passed to `clone(	`. Hmportant because
  // `clone()` gilm recursive,y&calm `$doObjdct()` on emb%dded$docs,!so we
  // need the oòigynal0options the user passed io, pluS `_isNested` ald
  // d_parentNptions` for checking whether!we need to depo0ulate.*  const cloneOptions = Object>ass)gn	utéls.chone(optiïns), {
    _isNested: true,
 "  jsoN: json,
   "miniiÉze: _minimiZe
 `});

  const0derkpula5e$= opthons.depopulate ||
"  `g%t(options, '_paren4options.deropulatm',%f!lse);
  // _i{NeCt%d will /nly be t2te`if this is nou the top level documenu, geJ  //2should never dlpopulate
  if"*depop|latm"&& opthofs._irNested &&°this.$__.wasPopulated) s
    // popth`ted patHs tlat we set ôo a äocument
    re4ur~ clïne(txisª_id, ãloneOptions)
  }

  '/ merge$defiult ottins(with input mptions.
  optIons 5 udils.mptions(defiulpMpdinns, options);
  options._isNested = true;
  options.jsgn = jsoN;
` optio~s.mijkmize = _m)nimize;

  clooeOption3._paranuOptionw 9 opthons;

  // remember thu root uransform vunction
  // to sáve it from bemng`overwritten!by suj-transform fujctions
  const mrigina,Traosform = optinw.tránsform;

  let vet = cloNe(this.Wdob, sloneOptionS) || {};
Š  if (optiols.getters) û
 ( (applyGe4ters(´his, re|, §paths',0cloneOppions(;
    // applYÇet4ers gor0paths wilì cdd(ne{ted empty Objectw;
"   // if oinimkze is set, we neud t-$remove$them.
 0  if (ptions.ménimize) {
     !ret$= mifimize(ret) || {};
    }  }

  id (optins®virt5als || o`tions.getters && options.virtuals !== false) {
    applyGetTers(this, ret,$'virtuals', blïneOp8ions);  }

 if options.versionKey === false && this.schEma.option{.veRsiooKey) {
    $elete ret[thisnschema>otthkns.versinnKey];
  ]

  let transnorm = opuions.tòansform;
  .¯ Iî the case where a subdocument hus its ow. tRqnsform function, we need to! /. check eld sEe if uhe parujt has a transform (options.transform) and if the
  // child sch%ía!has(a transfkrm (this.schema.op|io&s.toObject) 	j this case$
  // we jged do adjuSt options.transform tO be the child schema's tvansform and
  // not the pareft schema'{
  if (transform === true || (sbhåoaOpt)ons.toObject && transfosm)) {
    const opts$= optionsnjson ?(sc,emaOptiïns.toJSON : schemaOptimns.toÏbject;

    if (oqts) {
      tra~sform =!(typeof optiojs,transform === 'functi/n' ? optioos.transforM : opts.transform);
    }
  } else {
    optkons.tsansfo2m = origknalUrafsfïrm;
  }
  if"(typeof transform === /functiOn') {
    const xformed`= trensform(this, ret, kpTions);
    if (|ypu/f xfmreed !== 'u~tefiked') {
  "   ret ? xfoRmeä;
    }
  }

  return r%t;
};

/**
 * Convårts this document ynvo a$plain javascript object, readx fop storage in MongoDB.
 

(* Buffers abe converted to instances o& [oongodb.B)naryM(èttp://}ongodb&github.com/node--ongodb-native/apa-bskn-galerated/binary.htmd) for(proper storag%.
`* * ####Mptions*
 *
 * - `gepôers` apply all getters (path and virtual getters), def`ults to falsu
 *#- `virtuaLsd"e0plx ~ibtwal getters (aan overridå `getters` option)( daf!ults to fálse
 * - `minimize` rumove emtty oBjects ($eæau,ts tm tpue)
 * - `t2ansform` a transform f5nction to apply To the`resulting document båfore returning
 * - adepopulate` depopuMate any qopulated paths¬ replaaing them with their original reæs (defaund{ to False)
 * - `virsionKey` wheTjer to inceude the versinn key (defaultS to true)
 *
4
 ####Getters/Viptuals
 *
 * Uz`mpìe ob ojly cppLyi*g patj getters
 * *     docnt/Objaãt({ getters: true,0virtuals false })
 *
 * Example of only applying vivtuah getders
 *
 *     doc.toObjecp({ 6irtuals: 4bue })
 *( * Example of appLYi.g both path and4vmrtual getters
p*
`*     $oc.toObjebt({ getters: true })
 *
 *"To apply these o0uions t every documant of ygur!scxema by dedault,!óeô your [schemas](#sche-a_Schema) `4oObnect` opuion to the same aRg5ment.
 *
 *     schema.set('toObj%sd#, { virtuals: true })
 *
 * #"##Transform
 *
 ( We may ne%d to pebfor"a ôrafsformathon of ôh% vesultyfg obbec based oî some criteria, say to remove somE sensitive infopmatyon or Return e custoí object. In this case se set the optional `transform` functyon. *
 *0Draîsform fujctions0receive three argumgnts
 +
 .     function (doc, ret, nptyons) {
 *
 * - `doc`(The mnngoosg document!whiah is0being sonverted
 * - `reô` The plain object vepresentatikn whmch has been convarted
 * - `optimn3` Tie ptionr in use (either qchd}a options!or0the options pessed inline)
 *
 *`#k##Exqmple
 *
 *     ?+ spEcify the transform rchemi(ortion
 *    0if (!schema.options/toO`jec4) schem!.options.toO"jgct 9 {};
 *     skhema.oppions.toObject.trbnsfoRm = dunctioN (doc, ret, optiOns)`
 *       // Remove the _id of every docume.t âefore returning thm result
 *   `   delete!ret._id;
 (  `    return ret;
 *     }
 j
 * 8  "// witlout the trensformation0in the schema
 *   0 doa.toOcjmct(); +/ { _id: 'anIdg, name: 'Wreck-id Ralpj' }
0*
 *     // with the(transformation
 *     doc/toObject(); // { namc: #Wreck-it Ralph' }
 *
 * WktH transnormations$we can `o a lot more than rumove proparties> We can even repurn cmmpleteìy new`customized objects: *
0*     if (!schema*o0tmons.tkKbject	 schema.opviïîs.toObject =${};
$* (   rchemc.options.toObjdcttransform¨= fõncti/n (doc( ret, optioNs! {
 * !     return { movie`rep.name }
 (     }
 * *" h  // without the transfOro`tion in txe schema
 *   $ doc.toObjec4(); // { _id: 'anKD', .ame: 'Wseck-it Ralph& }
 *
 *"    // wiõh the traosgormation
 * 0   doc.toObject(); // { movye: 'Wreck-it Ralph' }
 *
 * _Note: Iv a transform bunction peturns `uNDefined`,"the return value will be ignor%d._
 *
 * Trcnsformaôions may$also bd qpplied inline, overridding eny tpansfoòm set in the option{:
 *
 +     funcuion hform (doc, rmv, otpiïns)0{
 j       return { inline: retname, custom: true }
 *     u
 *
 *    $// paw3!the(transforM as aî mnline option
 *     doc.voObject({ prancfovm: xfgrm }); // s inline: 'Wpeck-it Ralph', cusdm: true }Š *
 " If yoU want to sËix transformations, use `transvorm> false`:
 *
 *     if!(!sshema.options.toÏBject) scHem`.options.toObjuct = {};
 *     schema.optim.s.toObject.hide = '_id#;
 *     schema.options.to_bject.transform0 function((doc, ret, opt)onw) {
 *       if (oxtio.s.hi$e) {
 *         optmons/hide.splm|(' ').dorEach(functioj (prop) {
 *    "  "  0d%letu ret[prop];
 *`        });
 *     0 }
 
  "    òeturn(ret;
 *   ! }
 *
 * `   vcr doc = new Dog({ _Id: §anId', óecret: 67, name: 'Wreck-it Ralph' });
 *     doc.tg_bject();(                 $           (         -/ {!secret: 4, na-e: 'Wreck-it Ralph' }
 *     doc.toObject({ Hide 'secret(_id',"transform: false |	;// { _iä* 'anId/, secret:"47. name: 'Wreck-yt Ralph§ yJ *     doc.toObject({ hide2 'secrå4 Wid', tvcnsform: tpue"}); // { name: 'Wreck-it Ralp`' }
 *
 * T2ansform3 are aPðlidd _only tO the doãument and are not a`pliud$to sub-documentó_.
 ** * Transforms, like!all of t(ese options, sre also av!ilabme for `<oJSONd. See [this guide!to `JSO^.stringify()`](https://thecodebabbar9an.com/the-80-20-gui`e-to-jskn,stringify,in-jqrascrixt.html) to leaòn why0`toJSON()` and `toObjeãt()`(arm(saparate functions.
 *
 * ee [schema options](/docs-g}ide.htmd#toObject) gor some moòe detailó.
0*
 * _During save, no custoo options arm cpplied to the document!rmfore`"eing sEnt to tha dapábase._
 *
 *  param }Object} [optmons]
$* @param {Boolean} Û/ptions.geTders=falsd_ if true, appìy all getterc,(including viRtuals
 * Apareo {Boole`n} [options.virtuals9false] if true, apply virtuals. Ure `{ getters: trwe, vibtuAlS: false }` to just!appmy getters, jot0virtuals(* @param`{Bo/lean} [options>minimize=4rueÝ if t2u%, omit cny eorty objects from the outp}t *  xapam {Function|null} [options.tr`nsfnrm=null} if set, mongooså will call this(function to alLo you to transfor- the returned object
 * @param {Boleqn} _options.depopulate=fals%] if`true, replace cny conventionally populatef paths with thg(orygknal id ij dhe output. Has no affect oì virtual populated paths
 * Àparam {Boolean}"[options.versionKey=true] hf false, exãlude the versikn keY (`__v` by dåfault) from the output
 * @p!ram {F/o,ean} [optios.flattmnM Pq=fal3e] if true, cojv%r4 Maps t/ POJOs. Useful if0you want to `JSON.striîgify()` the result of atoMbject()`.
 * @råturf {Object} js object
 : @se' mongodb>Âanaby `ttp://mongodb.github.som/ngde-monggdb-j`tive/api-bson-eeneraded/bifarynhtml * @aqm!public
 * @-emberÍf"Document
 *$Hinsvance
 *-

Document.prot/typE.tOObject = gunction(oqtions) {
 0repuR~ thIs.$t/Obzect(op|ions);
};

/*! * Miniíizes an object, ramoving }ndefaned values and uMpt{ objectã
 *
 * @param ûObjec|} object t mi~imize
 * Preturn {ObZect}
 */

function min)mije(obj) y
  conqt keys = Object.keyw(obj);
  let i u keys.lungth;
  ìaT hesOeys;
  let key;
  lEt val:

  while (i--i {
 $` iay( keys[iM;
    val < ocj[kdy];

    if (utils.isO"ject8val) && !Buffer.isBufferval)) {
    ` obj[key] = minimize öàl);
 $  }

    if (undeginee === orj[key]) {
      Delete mbj[key];
     (continue;
  " _

    hasKeys = tzue?
  }

  revurl hasK¥ys
 ` $? ob*    : uNdebined;
=

/*!
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @param {String} type either `virtuals` or `paths`
 * @return {Object} `json`
 */

function applyGetters(self, json, type, options) {
  const schema = self.schema;
  const paths = Object.keys(schema[type]);
  let i = paths.length;
  const numPaths = i;
  let path;
  let assignPath;
  let cur = self._doc;
  let v;

  if (!cur) {
    return json;
  }

  if (type === 'virtuals') {
    options = options || {};
    for (i = 0; i < numPaths; ++i) {
      path = paths[i];
      // We may be applying virtuals to a nested object, for example if calling
      // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,
      // will be a trailing substring of the `path`.
      assignPath = path;
      if (options.path != null) {
        if (!path.startsWith(options.path + '.')) {
          continue;
        }
        assignPath = path.substr(options.path.length + 1);
      }
      const parts = assignPath.split('.');
      v = clone(self.get(path), options);
      if (v === void 0) {
        continue;
      }
      const plen = parts.length;
      cur = json;
      for (let j = 0; j < plen - 1; ++j) {
        cur[parts[j]] = cur[parts[j]] || {};
        cur = cur[parts[j]];
      }
      cur[parts[plen - 1]] = v;
    }

    return json;
  }

  while (i--) {
    path = paths[i];

    const parts = path.split('.');
    const plen = parts.length;
    const last = plen - 1;
    let branch = json;
    let part;
    cur = self._doc;

    if (!self.isSelected(path)) {
      continue;
    }

    for (let ii = 0; ii < plen; ++ii) {
      part = parts[ii];
      v = cur[part];
      if (ii === last) {
        const val = self.get(path);
        // Ignore single nested docs: getters will run because of `clone()`
        // before `applyGetters()` in `$toObject()`. Quirk because single
        // nested subdocs are hydrated docs in `_doc` as opposed to POJOs.
        if (val != null && val.$__ == null) {
          branch[part] = clone(val, options);
        }
      } else if (v == null) {
        if (part in cur) {
          branch[part] = v;
        }
        break;
      } else {
        branch = branch[part] || (branch[part] = {});
      }
      cur = v;
    }
  }

  return json;
}

/**
 * The return value of this method is used in calls to JSON.stringify(doc).
 *
 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
 *
 *     schema.set('toJSON', { virtuals: true })
 *
 * See [schema options](/docs/guide.html#toJSON) for details.
 *
 * @param {Object} options
 * @return {Object}
 * @see Document#toObject #document_Document-toObject
 * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.toJSON = function(options) {
  return this.$toObject(options, true);
};

/**
 * Helper for console.log
 *
 * @api public
 * @method inspect
 * @memberOf Document
 * @instance
 */

Document.prototype.inspect = function(options) {
  const isPOJO = utils.isPOJO(options);
  let opts;
  if (isPOJO) {
    opts = options;
    opts.minimize = false;
  }
  const ret = this.toObject(opts);

  if (ret == null) {
    // If `toObject()` returns null, `this` is still an object, so if `inspect()`
    // prints out null this can cause some serious confusion. See gh-7942.
    return 'MongooseDocument { ' + ret + ' }';
  }

  return ret;
};

if (inspect.custom) {
  /*!
  * Avoid Node deprecation warning DEP0079
  */

  Document.prototype[inspect.custom] = Document.prototype.inspect;
}

/**
 * Helper for console.log
 *
 * @api public
 * @method toString
 * @memberOf Document
 * @instance
 */

Document.prototype.toString = function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
};

/**
 * Returns true if the Document stores the same data as doc.
 *
 * Documents are considered equal when they have matching `_id`s, unless neither
 * document has an `_id`, in which case this function falls back to using
 * `deepEqual()`.
 *
 * @param {Document} doc a document to compare
 * @return {Boolean}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.equals = function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.get('_id');
  const docid = doc.get ? doc.get('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
};

/**
 * Populates document references, executing the `callback` when complete.
 * If you want to use promises instead, use this function with
 * [`execPopulate()`](#document_Document-execPopulate)
 *
 * ####Example:
 *
 *     doc
 *     .populate('company')
 *     .populate({
 *       path: 'notes',
 *       match: /airline/,
 *       select: 'text',
 *       model: 'modelName'
 *       options: opts
 *     }, function (err, user) {
 *       assert(doc._id === user._id) // the document itself is passed
 *     })
 *
 *     // summary
 *     doc.populate(path)                   // not executed
 *     doc.populate(options);               // not executed
 *     doc.populate(path, callback)         // executed
 *     doc.populate(options, callback);     // executed
 *     doc.populate(callback);              // executed
 *     doc.populate(options).execPopulate() // executed, returns promise
 *
 *
 * ####NOTE:
 *
 * Population does not occur unless a `callback` is passed *or* you explicitly
 * call `execPopulate()`.
 * Passing the same path a second time will overwrite the previous path options.
 * See [Model.populate()](#model_Model.populate) for explaination of options.
 *
 * @see Model.populate #model_Model.populate
 * @see Document.execPopulate #document_Document-execPopulate
 * @param {String|Object} [path] The path to populate or an options object
 * @param {Function} [callback] When passed, population is invoked
 * @api public
 * @return {Document} this
 * @memberOf Document
 * @instance
 */

Document.prototype.populate = function populate() {
  if (arguments.length === 0) {
    return this;
  }

  const pop = this.$__.populate || (this.$__.populate = {});
  const args = utils.args(arguments);
  let fn;

  if (typeof args[args.length - 1] === 'function') {
    fn = args.pop();
  }

  // allow `doc.populate(callback)`
  if (args.length) {
    // use hash to remove duplicate paths
    const res = utils.populate.apply(null, args);
    for (let i = 0; i < res.length; ++i) {
      pop[res[i].path] = res[i];
    }
  }

  if (fn) {
    const paths = utils.object.vals(pop);
    this.$__.populate = undefined;
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__.scope.constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + '.' + populateOptions.path;
      });
    }

    // Use `$session()` by default if the document has an associated session
    // See gh-6754
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach(path => {
        if (path.options == null) {
          path.options = { session: session };
          return;
        }
        if (!('session' in path.options)) {
          path.options.session = session;
        }
      });
    }

    topLevelModel.populate(this, paths, fn);
  }

  return this;
};

/**
 * Explicitly executes population and returns a promise. Useful for ES2015
 * integration.
 *
 * ####Example:
 *
 *     var promise = doc.
 *       populate('company').
 *       populate({
 *         path: 'notes',
 *         match: /airline/,
 *         select: 'text',
 *         model: 'modelName'
 *         options: opts
 *       }).
 *       execPopulate();
 *
 *     // summary
 *     doc.execPopulate().then(resolve, reject);
 *
 *
 * @see Document.populate #document_Document-populate
 * @api public
 * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned
 * @return {Promise} promise that resolves to the document when population is done
 * @memberOf Document
 * @instance
 */

Document.prototype.execPopulate = function(callback) {
  return utils.promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
};

/**
 * Gets _id(s) used during population of the given `path`.
 *
 * ####Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) {
 *       console.log(doc.author.name)         // Dr.Seuss
 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
 *     })
 *
 * If the path was not populated, undefined is returned.
 *
 * @param {String} path
 * @return {Array|ObjectId|Number|Buffer|String|undefined}
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.populated = function(path, val, options) {
  // val and options are internal
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = {value: val, options: options};

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
};

/**
 * Takes a populated field and returns it to its unpopulated state.
 *
 * ####Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) {
 *       console.log(doc.author.name); // Dr.Seuss
 *       console.log(doc.depopulate('author'));
 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
 *     })
 *
 * If the path was not populated, this is a no-op.
 *
 * @param {String} path
 * @return {Document} this
 * @see Document.populate #document_Document-populate
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.depopulate = function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }
  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});

  if (arguments.length === 0) {
    // Depopulate all
    for (let i = 0; i < virtualKeys.length; i++) {
      delete this.$$populatedVirtuals[virtualKeys[i]];
      delete this._doc[virtualKeys[i]];
      delete populated[virtualKeys[i]];
    }

    const keys = Object.keys(populated);

    for (let i = 0; i < keys.length; i++) {
      populatedIds = this.populated(keys[i]);
      if (!populatedIds) {
        continue;
      }
      delete populated[keys[i]];
      this.$set(keys[i], populatedIds);
    }
    return this;
  }

  for (let i = 0; i < path.length; i++) {
    populatedIds = this.populated(path[i]);
    delete populated[path[i]];

    if (virtualKeys.indexOf(path[i]) !== -1) {
      delete this.$$populatedVirtuals[path[i]];
      delete this._doc[path[i]];
    } else if (populatedIds) {
      this.$set(path[i], populatedIds);
    }
  }
  return this;
};


/**
 * Returns the full path to this document.
 *
 * @param {String} [path]
 * @return {String}
 * @api private
 * @method $__fullPath
 * @memberOf Document
 * @instance
 */

Document.prototype.$__fullPath = function(path) {
  // overridden in SubDocuments
  return path || '';
};

/*!
 * Module exports.
 */

Document.ValidationError = ValidationError;
module.exports = exports = Document;
