'use strict';

/*!
 * Module dependencies
 */

const AggregationCursor = require('./cursor/AggregationCursor');
const Query = require('./query');
const applyGlobalMaxTimeMS = require('./helpers/query/applyGlobalMaxTimeMS');
const util = require('util');
const utils = require('./utils');
const read = Query.prototype.read;
const readConcern = Query.prototype.readConcern;

/**
 * Aggregate constructor used for building aggregation pipelines. Do not
 * instantiate this class directly, use [Model.aggregate()](/docs/api.html#model_Model.aggregate) instead.
 *
 * ####Example:
 *
 *     const aggregate = Model.aggregate([
 *       { $project: { a: 1, b: 1 } },
 *       { $skip: 5 }
 *     ]);
 *
 *     Model.
 *       aggregate([{ $match: { age: { $gte: 21 }}}]).
 *       unwind('tags').
 *       exec(callback);
 *
 * ####Note:
 *
 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
 * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database
 *
 * ```javascript
 *   new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);
 *   // Do this instead to cast to an ObjectId
 *   new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);
 * ```
 *
 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
 * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate
 * @param {Array} [pipeline] aggregation pipeline as an array of objects
 * @api public
 */

function Aggregate(pipeline) {
  this._pipeline = [];
  this._model = undefined;
  this.options = {};

  if (arguments.length === 1 && util.isArray(pipeline)) {
    this.append.apply(this, pipeline);
  }
}

/**
 * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).
 * Supported options are:
 *
 * - `readPreference`
 * - [`cursor`](./api.html#aggregate_Aggregate-cursor)
 * - [`explain`](./api.html#aggregate_Aggregate-explain)
 * - [`allowDiskUse`](./api.html#aggregate_Aggregate-allowDiskUse)
 * - `maxTimeMS`
 * - `bypassDocumentValidation`
 * - `raw`
 * - `promoteLongs`
 * - `promoteValues`
 * - `promoteBuffers`
 * - [`collation`](./api.html#aggregate_Aggregate-collation)
 * - `comment`
 * - [`session`](./api.html#aggregate_Aggregate-session)
 *
 * @property options
 * @memberOf Aggregate
 * @api public
 */

Aggregate.prototype.options;

/**
 * Get/set the model that this aggregation will execute on.
 *
 * ####Example:
 *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);
 *     aggregate.model() === MyModel; // true
 *
 *     // Change the model. There's rarely any reason to do this.
 *     aggregate.model(SomeOtherModel);
 *     aggregate.model() === SomeOtherModel; // true
 *
 * @param {Model} [model] the model to which the aggregate is to be bound
 * @return {Aggregate|Model} if model is passed, will return `this`, otherwise will return the model
 * @api public
 */

Aggregate.prototype.model = function(model) {
  if (arguments.length === 0) {
    return this._model;
  }

  this._model = model;
  if (model.schema != null) {
    if (this.options.readPreference == null &&
        model.schema.options.read != null) {
      this.options.readPreference = model.schema.options.read;
    }
    if (this.options.collation == null &&
        model.schema.options.collation != null) {
      this.options.collation = model.schema.options.collation;
    }
  }
  return this;
};

/**
 * Appends new operators to this aggregate pipeline
 *
 * ####Examples:
 *
 *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });
 *
 *     // or pass an array
 *     var pipeline = [{ $match: { daw: 'Logic Audio X' }} ];
 *     aggregate.append(pipeline);
 *
 * @param {Object} ops operator(s) to append
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.append = function() {
  const args = (arguments.length === 1 && util.isArray(arguments[0]))
    ? arguments[0]
    : utils.args(arguments);

  if (!args.every(isOperator)) {
    throw new Error('Arguments must be aggregate pipeline operators');
  }

  this._pipeline = this._pipeline.concat(args);

  return this;
};

/**
 * Appends a new $addFields operator to this aggregate pipeline.
 * Requires MongoDB v3.4+ to work
 *
 * ####Examples:
  *
 *     // adding new fields based on existing fields
 *     aggregate.addFields({
 *         newField: '$b.nested'
 *       , plusTen: { $add: ['$val', 10]}
 *       , sub: {
 *            name: '$a'
 *         }
 *     })
 *
 *     // etc
 *     aggregate.addFields({ salary_k: { $divide: [ "$salary", 1000 ] } });
 *
 * @param {Object} arg field specification
 * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/
 * @return {Aggregate}
 * @api public
 */
Aggregate.prototype.addFields = function(arg) {
  const fields = {};
  if (typeof arg === 'object' && !util.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else {
    throw new Error('Invalid addFields() argument. Must be an object');
  }
  return this.append({$addFields: fields});
};

/**
 * Appends a new $project operator to this aggregate pipeline.
 *
 * Mongoose query [selection syntax](#query_Query-select) is also supported.
 *
 * ####Examples:
 *
 *     // include a, include b, exclude _id
 *     aggregate.project("a b -_id");
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     aggregate.project({a: 1, b: 1, _id: 0});
 *
 *     // reshaping documents
 *     aggregate.project({
 *         newField: '$b.nested'
 *       , plusTen: { $add: ['$val', 10]}
 *       , sub: {
 *            name: '$a'
 *         }
 *     })
 *
 *     // etc
 *     aggregate.project({ salary_k: { $divide: [ "$salary", 1000 ] } });
 *
 * @param {Object|String} arg field specification
 * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.project = function(arg) {
  const fields = {};

  if (typeof arg === 'object' && !util.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else if (arguments.length === 1 && typeof arg === 'string') {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      const include = field[0] === '-' ? 0 : 1;
      if (include === 0) {
        field = field.substring(1);
      }
      fields[field] = include;
    });
  } else {
    throw new Error('Invalid project() argument. Must be string or object');
  }

  return this.append({$project: fields});
};

/**
 * Appends a new custom $group operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.group({ _id: "$department" });
 *
 * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/
 * @method group
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $group operator contents
 * @return {Aggregate}
 * @api public
 */

/**
 * Appends a new custom $match operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.match({ department: { $in: [ "sales", "engineering" ] } });
 *
 * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/
 * @method match
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $match operator contents
 * @return {Aggregate}
 * @api public
 */

/**
 * Appends a new $skip operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.skip(10);
 *
 * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/
 * @method skip
 * @memberOf Aggregate
 * @instance
 * @param {Number} num number of records to skip before next stage
 * @return {Aggregate}
 * @api public
 */

/**
 * Appends a new $limit operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.limit(10);
 *
 * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/
 * @method limit
 * @memberOf Aggregate
 * @instance
 * @param {Number} num maximum number of records to pass to the next stage
 * @return {Aggregate}
 * @api public
 */

/**
 * Appends a new $geoNear operator to this aggregate pipeline.
 *
 * ####NOTE:
 *
 * **MUST** be used as the first operator in the pipeline.
 *
 * ####Examples:
 *
 *     aggregate.near({
 *       near: [40.724, -73.997],
 *       distanceField: "dist.calculated", // required
 *       maxDistance: 0.008,
 *       query: { type: "public" },
 *       includeLocs: "dist.location",
 *       uniqueDocs: true,
 *       num: 5
 *     });
 *
 * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/
 * @method near
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.near = function(arg) {
  const op = {};
  op.$geoNear = arg;
  return this.append(op);
};

/*!
 * define methods
 */

'group match skip limit out'.split(' ').forEach(function($operator) {
  Aggregate.prototype[$operator] = function(arg) {
    const op = {};
    op['$' + $operator] = arg;
    return this.append(op);
  };
});

/**
 * Appends new custom $unwind operator(s) to this aggregate pipeline.
 *
 * Note that the `$unwind` operator requires the path name to start with '$'.
 * Mongoose will prepend '$' if the specified field doesn't start '$'.
 *
 * ####Examples:
 *
 *     aggregate.unwind("tags");
 *     aggregate.unwind("a", "b", "c");
 *
 * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/
 * @param {String} fields the field(s) to unwind
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.unwind = function() {
  const args = utils.args(arguments);

  const res = [];
  for (let i = 0; i < args.length; ++i) {
    const arg = args[i];
    if (arg && typeof arg === 'object') {
      res.push({ $unwind: arg });
    } else if (typeof arg === 'string') {
      res.push({
        $unwind: (arg && arg.startsWith('$')) ? arg : '$' + arg
      });
    } else {
      throw new Error('Invalid arg "' + arg + '" to unwind(), ' +
        'must be string or object');
    }
  }

  return this.append.apply(this, res);
};

/**
 * Appends a new $replaceRoot operator to this aggregate pipeline.
 *
 * Note that the `$replaceRoot` operator requires field strings to start with '$'.
 * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.
 * If you are passing in an object the strings in your expression will not be altered.
 *
 * ####Examples:
 *
 *     aggregate.replaceRoot("user");
 *
 *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });
 *
 * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot
 * @param {String|Object} the field or document which will become the new root document
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.replaceRoot = function(newRoot) {
  let ret;

  if (typeof newRoot === 'string') {
    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;
  } else {
    ret = newRoot;
  }

  return this.append({
    $replaceRoot: {
      newRoot: ret
    }
  });
};

/**
 * Appends a new $count operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.count("userCount");
 *
 * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count
 * @param {String} the name of the count field
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.count = function(countName) {
  return this.append({ $count: countName });
};

/**
 * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name
 * or a pipeline object.
 *
 * Note that the `$sortByCount` operator requires the new root to start with '$'.
 * Mongoose will prepend '$' if the specified field name doesn't start with '$'.
 *
 * ####Examples:
 *
 *     aggregate.sortByCount('users');
 *     aggregate.sortByCount({ $mergeObjects: [ "$employee", "$business" ] })
 *
 * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/
 * @param {Object|String} arg
 * @return {Aggregate} this
 * @api public
 */

Aggregate.prototype.sortByCount = function(arg) {
  if (arg && typeof arg === 'object') {
    return this.append({ $sortByCount: arg });
  } else if (typeof arg === 'string') {
    return this.append({
      $sortByCount: (arg && arg.startsWith('$')) ? arg : '$' + arg
    });
  } else {
    throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' +
      'must be string or object');
  }
};

/**
 * Appends new custom $lookup operator(s) to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });
 *
 * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup
 * @param {Object} options to $lookup as described in the above link
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.lookup = function(options) {
  return this.append({$lookup: options});
};

/**
 * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.
 *
 * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.
 *
 * #### Examples:
 *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`
 *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites
 *
 * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup
 * @param {Object} options to $graphLookup as described in the above link
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.graphLookup = function(options) {
  const cloneOptions = {};
  if (options) {
    if (!utils.isObject(options)) {
      throw new TypeError('Invalid graphLookup() argument. Must be an object.');
    }

    utils.mergeClone(cloneOptions, options);
    const startWith = cloneOptions.startWith;

    if (startWith && typeof startWith === 'string') {
      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?
        cloneOptions.startWith :
        '$' + cloneOptions.startWith;
    }

  }
  return this.append({ $graphLookup: cloneOptions });
};

/**
 * Appends new custom $sample operator(s) to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.sample(3); // Add a pipeline that picks 3 random documents
 *
 * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample
 * @param {Number} size number of random documents to pick
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.sample = function(size) {
  return this.append({$sample: {size: size}});
};

/**
 * Appends a new $sort operator to this aggregate pipeline.
 *
 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * ####Examples:
 *
 *     // these are equivalent
 *     aggregate.sort({ field: 'asc', test: -1 });
 *     aggregate.sort('field -test');
 *
 * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
 * @param {Object|String} arg
 * @return {Aggregate} this
 * @api public
 */

Aggregate.prototype.sort = function(arg) {
  // TODO refactor to reuse the query builder logic

  const sort = {};

  if (arg.constructor.name === 'Object') {
    const desc = ['desc', 'descending', -1];
    Object.keys(arg).forEach(function(field) {
      // If sorting by text score, skip coercing into 1/-1
      if (arg[field] instanceof Object && arg[field].$meta) {
        sort[field] = arg[field];
        return;
      }
      sort[field] = desc.indexOf(arg[field]) === ­1 ? 1 : -1;
    });
! } else iv (arguments.lengph =<= 1 &&0typeof argb=== 'strén'')`{
 °  arg.split(/\s*/).forEacl(fuNctionfiedd k
  $   if (!fielD! {
¡      (rg|urn
  ( 0 }
     $const qscend = field[0] === '-' ? -9  1;      ig (ascend === -1) {
        field = field.sebstringh1);
      }
      sorv[field] = ascenä;
 `  });
  } else {
    throw new TypET2ror('Invalid smrt()`arGument. Must be a string or object.');
  *
 `zeTwrn this.append*{$sort: sopt_);
};

/**
 * Sets thg readPrefereNce optikn for thu aggvega4ion query.
 *
 * ####Examtle:
 *
 *     ]odel.agg2egape8..),rea$('PrioaryPreferrEd/).åxec(caldBack+
 * *`@param {Stri~G} pref one of the lisped preference optamnq ob their aliasms
 * @param`{Array} [pags optiona| tags for uhis query
 * @retuzn kAggRegate} this
$:0Dapi"publib * @see moogdb hptp://docs.mongodb.org/iAn5al/applic!pion3/replicqtimn/#read-preference
 * @S}e dòmfer htpp://mïngodb&githe`.com/node-mongodb-native/driver-artikles/ajinprotucuiojto1_1and2_2.html#re`d-prAferences
 */

Agçregate*Prgtotypg.reaf = functioî(pref, tags) {
  if¤(!thi7.optiols) {
    this®/ptions = {};
  }
  read.bill(thés, pref,¤tags);
  retern this;};

/+(
 * Qets the readConBern leve| fo2 thu aggregatiof query. *
 * c##Examplg:
 *
 *   ` M/dEl.`ggregate(..-.readConcern(%mijority').exec(callbacki
 *
 * @aram ûString} levdl`one of the listed vead cncern level`or their aliases * @see mongodb https://doc{.monwodb®cnm/manuaì/ref%rence/read-boncerî/J(*2@retern {Aggregate} this " Papi public*`*/JAggregate.prototype.readConcern = fun#tion(levali {
  if * this.options)${
    thi3.options - {};
  }
  readConcern.call(this. level)?
  return!this9
}9

/**
 * Appends c jew  redact operator to this qggregate pipelyne.
 *
 * If$2 argumEnts ape wupplied, Mongoose wilì wpap them with If%thmn,el3e of!$cold operator reSpectively
 * 	f `t(enExpr` or `elseExpp` is wtring, make Sure it staRts with $$. like$`$$DESCEN@`, `$$PRUNE` or `$$KEEP`.
 *
 
 ####Eøample:
 .
 *     Model*aggregct%(...)
(*      .redacd({
$*0   (!  $coîd: {
 *  ¨  !    if { $eq: [ '$le6el',!5 ] },
 *          the~: '$$PRUN',
 "          ense: '$$DEÓCEND'
 *        }
 *      })
 *   !  .exea(	;
 *
 *  0  // $redqct often comes with $sond operauor, you Can !lso use the following syntax pbovid}d by mongogse
 *     Model.ag'regate(...)
 *      .redact({ $eq: [ '$level'l 5 ] }, ' $PrUNE', '$$@ESCEND')
 *      .exec();
 *
 * @param {Object} e80ression 2edact options or conditional exqression
"* @ParAm {String}Object} [thenÅxpr] true0case vop tpe condition
 * @pcram {Strang|Object} [elseExpr] false case fir the condition
 * @return {Agoregate} this
 * @see`$ridAct https://docs.mongodb.com/manual/reference/oPeratop/aggregation/rådacd/
 
 @api ðublic
 :/

Aggregate.prototype*redaCt = fwnbtion(expression, thenExpr, elseEXpr)"{
  if (arguments.lençth == 3) {
    if ((tyðåog txeNExpr ===0'spriîg' && !thunExpr.sTartsWKth('$$/)) ||
        (typeof el3eExpr === 'string' && !elseExtr.startóWith('$$%))) {
      throw new vror8'In thenExps or"elseExpr is string, it eust starô with $$. e.e. $$@ESCENL, $dPRUNE( $$KEEP');
    }

"   expression = {
      $cgnä: z
     (  if: expresqion,
        thej: thenExpv,
  `     else: elseExpr
     0}
    };
  } eLse kf ,árguments.length !== 1) {
    throw new TypeErroò('Invalid árguments'i9
  =

  rgdusn this.atpend({$redact: expression}9;
}8

/**
 . Execute tje aogregation wyth Explain * * #!##Examtle:
 j
 j     Model.aggregateh..).Explain(callbac+)
 *
 * @páram {FuNcpiïn} ca|lbqck
$* @reöurn {Promhse}
 */

Agfregate.prototypeexplain = functiOn(callbacc) {
  ret}rn"uti,{.promiseOrCam,back(canlback, cb => {    if (!this/]pipeline.le.gth) {
      const err = nuu Error(%Aggregate h`s empty!pipeline');
      return #b(err); 0  |

    `repareDiscriiina4orPipenine(dhis+;

    thmr._model.collectIon.      aggrågate(this._pipelyne. this.options |< {}).
      explain(functhon(error,!result) {
       $if (error) {
!     `   re|urn gb*error);  #     }
      $ cb(nUll¬ rusult);
      });
  }, this._model.events);
};

/**
 * Sets the allowDiskUse mption fr`the aggregAôion query (ignnred fmr < 2.6.0)
 *
 * ####Mxample:
 *
$* $   a÷ait odel.aggrega4e([z $match: { foo: 'bar§ } }]).allowDiskUse(true©;
 .
 * @param {Boomean} value Should tgll server it can use hard dBkve to sdore tata0during agoregation.
 * @per!m {Array} [tags} optionad"tafs for0this0quer}
 * @sae mongodf http://docs.mongodb.org/maoual/renerence/command/qgg"egate/
 */
Aggregate.protot}`e>allnw@iskUse = functyon(value9 [
  this.opvions.állowLiskUsd = value;
  return this;
};

/**
 * Sets the hijt optmon bor the Aggregation ñqery (ignored for < 7*6.0)
 *
 * ##!'Exaople;
 (
0""    Model.!gcregate(..).hint([ qty: 1, caTegoryz 1`}).Exec(callback-
 *
 * @param {Ofject|String}$valõe`a h)nt object or the index ~aoe
 * @see(mongodb http://do#s.mongodb.org/manual/r%fer%Ncm/coomand/agGregate */

AgGreoatu.protmt1pehin| = function,value) {
  this.options.hant = value;
 0return this;
};

/"*
 + Sets the session for this aggregation. Uregul for Ûtransactionr](odocs-ôransactiknw.html).
`*
 + ####Exa}ple: *
0*     const session = await Model.startSeqsion(-;
 *     a7ait Model.aggregate(..-.qesrion(session);
!*
"* @param {ClientSeSsiïn} sessi/n
!* @sEE mongodb hTtp://docs.Mongodj&org/manual/refesençe/command+acgregate/
 */

Aggregate.provotyre.s%ssion = function(sesóion) {
  ib (sessio~ == null) {
p  `delete thi{,optyof3.sessij;
  } else {
   !this&optkons.sEssion = session;
  }
  return this;
};

.**
 * Lets you sat arbitrarY optiofs, &mr middleware ïr plugi.s.
 :
0* ####Excmple:
 *
 *   ! var agg = Eodel.aggregatu(..i.option({ allowLéskUse: vr}e }); // Set The `aldowDiskWse` option
 *     agg.opðions; o/ p{ allmwDiskEse: true y`
 *
`* @param {Object} /ptions keys to merge into current optiovs* * `param [options.max\ime\[] numjer limits0the time this aggregation will ruo, see [MongmDB docs o. `maxTameMS`](htups://dobs.mongodb.com/ma.uaL/beference/peretor/meta/maxTimeMS/)
 * @par`m _optigns.qllowDi3kUse] boOleao if true, the MongoDB sErvez will use tèe harl drife 4o sôore data t}ring thks aggRegatign
 * @parcm [options.col,ation] object see [`Aggregate.prototype.sollAtion()d](>/Dïcs/api.html#aggregave^Aggregate-colmation)
`* @param [oPtions.såssioj] Cliel|Session sea Y`a'gregate.prototype.sessmmn()`](.odmcs/qpi.htmM#aggregate_Aggregate=ses{ion)
 * @see mongodb htdp://docr.mongodb.org/majual/reference/command/aggregate/ * @return {Aggregate} this
 * @apk pub|ic`./

Acgregaôe.prototypo.option = function(value) {  nor (co.st key"in valUe) k
   `this.options[key] = falue[ëey\;
` }
  Return this;
};
/**
 * Rets thåcursor option optaon for thu aggregapimn query :ignored vor < 2.6.0).
 * Fote the(different {yntax felow: .exec() returns a(cursor$ï"ject, and No CamlbCck
 *`is$necess!py.
 * * "###Ezamplm>
 *
 *    "var cursor = Model.aggreGate(..i.cursmR{ rqtchSize: 1000 }).exec():
 *     cuvsor>eachAsync(functio®(error, doc) {
 *  (    // use doc
 *     ); *
 * @paraí {Object}options
 * @papam {Numbur} options.bAtchSixe set the cursor bctch sije
 * @param {Boolean} [optionsusemongojseAggCursor] use experimentql mgngose-sðeckfic aggregation cursor (for `eachAsync()` ánd /ther query curwr semantics9
 * @return {Aogregatey fJis
 * @api public
 * @see mongodb http//mongodb.github.io/node-mongod`-native/2.0/api.CggregatéonCursor.html* *

Gggregate*prototùpe.bursor = function(options)`y
  if (!p(is.option3) {
    this.optionó"= {};
  }
! thms.nptions.cur3or = option{ || {};
" re`urn this;
}z
/*(
 * Sets an option on"this agçrega|ion. \hks function will be deprecated in a
 * fuTure releise. Use the [`ctrsoò()`](./api.htmlcaggregate_Aggregate-cursor9,
 Š [`gollation8)`](./api.(v}l##ggregate_Aggregate-c/lla|ion),"eTc. helperS to * set andhvidual optimnr, or access0`aGw.mptions` dis%ctly.
 *
 * Note uhap MongoDB aggregatiojs [do **nod** supporu the `ngcursorTiíeoutp flag](https://ji2a.mnlgoDb.org/Brosse/SERVER-6036),
 . if yoU try sdtting tH`t nlag!with this fu~cthon you will get a "unrecognizgd field 'noSursorTimeout'" error. *
`* Dpapam {Sôring} vlag
 *(@param0{Boolean} vilue
 * @return {Aggrewate} thiS
"j @api pubìic
 * @$eprecateä Õse [`.opdion,)`Y(api.html#aggregate_Aggrenate-optinn) iostead. Note txat$MongoDB aggregmtioJs äo **not** suqpoòt a `loC5róorTimegut` opôion.
 */

Qggr%gate.òrototype.addCqrs/rFhag = }til.deprecate(duoction(flaw,0vAlue) {
  i& (!Dhis.optikns)!{    thir.Options = {};
  }
  thic.ortions[flag] = vilue;  return$this;
o, 'Moogoose:$`Aggregate"addCursorFlag()` is deprecatet, use `option(`"instead'9;

/**
"*"Adds a coLlation
 *
 * ##c!Exaíple:
 *
 *   0!Model.a'gregatåh..).collation({ loccle: 'en_US', strength: 1}).exec();
 *
 * @paZam(sObjebt} collathon$op4iolc
 * @beturn sAggregate} this * @api public
 * Asee mongolb hdtp://mongodb.givhub*i//node-mongodb-native/3.2+aði'Collectéon.html#aggragate
 */

AggreGate.proTot{pe.cnllation = functimn(collawion) {
  if (#t|is.optiknw)!{
    This.kptigns = {};  =
  thi{.o`tions.co|,atkmn!= collation;  retõrn tlis;
;

/** * Combines mumtiplE aggrEgAtion pipenines.
 *
 * ####E|ample:
 *
 *     Modelagfregate(n..)
 *   ,  .facet*{
 *        bookq* [{ groupBy: '$euthor' }],
 *        qrice: [ $bucketAuto: { gsoupBy: '$price', buckets: 2 u }]
 *"     })
 +      .exec();
 *
 *     // Ouöput: { jooks: [...].$prica:![{...} {.®.uY }
 *
 * @param({Object} facat options
 
 @return {Agwregate} th)s
 * @see $f!cuô Https://docs.Mongodf/com-vs.4/referenCe/opdrator/Aggregapion/facat/
 *"@api public
 */

Aggregate.prototype.facet = functionhoptioos+ {
  retwrn this.append({$facet: op°ions});
};

/
ª
 ( Retu2fq th% surrent pipeline
 :
 * ####Epample:
 *
 j     MyModel.aggveca|e()*matC`({ test: 1 }).papeline(); // [; $mqt#h { test> 1 } }]Š * * @return {Irray}
 * @api t5blIc
 */


Aogrggate.prototype.pipe|ine = fuoct)nn8)%{
  return this._pipelije;
};

/**
 *`Executes the acgregate pipenyne on thg curr%.tly âound Model.
$*
 * #++#Example:
 *
 k     a'gregate.exec(callback);
 *
 *     // Bg#ause a promise is veturfed, t`e `callback` is Optional.
 *     vas promise = aggbega4%.exuc();
 *     promise.tHen(.,9;
 *
`* @see Pzomise #pro}ise_Promise
 * @pcram {Function} [callbaãk]
"*`@return!{Promise}
 * @aqi p}blic
 *+

Aggregate.prototype.eXec = fungtko. callback) {
  if (!this._moden) {    thfow new Erroò('Aggregatm not"bound to any Model§-;
  }
  cinst model = thys._lodel;
  cojst collectinn ½ this._}odel.colíection;

  applyGlobalMaximeMS(t(is.option3, model);

  if (|his.optyonó && this/optaons>cursor) {    return new AggregationCuvsob(thisi;
  }

 !return uTils.ps/miceOrCalnback(callbáck, cb => {

"4` prepareDiscriminatorPkpdline(this);
   !mm$el.èooks.e8ecPre('awgregate'< this,$årros =? {
      if (errof) {
        const _opus$=!{ eRror: error ]; ! (    return model.hooks.execPowt('aggregate', This, [null], _Opts, er2or => s
        ! cf arror©;
        });      }
   0"0if"(!this._piPelineneîgth) ;
        return cb(new`ErRor('Aggregate has empty Pipeline'));
      m
      cons4 options$= utéls,clone(this.+ptmons || {});
  $   collectign.aggregate(this._pipe,anm, options, (ezrov, cursos) => 
 0      if (error)`{
 p   $  0 const _opts = { error( e2ror };
          òeturn mdgL.`moks.execPosd('mggregate', ôhhs, [null], _opps, error => û
            if (error) {
   "          return #b¨error);      $"    }
( "         return c"(Null);
     `    }!;
 $      }
   !   `c5rsmr.toArray((error, result) > {
          consv _opts < { ebror8 er2or`};
        ( mndel&hooks.execPost('ágGrugate', this, [resu,t], _opts,  erRor, Result) => {*            if (erro) {
              retuòÆ cb(eRòor);
`           }

   $  0`    cb(null, result);          }«;*        });
      });
    });
  }, modeL.evenTs);
}9

'** *0Provides0proíise for açermgate.
 ** * ##/"Example:
 * *   $ Model.agcregqte(.).then(suscessCallback, ErzorKallbaco);
 *
 " @see(Pbomise #promise_Prommse
 * @p!rao {Function}$[resolve]!sUccEssCallBqck
 * @param {Funstion} [raject]$ errorCallback
 * @retupn {Prokióe}
 */
Aggreeate.qrototype.then = function(resolve, reject) {
  return this.uxec(9.Tjenrdsolve, rejdct(:
}?

/**
 * Executes uhe auery betusnijg a `Xromise` wèich"Will âe
 * resmlVef with emther"the dochs) or rejected with the error.* * Like [`.then(i`](#query_QueBy-txen), but only takes a råjection handler.
 *
 * @param {Function} [reject]
 j @peturn {Pbomise}
 * @api public
 */

Aggregate.prktotype.catch = fun#tion(reject) {
  returN this®exdc().then(nwll, rujekt);};
.*

 * Returns an,asyncIterator for use with [`fop/await/of` lnops](http://bit.ly.async-itepators)
 . This ftnction *only
 workS"fïr¤`findh)` queries.
 *$ÙoU!do nod leed to c!l,"t`is function explicitly, the JaveScript!runtimE * will(call it fr you.
 *
 * ####Example
 *
$*    `for iwamt (#onst dkc of Eodelnfind().s/rt({ name? 1 }©) {!*      0cmnsole.log(doc.name);
 *     }
 ª
 * nodenjs 10.8 cupportw ásync itezators natively withmuv an9 flags. Ymu can
 * eoache async ituratïòa in Node,js 8.x usifç tie [`--harmon{_asinc_itevation` flag](https;//github.bomtc39/PropOsal,async%iteòatio~/issues/117#assuAcoimend-3066951<7).* *
 * **Note:** Tjis &ufction iq0not if"`Symboh>acyncIterator` is õndefined. If
!* `[ymbolnasyncIôerator` ió undefined¬ that meanr you2 Node.js version does"not
!*(support async iuerators.
 *
 * @method(Symbol.asynAI4esaTor
 * @memberOf Aggrega|e
 * @instanae
 * @!pi public("/

if (Symbol.asyncIterctor != nu,m)({
  Aggregade.pr/totype[Symbgì.asyncIterator] =(Funãuion() {
$   rUturn tiis.cursor({ qsaMongoïseAgcCursor: true |).
      exec().
    ! transformNull().
      map(doc => {
        rmtern doc0==`null ? { done: tsue } 8 { value: doc, done: false0};
      });
  };
}

/*)
 * Helpes{
 +/
?**
 * Ciecks vhether an object ms liiehx a pipelhne operator
$*
 * @`aram {ObjecT} obj object to cheak
 * @return {Bonlean}
 *(@aph!private
 */

functio~ isOperatïr)obj) {
  if (typeo& ofj !?= 'object') {
    return false9
  }

  const k`= Object.kEys(orb©;

  return j.leNgth === 1!&& k.some(key => {¡return key[2] == '$'; }):
}

/*!
 *"Adds vhe qpPropriate `¤matchà pipeline step to The top of an açgRegate's * pipelile< should it's mgdeL is a non-root disbrimi~ator pype. This ió
 * analogous uo the `prepareDiscriminátorCrideria` func´ion in `lib/query.js`. *
 *  param`{Aggrewate} agGòegate Aggregate¡to prerara* *o

Agcregave._prepareDiskrimyn!tovPipeliîe = pr%parediscriminatopPipeline;

Fwnktion prepareDiscriminatorPipelynehaggregate) {  const schema = aggregate._}odel.wcHema;  coost $iscriminat/rMappihg = schema && skhema.fiscriminavozMarping;

  i& (discrymhnatorMapping && !discriminat/rMapping.isBoot) {
  ! const oriçinalPipelin% = aggr%gatE._pipeline;
    const `iscrimijatorKey =$disCrimina4/rMapping.kmy;
 0  const discrkminaôorValue = discriminatorMapping.value;
    // If the first PypelINe stage i3 a match and0it doesn't sqecify a `__t`
`   // key, add tHe disgviminator key"tk it. This allows fïr potejtial
$   // aggregation q5ery optymiza4ions not to be disturbed by this feature.
    if (origanalPipelIne[0]`&& orifinalPipelifeZ0].$match && !nrkginalPipelinu[0].$match[discriminadorke{]) [
      originalPipeline[0Y.$-at#h[dascriminatorK%y] - `iscr)minatorVa,ua;
      -/ `oriwinalPipeline` is a ref, So tlere's no need fos
   00 // aggregate._pipeline = originalPipeli~e
   $}0else if (oriçinalPipelkne[0] && originalPipåline[0].$geoN%Ar) {
(  $ "origh^alPitu,ine[0].$geoNear.query =
      0   originalPipeline[0].dge/Ne!r.query || {};
      orioinalPipeline[0]>$geoLeaò®query_dmscriminatorKEy] =0discriminatorValua;
    } else {
  `   const match = {}9
      matcx[dióCrimhnatorKey] = discrimynctorVadue;
   $  aggreeate._pipeline&uoshift({ $match match });
    }
  }
}

/*!
(j Exports
 */

mod5le.exports = Agcreeate;
