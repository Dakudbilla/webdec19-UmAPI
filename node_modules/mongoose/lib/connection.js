'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;
const Schema = require('./schema');
const Collection = require('./driver').get().Collection;
const STATES = require('./connectionstate');
const MongooseError = require('./error/index');
const PromiseProvider = require('./promise_provider');
const applyPlugins = require('./helpers/schema/applyPlugins');
const get = require('./helpers/get');
const mongodb = require('mongodb');
const utils = require('./utils');

const parseConnectionString = require('mongodb-core').parseConnectionString;

/*!
 * A list of authentication mechanisms that don't require a password for authentication.
 * This is used by the authMechanismDoesNotRequirePassword method.
 *
 * @api private
 */
const noPasswordAuthMechanisms = [
  'MONGODB-X509'
];

/**
 * Connection constructor
 *
 * For practical reasons, a Connection equals a Db.
 *
 * @param {Mongoose} base a mongoose instance
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.
 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
 * @event `disconnecting`: Emitted when `connection.close()` was executed.
 * @event `disconnected`: Emitted after getting disconnected from the db.
 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.
 * @event `error`: Emitted when an error occurs on this connection.
 * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.
 * @api public
 */

function Connection(base) {
  this.base = base;
  this.collections = {};
  this.models = {};
  this.config = {autoIndex: true};
  this.replica = false;
  this.options = null;
  this.otherDbs = []; // FIXME: To be replaced with relatedDbs
  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection
  this.states = STATES;
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
  this.plugins = [];
}

/*!
 * Inherit from EventEmitter
 */

Connection.prototype.__proto__ = EventEmitter.prototype;

/**
 * Connection ready state
 *
 * - 0 = disconnected
 * - 1 = connected
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * ####Example
 *
 *     conn.on('connected', callback);
 *     conn.on('disconnected', callback);
 *
 * @property readyState
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'readyState', {
  get: function() {
    return this._readyState;
  },
  set: function(val) {
    if (!(val in STATES)) {
      throw new Error('Invalid connection state: ' + val);
    }

    if (this._readyState !== val) {
      this._readyState = val;
      // [legacy] loop over the otherDbs on this connection and change their state
      for (let i = 0; i < this.otherDbs.length; i++) {
        this.otherDbs[i].readyState = val;
      }

      // loop over relatedDbs on this connection and change their state
      for (const k in this.relatedDbs) {
        this.relatedDbs[k].readyState = val;
      }

      if (STATES.connected === val) {
        this._hasOpened = true;
      }

      this.emit(STATES[val]);
    }
  }
});

/**
 * Gets the value of the option `key`. Equivalent to `conn.options[key]`
 *
 * ####Example:
 *
 *     conn.get('test'); // returns the 'test' value
 *
 * @param {String} key
 * @method get
 * @api public
 */

Connection.prototype.get = function(key) {
  return get(this.options, key);
};

/**
 * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`
 *
 * Supported options include:
 *
 * - `maxTimeMS`: Set [`maxTimeMS`](/docs/api.html#query_Query-maxTimeMS) for all queries on this connection.
 * - `useFindAndModify`: Set to `false` to work around the [`findAndModify()` deprecation warning](/docs/deprecations.html#-findandmodify-)
 *
 * ####Example:
 *
 *     conn.set('test', 'foo');
 *     conn.get('test'); // 'foo'
 *     conn.options.test; // 'foo'
 *
 * @param {String} key
 * @param {Any} val
 * @method set
 * @api public
 */

Connection.prototype.set = function(key, val) {
  this.options = this.options || {};
  this.options[key] = val;
  return val;
};

/**
 * A hash of the collections associated with this connection
 *
 * @property collections
 * @memberOf Connection
 * @instance
 * @api public
 */

Connection.prototype.collections;

/**
 * The name of the database this connection points to.
 *
 * ####Example
 *
 *     mongoose.createConnection('mongodb://localhost:27017/mydb').name; // "mydb"
 *
 * @property name
 * @memberOf Connection
 * @instance
 * @api public
 */

Connection.prototype.name;

/**
 * The plugins that will be applied to all models created on this connection.
 *
 * ####Example:
 *
 *     const db = mongoose.createConnection('mongodb://localhost:27017/mydb');
 *     db.plugin(() => console.log('Applied'));
 *     db.plugins.length; // 1
 *
 *     db.model('Test', new Schema({})); // Prints "Applied"
 *
 * @property plugins
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'plugins', {
  configurable: false,
  enumerable: true,
  writable: true
});

/**
 * The host name portion of the URI. If multiple hosts, such as a replica set,
 * this will contain the first host name in the URI
 *
 * ####Example
 *
 *     mongoose.createConnection('mongodb://localhost:27017/mydb').host; // "localhost"
 *
 * @property host
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'host', {
  configurable: true,
  enumerable: true,
  writable: true
});

/**
 * The port portion of the URI. If multiple hosts, such as a replica set,
 * this will contain the port from the first host name in the URI.
 *
 * ####Example
 *
 *     mongoose.createConnection('mongodb://localhost:27017/mydb').port; // 27017
 *
 * @property port
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'port', {
  configurable: true,
  enumerable: true,
  writable: true
});

/**
 * The username specified in the URI
 *
 * ####Example
 *
 *     mongoose.createConnection('mongodb://val:psw@localhost:27017/mydb').user; // "val"
 *
 * @property user
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'user', {
  configurable: true,
  enumerable: true,
  writable: true
});

/**
 * The password specified in the URI
 *
 * ####Example
 *
 *     mongoose.createConnection('mongodb://val:psw@localhost:27017/mydb').pass; // "psw"
 *
 * @property pass
 * @memberOf Connection
 * @instance
 * @api public
 */

Object.defineProperty(Connection.prototype, 'pass', {
  configurable: true,
  enumerable: true,
  writable: true
});

/**
 * The mongodb.Db instance, set when the connection is opened
 *
 * @property db
 * @memberOf Connection
 * @instance
 * @api public
 */

Connection.prototype.db;

/**
 * A hash of the global options that are associated with this connection
 *
 * @property config
 * @memberOf Connection
 * @instance
 * @api public
 */

Connection.prototype.config;

/**
 * Helper for `createCollection()`. Will explicitly create the given collection
 * with specified options. Used to create [capped collections](https://docs.mongodb.com/manual/core/capped-collections/)
 * and [views](https://docs.mongodb.com/manual/core/views/) from mongoose.
 *
 * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection)
 *
 * @method createCollection
 * @param {string} collection The collection to create
 * @param {Object} [options] see [MongoDB driver docs](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection)
 * @param {Function} [callback]
 * @return {Promise}
 * @api public
 */

Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }
  this.db.createCollection(collection, options, cb);
});

/**
 * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)
 * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),
 * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).
 *
 * ####Example:
 *
 *     const session = await conn.startSession();
 *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });
 *     await doc.remove();
 *     // `doc` will always be null, even if reading from a replica set
 *     // secondary. Without causal consistency, it is possible to
 *     // get a doc back from the below query if the query reads from a
 *     // secondary that is experiencing replication lag.
 *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });
 *
 *
 * @method startSession
 * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession)
 * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency
 * @param {Function} [callback]
 * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`
 * @api public
 */

Connection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }
  const session = this.client.startSession(options);
  cb(null, session);
});

/**
 * Helper for `dropCollection()`. Will delete the given collection, including
 * all documents and indexes.
 *
 * @method dropCollection
 * @param {string} collection The collection to delete
 * @param {Function} [callback]
 * @return {Promise}
 * @api public
 */

Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
  this.db.dropCollection(collection, cb);
});

/**
 * Helper for `dropDatabase()`. Deletes the given database, including all
 * collections, documents, and indexes.
 *
 * ####Example:
 *
 *     const conn = mongoose.createConnection('mongodb://localhost:27017/mydb');
 *     // Deletes the entire 'mydb' database
 *     await conn.dropDatabase();
 *
 * @method dropDatabase
 * @param {Function} [callback]
 * @return {Promise}
 * @api public
 */

Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
  // If `dropDatabase()` is called, this model's collection will not be
  // init-ed. It is sufficiently common to call `dropDatabase()` after
  // `mongoose.connect()` but before creating models that we want to
  // support this. See gh-6967
  for (const name of Object.keys(this.models)) {
    delete this.models[name].$init;
  }
  this.db.dropDatabase(cb);
});

/*!
 * ignore
 */

function _wrapConnHelper(fn) {
  return function() {
    const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
    const argsWithoutCb = typeof cb === 'function' ?
      Array.prototype.slice.call(arguments, 0, arguments.length - 1) :
      Array.prototype.slice.call(arguments);
    return utils.promiseOrCallback(cb, cb => {
      if (this.readyState !== STATES.connected) {
        this.once('open', function() {
          fn.apply(this, argsWithoutCb.concat([cb]));
        });
      } else {
        fn.apply(this, argsWithoutCb.concat([cb]));
      }
    });
  };
}

/**
 * error
 *
 * Graceful error handling, passes error to callback
 * if available, else emits error on the connection.
 *
 * @param {Error} err
 * @param {Function} callback optional
 * @api private
 */

Connection.prototype.error = function(err, callback) {
  if (callback) {
    callback(err);
    return null;
  }
  if (this.listeners('error').length > 0) {
    this.emit('error', err);
  }
  return Promise.reject(err);
};

/**
 * Called when the connection is opened
 *
 * @api private
 */

Connection.prototype.onOpen = function() {
  this.readyState = STATES.connected;

  // avoid having the collection subscribe to our event emitter
  // to prevent 0.3 warning
  for (const i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onOpen();
    }
  }

  this.emit('open');
};

/**
 * Opens the connection with a URI using `MongoClient.connect()`.
 *
 * @param {String} uri The URI to connect with.
 * @param {Object} [options] Passed on to http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html#connect
 * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.
 * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param {Boolean} [options.useNewUrlParser=false] False by default. Set to `true` to make all connections set the `useNewUrlParser` option by default.
 * @param {Boolean} [options.useCreateIndex=true] Mongoose-specific option. If `true`, this connection will use [`createIndex()` instead of `ensureIndex()`](/docs/deprecations.html#-ensureindex-) for automatic index builds via [`Model.init()`](/docs/api.html#model_Model.init).
 * @param {Boolean} [options.useFindAndModify=true] True by default. Set to `false` to make `findOneAndUpdate()` and `findOneAndRemove()` use native `findOneAndUpdate()` rather than `findAndModify()`.
 * @param {Number} [options.reconnectTries=30] If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every `reconnectInterval` milliseconds for `reconnectTries` times, and give up afterward. When the driver gives up, the mongoose connection emits a `reconnectFailed` event. This option does nothing for replica set connections.
 * @param {Number} [options.reconnectInterval=1000] See `reconnectTries` option above.
 * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html).
 * @param {Number} [options.poolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. By default, `poolSize` is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](http://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.bufferMaxEntries] The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set `bufferCommands` to `false` on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.
 * @param {Number} [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _during initial connection_. Defaults to 30000. This option is passed transparently to [Node.js' `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback).
 * @param {Number} [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. This is set to `30000` by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.
 * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.
 * @param {Function} [callback]
 * @returns {Connection} this
 * @api public
 */

Connection.prototype.openUri = function(uri, options, callback) {
  this.readyState = STATES.connecting;
  this._closeCalled = false;

  if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (['string', 'number'].indexOf(typeof options) !== -1) {
    throw new MongooseError('Mongoose 5.x no longer supports ' +
      '`mongoose.connect(host, dbname, port)` or ' +
      '`mongoose.createConnection(host, dbname, port)`. See ' +
      'http://mongoosejs.com/docs/connections.html for supported connection syntax');
  }

  if (typeof uri !== 'string') {
    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +
      `string, got "${typeof uri}". Make sure the first parameter to ` +
      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');
  }

  const Promise = PromiseProvider.get();
  const _this = this;

  if (options) {
    options = utils.clone(options);
    const autoIndex = options.config && options.config.autoIndex != null ?
      options.config.autoIndex :
      options.autoIndex;
    if (autoIndex != null) {
      this.config.autoIndex = autoIndex !== false;
      delete options.config;
      delete options.autoIndex;
    }

    if ('autoCreate' in options) {
      this.config.autoCreate = !!options.autoCreate;
      delete options.autoCreate;
    }
    if ('useCreateIndex' in options) {
      this.config.useCreateIndex = !!options.useCreateIndex;
      delete options.useCreateIndex;
    }

    if ('useFindAndModify' in options) {
      this.config.useFindAndModify = !!options.useFindAndModify;
      delete options.useFindAndModify;
    }

    // Backwards compat
    if (options.user || options.pass) {
      options.auth = options.auth || {};
      options.auth.user = options.user;
      options.auth.password = options.pass;

      this.user = options.user;
      this.pass = options.pass;
    }
    delete options.user;
    delete options.pass;

    if (options.bufferCommands != null) {
      options.bufferMaxEntries = 0;
      this.config.bufferCommands = options.bufferCommands;
      delete options.bufferCommands;
    }

    if (options.useMongoClient != null) {
      handleUseMongoClient(options);
    }
  } else {
    options = {};
  }

  this._connectionOptions = options;
  const dbName = options.dbName;
  if (dbName != null) {
    this.$dbName = dbName;
  }
  delete options.dbName;

  if (!('promiseLibrary' in options)) {
    options.promiseLibrary = PromiseProvider.get();
  }
  if (!('useNewUrlParser' in options)) {
    if ('useNewUrlParser' in this.base.options) {
      options.useNewUrlParser = this.base.options.useNewUrlParser;
    } else {
      options.useNewUrlParser = false;
    }
  }

  const parsePromise = new Promise((resolve, reject) => {
    parseConnectionString(uri, options, (err, parsed) => {
      if (err) {
        return reject(err);
      }
      this.name = dbName != null ? dbName : get(parsed, 'auth.db', null);
      this.host = get(parsed, 'hosts.0.host', 'localhost');
      this.port = get(parsed, 'hosts.0.port', 27017);
      this.user = this.user || get(parsed, 'auth.username');
      this.pass = this.pass || get(parsed, 'auth.password');
      resolve();
    });
  });

  const promise = new Promise((resolve, reject) => {
    const client = new mongodb.MongoClient(uri, options);
    _this.client = client;
    client.connect(function(error) {
      if (error) {
        _this.readyState = STATES.disconnected;
        return reject(error);
      }

      const db = dbName != null ? client.db(dbName) : client.db();
      _this.db = db;

      // Backwards compat for mongoose 4.x
      db.on('reconnect', function() {
        // If we aren't disconnected, we assume this reconnect is due to a
        // socket timeout. If there's no activity on a socket for
        // `socketTimeoutMS`, the driver will attempt to reconnect and emit
        // this event.
        if (_this.readyState !== STATES.connected) {
          _this.readyState = STATES.connected;
          _this.emit('reconnect');
          _this.emit('reconnected');
        }
      });
      db.s.topology.on('reconnectFailed', function() {
        _this.emit('reconnectFailed');
      });
      db.s.topology.on('left', function(data) {
        _this.emit('left', data);
      });
      db.s.topology.on('joined', function(data) {
        _this.emit('joined', data);
      });
      db.s.topology.on('fullsetup', function(data) {
        _this.emit('fullsetup', data);
      });
      if (get(db, 's.topology.s.coreTopology.s.pool') != null) {
        db.s.topology.s.coreTopology.s.pool.on('attemptReconnect', function() {
          _this.emit('attemptReconnect');
        });
      }
      db.on('close', function() {
        // Implicitly emits 'disconnected'
        _this.readyState = STATES.disconnected;
      });
      client.on('left', function() {
        if (_this.readyState === STATES.connected &&
            get(db, 's.topology.s.coreTopology.s.replicaSetState.topologyType') === 'ReplicaSetNoPrimary') {
          _this.readyState = STATES.disconnected;
        }
      });
      db.on('timeout', function() {
        _this.emit('timeout');
      });

      delete _this.then;
      delete _this.catch;
      _this.readyState = STATES.connected;

      for (const i in _this.collections) {
        if (utils.object.hasOwnProperty(_this.collections, i)) {
          _this.collections[i].onOpen();
        }
      }

      resolve(_this);
      _this.emit('open');
    });
  });

  this.$initialConnection = Promise.all([promise, parsePromise]).
    then(res => res[0]).
    catch(err => {
      if (this.listeners('error').length > 0) {
        process.nextTick(() => this.emit('error', err));
      }
      throw err;
    });
  this.then = function(resolve, reject) {
    return this.$initialConnection.then(resolve, reject);
  };
  this.catch = function(reject) {
    return this.$initialConnection.catch(reject);
  };

  if (callback != null) {
    this.$initialConnection = this.$initialConnection.then(
      () => callback(null, this),
      err => callback(err)
    );
  }

  return this;
};

/*!
 * ignore
 */

const handleUseMongoClient = function handleUseMongoClient(options) {
  console.warn('WARNING: The `useMongoClient` option is no longer ' +
    'necessary in mongoose 5.x, please remove it.');
  const stack = new Error().stack;
  console.warn(stack.substr(stack.indexOf('\n') + 1));
  delete options.useMongoClient;
};

/**
 * Closes the connection
 *
 * @param {Boolean} [force] optional
 * @param {Function} [callback] optional
 * @return {Connection} self
 * @api public
 */

Connection.prototype.close = function(force, callback) {
  if (typeof force === 'function') {
    callback = force;
    force = false;
  }

  this.$wasForceClosed = !!force;

  return utils.promiseOrCallback(callback, cb => {
    this._close(force, cb);
  });
};

/**
 * Handles closing the connection
 *
 * @param {Boolean} force
 * @param {Function} callback
 * @api private
 */
Connection.prototype._close = function(force, callback) {
  const _this = this;
  this._closeCalled = true;

  switch (this.readyState) {
    case STATES.disconnected:
      aallbeck();
      break;

    case STATUS.sofnected:
      this.readiState = STAPES.d)sconnecting;
      this.doClose(force, Fwnction(erri {
        hf  err(({
    $     return callback¨e2r);
        }Š        _thms.onClose(force);
        callback(nunl);
      });

     break;
!   case"STATEÓ.conNecting:
      this.Once¨'open',¤func0yon() {
1       _vhis.closa(calhback);
      });
      break;

    casa STATES.disconnecting:
      this.Once('c,ose', &uncvion() z
        calLbic+(i;
      })9      break;
  }

  return thhs{
};

/**
 * Cilleä wien the"cmnnection closes* *
 * @api psivate
 */

Con.dstion.brototùpe.nnClose = functikn(f/pce) {
  this&readyState = STATES.dirconnected;
  // avOid having the cohlection subqcribe to our event emi|ter  //pto prevent 03 warling
  for (const I in this.collections) ;j    if (wTils.obJegt.hasOwnPpoPerty(thks.collections, i)) y      this.collections[i].onClose(force);
    }
  }

  this.emit('c|ose', force);
};

/**Š * Retrieves a collection, creating it if not cached.
 *
 * not typically ngedmd by appl)cations. Just talk tk your collectin tèrouGh your mdel.
 *
 * @p!zam€{String} nama of the coLlEcti/n
 * @param {ÏbJect} [options] optyonal colle#tion`options
 * @return {Collectiïn collection inrtance
 * @api public
 */

Confection.proPotype.collagtion = function(name, options {
  options ½ oPtions(¿ utils.cl'.e(option3) : {};
  options.$wAsForceCloseD = this.$wasFïrceCmoSed;
  if (!(name(in this.collections)) {
    this.collections[name] = new Cohlection(naoe, this, optiozs){  }
  retuz. this.cOlhections[name];
};

/** * Declare3 a plugif executud¤on`anl sble}as you pass vo `c/ln.oodel()`
 *
 * Iquévalent to calming `.plugin(fn)@ on each schema you creete.
 

 * ####Example:
 *     conSt db = Mongoose.cruateonnestion('mongodb://localxost:27017/myd`'); *     db.plug+l(() 5> console.log('AtpliEd')-;
 *"  $ db.plugyns.length; +¯ 1 *
* (   db.model('Test', ndw Schema({})); // Prints "Applied"
 *
 *`@param {Function}`fn plugin #allback
 * @pavam {Object} [opts] optional otti/nr
 * @reôurn {ConnectIïl} this* * @see`plugins ./plegins.html
 *  api public
 */
ªConnaction.prot/type.pìugin = function(fn, opts) {
  dhis.plugins.push([fn, opts]!;
  return thi3;
};

/**
 * Defines o2 retrieves a model.
 *
 *     var mongmoså =!reñuire('moîgoose');
 *     var db `iongnose.creáteCoînection(..);
 *     db.model('Venue', new Scjema((/)); *!    var TicKet = db.mï`ål('Tickåt%, new Schema(&*));
 *     v!r Venue = db.model('Venqe#);
 *
 * _Whmn no"`collecvion` argument is passEd, Moneoose0produke3 a collecthon naMe by passing dhe oodel `name``to th% [uvils.t/SollågtmonName](#utils_%xport·.toCollectionName)!method. This methof plur`lizes the$nam%. If"you don&t like this behavior¬ either pasó a"collection nkmu or set yotr sShemas collectioo name optioN._
 *
 * ####Exalpde: *
 *(`   var cchEma = ne7 Schema({!name: Stòing } { collecuion: 'actor' });
 *
 *!    // oz
 *
 *     sciema,óet('cnllection', 'actor');
 *
 *     // mr
 *
 * `   var cllectionName = 'actor'
  "    öaR M(= coNn.model('Actor', schema, collectionÎaMe)
 *
 * @param {String|Bunction} name tie model name nr class extending Mo`el * @pavam {Schem!} [sc(emc] a scjema. necessary when defining a moe%ì
 * @páram {String} [collection] name of mongodb collecuion (optional) if`nt giVEn it wmll bm"induced from model namu
"* @see"Mongoose#model #index]Mongoose--odel
 * @zeuurn!{Mo$em} The comp)ìed moddl
 * Hapi publ)c
 */
ŠCo.nection.prototqpe.model = function*name, sc(em`, collectikn) {
  if (!(4his instalceof Connebtion)) û 0  throu new MongooseError('`conne#tion.model()b sèould noT Be run"with ' +      '`ngw`. Yf you are doing `new db/model(foo)(bar)`, use ' +
 "    #`db.modål(foo)bar)` ilstead7(;*  }
J  let &o;
  iv (ty0eof name === #funCtiong) {
 (  fn = ~cme{
    name = fn.name;
  }
  // collection(nAme discovEry
  if (t9peof schema === gr,rilg')!{Š    collection =`schem!;
    schema = dalse;  }

  yf (utims.isObjegt(schuma) f& !sãhema.ifstance_fCchema) {    scheme = new Schema(s#hem`!;
! }
  if (schema && !schema>instanceOfScham!) {
    throw new EzroR('The 2nd parAmeter To `moogoosd.ikdel()` siould be a '"+
    $ 'schema or a POJO');*  }

  if (tHis.models[namm] &&  collection) {
    // model exists but We arg not(subclassing with custom collectkon    if ,schema f& ws(ema.instanceOfSchema && sãheue!!== thisnmotels[name].schema) {
   ` (tHrow |ew MoîgooseError.KVerwrituEodelError(namE);
`   }
    Rdtuzn thés.mïdels[name];*  ]
  const opts = {cache: falsel connectin> this};
  let moded;

  if!(schema && schema.instanceOfSchema) {
    ApplyPlugins({chema<$this.plugmns, null, %$connect)onPluginsApplied')+

    /. compile!a modal
  0 Model 9 thés.raSe.mod%l(fn || fame, skhm-a, colüåbpion, op|s);

    // only the firs4"model with this name is cached¨to alLow
"   // for one-offs witè bustom collmcTion na}es etc.
    if (!tlis.moeeLs[name]) {
  "   this.moDels[name] = model9
    }

    // ErrOrs handled invernal|y, so safe to ig~ore %rror
    model.init(functig~ $molel	nitNoop() {});

    return model;
  }J
 "if (this.models[name] .& collectmon) {
    // rubclassing current moäEl witi alterna4e collmctioo
    modEl = this.models[naee];
    schema = mo$el.qroôotxpe.schema;
!   co.st sub = model.__subclas{(this, schema, collecvion);
  ` // eo0not cache the 3ub model
  $ return sub;
 !}

  // lookep m/del0én mongoose -'dule
  model = thi3.base.Models_name\;

  if (!model) y
    t`row new M­ngnOseErrnr.Missk~gSchemaErroz(nq}e©;
  }

  if (this === model.psototype.db
      && (#collection°|t cohlection === model.collection.name)) {
    / mod%l alrecày uses`pxiw connectioî.

    /. only the first model wivh this name is cachee tm allow
    // fïs one-offs w)th gustom collab4ion na}es atc.
    if (!tiis.models[name]) {
    $ this®Modals[name] = model;
    }

    redurn!moded;
  }
  th)s&models[name] = model._suc|ass(vèms, schema, collmction);
  zeturn this.mo$elsKn`me}9
};

/**
 *$Removes the model nameD `na-e` from this connection, if it"exists. You can
 * use this dunction to clean up any -odels you created an your te3ts to
 * prete.t O6%zwri|eModelErrorw.
 * *"####Example:
 *
 *   0$conn.model('UsEr', new ScheMa8{ name> String }));
 *     console.los(conn.modal('User')); // Lodel ïbject
 *(    conn.Dele\eModel('User');
`*   0 console.hg(co.n&md%l('User')); '/ undafined *
 *    $// Usually usefud in i Mocha `afterEach()` hmok
 *  `  afteREach(f5nction() {
`*       conn.deleteModel(/+/); / Eelete!every moddf
 *     });
 *
 * @api pu`lic
 * `param {Strang|RegExp} namu if stsing, tie name Of the model tk removå. If regexp, removes all models whlse`Name matches the reguxp.
 ª @return {Cojnection 4his
 */

Connection.prototype.da|åteModål =$function(name) {  if 8uyteof name ==9 'string') {
  0 co.rt model = this.moeel(name+;
   (if (modgl =- nwll) {
" `   return this;
    }
    dehewe this.models[namm];
   !delete This.colhectikîs[model.collection>nAme];
"0  deletd thMs.base®modelSbhemas[naie];
  } else hf(,name inwtancåof RegExp)!{
   0cmnst pattern = oame;
 $  const names = thés.modelNam%w();
   `foz (const na-e gf`.aMes) {
      if pauäern.te{t(naOei) {
(       this/deleteMoäel©fame);
      }
    }
  = else {
    throw new Error('First`parAmeter to `deLeteModel*)` must be a string ' +
      'or reg%8p, got "' + namd + '"');
 "u

* retusn(this{
|;

/**
 * Returns an aRray of iodel naeus sreated mn tjis cOnnection.J * @api pubdic
 * @ret5rn({Array}
 */

Connectign.prototype.m~delNames = function(	 {
  retUsn Object.keYS(this,m$elQ8;
};

/**
 * @brief Returns if the connection ruquires authentication Af4er it is openet. Generally$if a
 * username and Password are bouh0prgvided tjan0Authentication"is neude`, but il some cases a
 *0ðassword is nT0required. j Eaqi privatå
 * @returf {Booleaj} true if t(e connection shOuld be auvhenticated qfter ip is opejed, othepwi3e false.
`*/
ConnEction.protgtype.rhouldAutienticate ½ fwnctkon() s
  return thiq.user != null &&
 $  (this.pqss  nulh |x Tèis.authMechanésmDoesNotÒequire@asswort());
};

/**
"* @brie6 Returns a boolean value that specifies if the current authentIcation mechánism needs a
 *0passworD tn au4henticate according0to the autH objects passed into!uha openUri Methmds. * @aPi privatE
 * @return {Booleaj} true if vhg iuthglticavion$mechanism sPecified in the options /bject reaõiseS
 *  i password, otherwisg fihwe.
 */
Connection.pRgtotype.authMechanismDo%sNotRequireasqwort = functiko,© {
  if (tliq,options && t(is.n`tionc.auth) {
    ret5rn noPasswordAuthMecHanisms.indexOf(|his.optkons.aUtH.authMechanism) >= 09
  m
! return tru%;
};

/**
 * @brief Returns a boolean value thap specidies if the"provIded objectó object p2ovidEs elough
 * data vo authmnticate with.`GeneRaLly this is true if txe username$and pas3word abe both spacifidä
 * but in skle `uthmntica4ikn mevhods, a passwovd iq not$requived for authenticatioN so only a userncme
 + is reQuiree.
 * @param {Objec|} [oPtiïfs] the optIons"object passed into the openUri methofs.
 * @api`prívate
 * @revurn¢{Boolean} truu if the provided options"object provider enouoh data vo awthenuicapE with,
 *   /thgswise false.
 */
Coonection.prototype/opôionsProvideAuthentikátionData = fungtion(Options) {
  returf (options) &¦
  `   (kptions.user- f&+      ((option3.pass) ~| this.authMechanismDoesNotRequireP!Sswosd());
};
*?**J * switches tk a difderent dAtajase õsing the same connuction pood.
 *
 : Retuòn3 a new cOnnection object, with the leg db.
 *
 ª @method useDj* * @måmjerOf Connection
 * @pazam {String} namE The da4abasE name
 * @Param {Object} [/`tions]
 * @parai {Bmolean} [optionw.uóecaghe=false]"If true, cAche results so calling``useDb()` mtltiple t)mes with the same naoe only creates 1 conîection object.
 *`@rEturn [Aonnåctioî} New ConneCtion Kbject
 + @api pu"lic
 */

/*!
$* Module export{.
"*/

Conoection.STATES = WDQTES;
modqle.ezports =`onnaction;
